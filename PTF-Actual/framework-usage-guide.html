<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS Playwright Test Framework - Complete Usage Guide</title>
    <style>
        :root {
            --primary: rgb(148, 25, 107);
            --primary-dark: rgb(118, 20, 86);
            --primary-light: #fdf2f8;
            --secondary: #64748b;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --bg: #f8fafc;
            --bg-dark: #1e293b;
            --text: #1e293b;
            --text-light: #64748b;
            --border: #e2e8f0;
            --code-bg: #f1f5f9;
            --code-border: #cbd5e1;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text);
            background: var(--bg);
        }
        .container { max-width: 1400px; margin: 0 auto; display: flex; }

        /* Sidebar Navigation */
        .sidebar {
            width: 300px;
            height: 100vh;
            position: fixed;
            overflow-y: auto;
            background: white;
            border-right: 1px solid var(--border);
            padding: 20px 0;
        }
        .sidebar h1 {
            font-size: 1.25rem;
            padding: 0 20px 15px;
            border-bottom: 1px solid var(--border);
            color: var(--primary);
        }
        .nav-section { margin-top: 15px; }
        .nav-section h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--secondary);
            padding: 8px 20px;
            letter-spacing: 0.05em;
        }
        .nav-section a {
            display: block;
            padding: 8px 20px 8px 30px;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .nav-section a:hover { background: var(--bg); color: var(--primary); }
        .nav-section a.active { background: var(--primary-light); color: var(--primary); border-right: 3px solid var(--primary); }

        /* Main Content */
        .main-content {
            margin-left: 300px;
            padding: 40px 60px;
            flex: 1;
            max-width: calc(100% - 300px);
        }
        h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
            color: var(--text);
        }
        h3 {
            font-size: 1.5rem;
            margin: 30px 0 15px;
            color: var(--primary-dark);
        }
        h4 {
            font-size: 1.2rem;
            margin: 25px 0 10px;
            color: var(--secondary);
        }
        p { margin-bottom: 15px; }

        /* Code Blocks */
        pre {
            background: var(--code-bg);
            border: 1px solid var(--code-border);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 15px 0;
            font-size: 0.875rem;
            line-height: 1.5;
        }
        code {
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            background: var(--code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        pre code { background: none; padding: 0; }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9rem;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border);
        }
        th {
            background: var(--bg);
            font-weight: 600;
            color: var(--text);
        }
        tr:hover { background: #fafafa; }

        /* Info Boxes */
        .info-box {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid;
        }
        .info-box.tip { background: #f0fdf4; border-color: var(--success); }
        .info-box.warning { background: #fffbeb; border-color: var(--warning); }
        .info-box.note { background: var(--primary-light); border-color: var(--primary); }
        .info-box.danger { background: #fef2f2; border-color: var(--error); }
        .info-box strong { display: block; margin-bottom: 5px; }

        /* Feature Cards */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        .feature-card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            transition: box-shadow 0.2s;
        }
        .feature-card:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .feature-card h4 {
            margin: 0 0 10px;
            color: var(--primary);
            font-size: 1rem;
        }
        .feature-card p { font-size: 0.9rem; color: var(--text-light); margin: 0; }

        /* Architecture Diagram - Professional Compact Style */
        .arch-diagram {
            background: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-size: 0.8rem;
        }
        .arch-layer {
            background: white;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px 15px;
            margin-bottom: 8px;
            position: relative;
        }
        .arch-layer::after {
            content: 'â†“';
            position: absolute;
            bottom: -14px;
            left: 50%;
            transform: translateX(-50%);
            color: #94a3b8;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        .arch-layer:last-child::after { display: none; }
        .arch-layer-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }
        .arch-layer-icon {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
        }
        .arch-layer-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text);
        }
        .arch-layer-subtitle {
            font-size: 0.7rem;
            color: var(--text-light);
            margin-left: auto;
        }
        .arch-components {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .arch-component {
            background: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px 10px;
            flex: 1;
            min-width: 100px;
            max-width: 160px;
        }
        .arch-component-name {
            font-weight: 600;
            font-size: 0.75rem;
            color: var(--text);
        }
        .arch-component-desc {
            font-size: 0.65rem;
            color: var(--text-light);
            line-height: 1.3;
            margin-top: 2px;
        }
        /* Layer Colors */
        .layer-test .arch-layer-icon { background: #8b5cf6; }
        .layer-test { border-left: 3px solid #8b5cf6; }
        .layer-orchestration .arch-layer-icon { background: #f59e0b; }
        .layer-orchestration { border-left: 3px solid #f59e0b; }
        .layer-fixture .arch-layer-icon { background: #10b981; }
        .layer-fixture { border-left: 3px solid #10b981; }
        .layer-core .arch-layer-icon { background: #3b82f6; }
        .layer-core { border-left: 3px solid #3b82f6; }
        .layer-interaction .arch-layer-icon { background: #ec4899; }
        .layer-interaction { border-left: 3px solid #ec4899; }
        .layer-ai .arch-layer-icon { background: #14b8a6; }
        .layer-ai { border-left: 3px solid #14b8a6; }
        .layer-foundation .arch-layer-icon { background: #64748b; }
        .layer-foundation { border-left: 3px solid #64748b; }

        /* Data Flow Diagram - Professional Style */
        .flow-diagram {
            background: #1e293b;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: white;
            font-size: 0.8rem;
        }
        .flow-row {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .flow-node {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            padding: 8px 12px;
            text-align: center;
            min-width: 80px;
        }
        .flow-node-title {
            font-weight: 600;
            font-size: 0.75rem;
        }
        .flow-node-desc {
            font-size: 0.65rem;
            opacity: 0.7;
            margin-top: 2px;
        }
        .flow-arrow {
            display: flex;
            justify-content: center;
            font-size: 12px;
            color: #94a3b8;
            margin: 4px 0;
        }
        .flow-section {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
        }
        .flow-section-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #94a3b8;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 600;
        }

        /* Healing Flow - Professional Style */
        .healing-flow {
            background: #1e293b;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: white;
            font-size: 0.8rem;
        }
        .healing-step {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }
        .healing-step-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.7rem;
            flex-shrink: 0;
        }
        .healing-step-content { flex: 1; }
        .healing-step-title {
            font-weight: 600;
            font-size: 0.8rem;
            margin-bottom: 2px;
        }
        .healing-step-desc {
            font-size: 0.7rem;
            opacity: 0.7;
        }
        .healing-strategies {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin: 10px 0;
        }
        .healing-strategy {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 0.7rem;
            text-align: center;
        }
        .healing-result {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }
        .healing-result-box {
            padding: 10px 20px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.75rem;
        }
        .healing-result-box.success {
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.4);
        }
        .healing-result-box.failure {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.4);
        }
        @media (max-width: 768px) {
            .healing-strategies { grid-template-columns: repeat(2, 1fr); }
        }

        /* Method Signature */
        .method {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px 20px;
            margin: 15px 0;
        }
        .method-name {
            font-family: 'Fira Code', monospace;
            font-weight: 600;
            color: var(--primary-dark);
            font-size: 0.95rem;
        }
        .method-desc {
            margin-top: 8px;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-right: 5px;
        }
        .badge-primary { background: #fce7f3; color: var(--primary); }
        .badge-success { background: #dcfce7; color: #15803d; }
        .badge-warning { background: #fef3c7; color: #b45309; }
        .badge-error { background: #fee2e2; color: #b91c1c; }

        /* Section */
        section { margin-bottom: 60px; scroll-margin-top: 20px; }

        /* Search Styles */
        .search-container {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }
        .search-input {
            width: 100%;
            padding: 10px 12px 10px 36px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cpath d='m21 21-4.35-4.35'%3E%3C/path%3E%3C/svg%3E") no-repeat 10px center;
        }
        .search-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        .search-input::placeholder { color: var(--text-light); }
        .search-results {
            max-height: 400px;
            overflow-y: auto;
            border-top: 1px solid var(--border);
            display: none;
        }
        .search-results.active { display: block; }
        .search-result-item {
            padding: 10px 20px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
        }
        .search-result-item:hover { background: var(--bg); }
        .search-result-item:last-child { border-bottom: none; }
        .search-result-title {
            font-weight: 600;
            color: var(--text);
            font-size: 0.9rem;
            margin-bottom: 3px;
        }
        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
        }
        .search-result-preview {
            font-size: 0.8rem;
            color: var(--secondary);
            margin-top: 4px;
            line-height: 1.4;
        }
        .search-result-preview mark {
            background: #fef08a;
            color: inherit;
            padding: 0 2px;
            border-radius: 2px;
        }
        .search-no-results {
            padding: 20px;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }
        .search-stats {
            padding: 8px 20px;
            font-size: 0.75rem;
            color: var(--text-light);
            background: var(--bg);
            border-bottom: 1px solid var(--border);
        }
        .search-clear {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-light);
            font-size: 1.2rem;
            display: none;
            padding: 5px;
        }
        .search-clear:hover { color: var(--text); }
        .search-wrapper { position: relative; }
        .highlight-search {
            background: #fef08a !important;
            padding: 2px 0;
            border-radius: 2px;
            animation: highlightFade 2s ease-out;
        }
        @keyframes highlightFade {
            0% { background: #fbbf24; }
            100% { background: #fef08a; }
        }
        .kbd {
            display: inline-block;
            padding: 2px 6px;
            font-size: 0.7rem;
            font-family: monospace;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            margin-left: 5px;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { width: 250px; }
            .main-content { margin-left: 250px; padding: 30px; }
        }
        @media (max-width: 768px) {
            .sidebar { display: none; }
            .main-content { margin-left: 0; max-width: 100%; }
        }

        /* Print */
        @media print {
            .sidebar { display: none; }
            .main-content { margin-left: 0; max-width: 100%; }
            pre { white-space: pre-wrap; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <h1>CS Framework Guide</h1>

            <!-- Search Box -->
            <div class="search-container">
                <div class="search-wrapper">
                    <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off">
                    <button class="search-clear" id="searchClear" title="Clear search">&times;</button>
                </div>
                <div class="search-results" id="searchResults"></div>
            </div>

            <div class="nav-section">
                <h3>Getting Started</h3>
                <a href="#overview">Framework Overview</a>
                <a href="#architecture" style="padding-left:30px;font-size:0.85em">Architecture</a>
                <a href="#module-overview" style="padding-left:30px;font-size:0.85em">Module Overview</a>
                <a href="#installation">Installation</a>
                <a href="#project-structure">Project Structure</a>
                <a href="#configuration">Configuration</a>
                <a href="#browser-config" style="padding-left:30px;font-size:0.85em">Browser Config</a>
                <a href="#media-config" style="padding-left:30px;font-size:0.85em">Media Config</a>
                <a href="#smart-wait-config" style="padding-left:30px;font-size:0.85em">Smart Wait</a>
                <a href="#log-levels" style="padding-left:30px;font-size:0.85em">Log Levels</a>
            </div>

            <div class="nav-section">
                <h3>Core Concepts</h3>
                <a href="#page-objects">Page Objects</a>
                <a href="#generic-element-waits" style="padding-left:30px;font-size:0.85em">Generic Element Waits</a>
                <a href="#elements">Element Interactions</a>
                <a href="#wait-strategies">Wait Strategies</a>
                <a href="#smart-poller" style="padding-left:30px;font-size:0.85em">CSSmartPoller</a>
                <a href="#browser-management">Browser Management</a>
            </div>

            <div class="nav-section">
                <h3>Test Formats</h3>
                <a href="#spec-format">Spec Format Tests</a>
                <a href="#bdd-format">BDD/Cucumber Tests</a>
                <a href="#data-driven">Data-Driven Testing</a>
                <a href="#test-dependencies">Test Dependencies</a>
            </div>

            <div class="nav-section">
                <h3>API & Database</h3>
                <a href="#api-testing">API Testing</a>
                <a href="#api-auth" style="padding-left:30px;font-size:0.85em">Authentication</a>
                <a href="#file-upload-download" style="padding-left:30px;font-size:0.85em">File Upload/Download</a>
                <a href="#api-validators">API Validators</a>
                <a href="#database-testing">Database Testing</a>
                <a href="#database-config" style="padding-left:30px;font-size:0.85em">DB Configuration</a>
                <a href="#csdbutils" style="padding-left:30px;font-size:0.85em">CSDBUtils</a>
                <a href="#soap-testing">SOAP Testing</a>
            </div>

            <div class="nav-section">
                <h3>Execution</h3>
                <a href="#parallel-execution">Parallel Execution</a>
                <a href="#parallel-config" style="padding-left:30px;font-size:0.85em">Worker Config</a>
                <a href="#suite-execution">Suite Files</a>
                <a href="#pipeline-execution">Pipeline & CI/CD</a>
            </div>

            <div class="nav-section">
                <h3>Advanced Features</h3>
                <a href="#ai-self-healing">AI & Self-Healing</a>
                <a href="#reporting">Reporting & Evidence</a>
                <a href="#ado-integration">ADO Integration</a>
            </div>

            <div class="nav-section">
                <h3>Testing Types</h3>
                <a href="#performance-testing">Performance Testing</a>
                <a href="#visual-testing">Visual Testing</a>
                <a href="#mobile-testing">Mobile Testing</a>
            </div>

            <div class="nav-section">
                <h3>Data & Auth</h3>
                <a href="#variable-interpolation">Variable Interpolation</a>
                <a href="#data-management">Data Management</a>
                <a href="#authentication">Authentication</a>
                <a href="#diagnostics">Page Diagnostics</a>
            </div>

            <div class="nav-section">
                <h3>Utilities</h3>
                <a href="#utilities">Utility Classes</a>
                <a href="#assertions">Assertions</a>
                <a href="#network">Network Interception</a>
            </div>

            <div class="nav-section">
                <h3>Reference</h3>
                <a href="#cli-commands">CLI Commands</a>
                <a href="#api-reference">API Reference</a>
                <a href="#best-practices">Best Practices</a>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <!-- OVERVIEW -->
            <section id="overview">
                <h2>Framework Overview</h2>

                <p>CS Playwright Test Framework is an enterprise-grade, AI-powered test automation framework built on top of Microsoft Playwright. It provides a comprehensive solution for web, API, and database testing with intelligent self-healing capabilities, multi-format test support, and seamless Azure DevOps integration.</p>

                <div class="info-box note">
                    <strong>Why CS Playwright Test Framework?</strong>
                    <p>Built for enterprise teams who need reliable, maintainable, and scalable test automation. The framework eliminates common pain points like flaky tests (via AI self-healing), complex setup (via unified configuration), and limited reporting (via ADO integration and rich HTML reports).</p>
                </div>

                <h3>Core Philosophy</h3>
                <ul>
                    <li><strong>Convention over Configuration</strong> - Sensible defaults that work out of the box, with full customization available</li>
                    <li><strong>Test Format Flexibility</strong> - Write tests in Spec format (developers) or BDD/Gherkin (business stakeholders)</li>
                    <li><strong>Self-Healing by Design</strong> - AI-powered element recovery reduces test maintenance by up to 80%</li>
                    <li><strong>Enterprise Integration</strong> - Native Azure DevOps integration for test plans, results, and work items</li>
                    <li><strong>Full Stack Testing</strong> - UI, API, Database, and SOAP testing in a single framework</li>
                </ul>

                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>Multi-Format Testing</h4>
                        <p>Support for Spec format (Playwright-style) and BDD/Cucumber format with Gherkin syntax.</p>
                    </div>
                    <div class="feature-card">
                        <h4>AI-Powered Self-Healing</h4>
                        <p>Intelligent element healing with 8 strategies, failure prediction, and learning system.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Data-Driven Testing</h4>
                        <p>Support for CSV, JSON, Excel, XML, Database, and API data sources with filtering.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Comprehensive Reporting</h4>
                        <p>HTML, PDF, Excel reports with ADO integration and evidence collection.</p>
                    </div>
                    <div class="feature-card">
                        <h4>API & Database Testing</h4>
                        <p>Full HTTP client, SOAP support, and multi-database connectivity.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Parallel Execution</h4>
                        <p>Worker pool management with resource isolation and media capture.</p>
                    </div>
                </div>

                <h3>Key Capabilities</h3>
                <ul>
                    <li><strong>8-Level Configuration Hierarchy</strong> - CLI, Environment, Project, Common, Global levels</li>
                    <li><strong>Smart Wait System</strong> - DOM stability, network idle, spinner, animation detection</li>
                    <li><strong>Page Object Model</strong> - Decorator-based page objects with element self-healing</li>
                    <li><strong>64-Dimension Feature Extraction</strong> - Advanced element matching for healing</li>
                    <li><strong>Natural Language Element Finding</strong> - Describe elements in plain English</li>
                    <li><strong>Performance Testing</strong> - Load, stress, spike tests with Core Web Vitals</li>
                    <li><strong>Visual Testing</strong> - Baseline comparison with pixel-level accuracy</li>
                </ul>

                <!-- ARCHITECTURE -->
                <h3 id="architecture">Framework Architecture</h3>
                <p>The framework follows a layered architecture with clear separation of concerns. Each layer builds upon the previous, providing increasingly higher-level abstractions for test automation.</p>

                <div class="arch-diagram">
                    <!-- Test Layer -->
                    <div class="arch-layer layer-test">
                        <div class="arch-layer-header">
                            <div class="arch-layer-icon">T</div>
                            <div class="arch-layer-title">Test Layer</div>
                            <div class="arch-layer-subtitle">Test authoring formats</div>
                        </div>
                        <div class="arch-components">
                            <div class="arch-component">
                                <div class="arch-component-name">Spec Format</div>
                                <div class="arch-component-desc">describe(), test(), hooks</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">BDD/Cucumber</div>
                                <div class="arch-component-desc">Feature files, Given/When/Then</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Data-Driven</div>
                                <div class="arch-component-desc">CSV, JSON, Excel, DB sources</div>
                            </div>
                        </div>
                    </div>

                    <!-- Orchestration Layer -->
                    <div class="arch-layer layer-orchestration">
                        <div class="arch-layer-header">
                            <div class="arch-layer-icon">O</div>
                            <div class="arch-layer-title">Orchestration Layer</div>
                            <div class="arch-layer-subtitle">Execution management</div>
                        </div>
                        <div class="arch-components">
                            <div class="arch-component">
                                <div class="arch-component-name">Parallel Manager</div>
                                <div class="arch-component-desc">Worker pool, sharding</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Suite Executor</div>
                                <div class="arch-component-desc">YAML suites, ordering</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Data Iterator</div>
                                <div class="arch-component-desc">Row iteration, filtering</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Dependency Manager</div>
                                <div class="arch-component-desc">Test dependencies, workflows</div>
                            </div>
                        </div>
                    </div>

                    <!-- Fixture Layer -->
                    <div class="arch-layer layer-fixture">
                        <div class="arch-layer-header">
                            <div class="arch-layer-icon">F</div>
                            <div class="arch-layer-title">Fixture Layer</div>
                            <div class="arch-layer-subtitle">Dependency injection</div>
                        </div>
                        <div class="arch-components">
                            <div class="arch-component">
                                <div class="arch-component-name">Page Objects</div>
                                <div class="arch-component-desc">@Page decorator</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Browser Manager</div>
                                <div class="arch-component-desc">Lifecycle, contexts</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">API Client</div>
                                <div class="arch-component-desc">REST, SOAP, GraphQL</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Database Manager</div>
                                <div class="arch-component-desc">Multi-DB support</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Context Manager</div>
                                <div class="arch-component-desc">Shared state</div>
                            </div>
                        </div>
                    </div>

                    <!-- Core Services Layer -->
                    <div class="arch-layer layer-core">
                        <div class="arch-layer-header">
                            <div class="arch-layer-icon">C</div>
                            <div class="arch-layer-title">Core Services Layer</div>
                            <div class="arch-layer-subtitle">Cross-cutting concerns</div>
                        </div>
                        <div class="arch-components">
                            <div class="arch-component">
                                <div class="arch-component-name">Configuration</div>
                                <div class="arch-component-desc">8-level hierarchy</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Reporter</div>
                                <div class="arch-component-desc">HTML, PDF, Excel</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Evidence Collector</div>
                                <div class="arch-component-desc">Screenshots, videos</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">ADO Publisher</div>
                                <div class="arch-component-desc">Azure DevOps</div>
                            </div>
                        </div>
                    </div>

                    <!-- Interaction Layer -->
                    <div class="arch-layer layer-interaction">
                        <div class="arch-layer-header">
                            <div class="arch-layer-icon">I</div>
                            <div class="arch-layer-title">Interaction Layer</div>
                            <div class="arch-layer-subtitle">Element operations</div>
                        </div>
                        <div class="arch-components">
                            <div class="arch-component">
                                <div class="arch-component-name">Element Actions</div>
                                <div class="arch-component-desc">click, fill, select</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Smart Wait</div>
                                <div class="arch-component-desc">DOM stability, network</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Navigation</div>
                                <div class="arch-component-desc">Page transitions</div>
                            </div>
                        </div>
                    </div>

                    <!-- AI & Intelligence Layer -->
                    <div class="arch-layer layer-ai">
                        <div class="arch-layer-header">
                            <div class="arch-layer-icon">AI</div>
                            <div class="arch-layer-title">AI & Intelligence Layer</div>
                            <div class="arch-layer-subtitle">Self-healing capabilities</div>
                        </div>
                        <div class="arch-components">
                            <div class="arch-component">
                                <div class="arch-component-name">Self-Healing Engine</div>
                                <div class="arch-component-desc">8 recovery strategies</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Feature Extraction</div>
                                <div class="arch-component-desc">64-dimension analysis</div>
                            </div>
                            <div class="arch-component">
                                <div class="arch-component-name">Failure Prediction</div>
                                <div class="arch-component-desc">Pattern recognition</div>
                            </div>
                        </div>
                    </div>

                    <!-- Foundation Layer -->
                    <div class="arch-layer layer-foundation">
                        <div class="arch-layer-header">
                            <div class="arch-layer-icon">PW</div>
                            <div class="arch-layer-title">Foundation Layer</div>
                            <div class="arch-layer-subtitle">Microsoft Playwright</div>
                        </div>
                        <div class="arch-components">
                            <div class="arch-component" style="max-width: none;">
                                <div class="arch-component-name">Playwright Engine</div>
                                <div class="arch-component-desc">Browser automation, network interception, tracing, Chromium/Firefox/WebKit</div>
                            </div>
                        </div>
                    </div>
                </div>

                <h4>Architecture Layers Explained</h4>
                <table>
                    <thead><tr><th>Layer</th><th>Purpose</th><th>Key Components</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><strong>Test Layer</strong></td>
                            <td>Where test code lives - either Spec format or BDD format</td>
                            <td>CSSpecRunner, CSBDDRunner, describe/test/Given/When/Then</td>
                        </tr>
                        <tr>
                            <td><strong>Orchestration</strong></td>
                            <td>Manages test execution order, parallelization, and data iteration</td>
                            <td>CSParallelManager, CSSuiteRunner, CSSpecDataIterator</td>
                        </tr>
                        <tr>
                            <td><strong>Fixture Layer</strong></td>
                            <td>Provides test fixtures (page objects, API clients, DB connections)</td>
                            <td>CSBrowserManager, CSAPIClient, CSDatabaseManager</td>
                        </tr>
                        <tr>
                            <td><strong>Core Services</strong></td>
                            <td>Cross-cutting concerns: config, reporting, evidence collection</td>
                            <td>CSConfigurationManager, CSReporter, CSEvidenceCollector</td>
                        </tr>
                        <tr>
                            <td><strong>Interaction</strong></td>
                            <td>Element interactions with smart waiting and navigation</td>
                            <td>CSElement, CSSmartWait, CSNavigationManager</td>
                        </tr>
                        <tr>
                            <td><strong>AI & Intelligence</strong></td>
                            <td>Self-healing, feature extraction, and failure prediction</td>
                            <td>CSSelfHealingEngine, CSFeatureExtractor, CSFailurePredictor</td>
                        </tr>
                        <tr>
                            <td><strong>Foundation</strong></td>
                            <td>Underlying Playwright browser automation engine</td>
                            <td>Playwright Browser, Context, Page APIs</td>
                        </tr>
                    </tbody>
                </table>

                <!-- MODULE OVERVIEW -->
                <h3 id="module-overview">Module Overview</h3>
                <p>The framework is organized into focused modules, each handling a specific domain. Modules can be imported individually for tree-shaking benefits.</p>

                <h4>Core Modules</h4>
                <table>
                    <thead><tr><th>Module</th><th>Import Path</th><th>Purpose</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><strong>core</strong></td>
                            <td><code>@framework/core</code></td>
                            <td>Configuration management, context handling, base utilities</td>
                        </tr>
                        <tr>
                            <td><strong>spec</strong></td>
                            <td><code>@framework/spec</code></td>
                            <td>Spec format test runner: describe(), test(), hooks, fixtures</td>
                        </tr>
                        <tr>
                            <td><strong>bdd</strong></td>
                            <td><code>@framework/bdd</code></td>
                            <td>BDD/Cucumber runner: Given/When/Then, feature parsing, step definitions</td>
                        </tr>
                        <tr>
                            <td><strong>browser</strong></td>
                            <td><code>@framework/browser</code></td>
                            <td>Browser lifecycle, context management, page creation</td>
                        </tr>
                        <tr>
                            <td><strong>element</strong></td>
                            <td><code>@framework/element</code></td>
                            <td>Element interactions (click, fill, select), action tracking</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Testing Modules</h4>
                <table>
                    <thead><tr><th>Module</th><th>Import Path</th><th>Purpose</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><strong>api</strong></td>
                            <td><code>@framework/api</code></td>
                            <td>REST API testing: CSAPIClient, request/response handling, validators</td>
                        </tr>
                        <tr>
                            <td><strong>database</strong></td>
                            <td><code>@framework/database</code></td>
                            <td>Multi-DB support: SQL Server, Oracle, MySQL, PostgreSQL, MongoDB</td>
                        </tr>
                        <tr>
                            <td><strong>database-utils</strong></td>
                            <td><code>@framework/database-utils</code></td>
                            <td>Static DB utilities: CSDBUtils, comparison utilities</td>
                        </tr>
                        <tr>
                            <td><strong>data</strong></td>
                            <td><code>@framework/data</code></td>
                            <td>Data providers: CSV, JSON, Excel, XML, API, Database sources</td>
                        </tr>
                        <tr>
                            <td><strong>assertions</strong></td>
                            <td><code>@framework/assertions</code></td>
                            <td>Extended assertions: expect(), custom matchers, soft assertions</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Intelligence Modules</h4>
                <table>
                    <thead><tr><th>Module</th><th>Import Path</th><th>Purpose</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><strong>ai</strong></td>
                            <td><code>@framework/ai</code></td>
                            <td>AI services: natural language element finding, GPT integration</td>
                        </tr>
                        <tr>
                            <td><strong>self-healing</strong></td>
                            <td><code>@framework/self-healing</code></td>
                            <td>8-strategy healing engine, feature extraction, healing store</td>
                        </tr>
                        <tr>
                            <td><strong>wait</strong></td>
                            <td><code>@framework/wait</code></td>
                            <td>Smart wait system: DOM stability, network idle, custom conditions</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Reporting & Integration Modules</h4>
                <table>
                    <thead><tr><th>Module</th><th>Import Path</th><th>Purpose</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><strong>reporter</strong></td>
                            <td><code>@framework/reporter</code></td>
                            <td>Test reporting: CSReporter for pass/fail/info/warn logging</td>
                        </tr>
                        <tr>
                            <td><strong>reporting</strong></td>
                            <td><code>@framework/reporting</code></td>
                            <td>Report generation: HTML, PDF, Excel, JSON report formats</td>
                        </tr>
                        <tr>
                            <td><strong>evidence</strong></td>
                            <td><code>@framework/evidence</code></td>
                            <td>Evidence collection: screenshots, videos, HAR files, traces</td>
                        </tr>
                        <tr>
                            <td><strong>ado</strong></td>
                            <td><code>@framework/ado</code></td>
                            <td>Azure DevOps: test run publishing, work item linking, attachments</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Execution Modules</h4>
                <table>
                    <thead><tr><th>Module</th><th>Import Path</th><th>Purpose</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><strong>parallel</strong></td>
                            <td><code>@framework/parallel</code></td>
                            <td>Parallel execution: worker pool, resource isolation, sharding</td>
                        </tr>
                        <tr>
                            <td><strong>suite</strong></td>
                            <td><code>@framework/suite</code></td>
                            <td>Suite files: YAML-based test organization and execution</td>
                        </tr>
                        <tr>
                            <td><strong>pipeline</strong></td>
                            <td><code>@framework/pipeline</code></td>
                            <td>CI/CD integration: pipeline detection, artifact publishing</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Specialized Testing Modules</h4>
                <table>
                    <thead><tr><th>Module</th><th>Import Path</th><th>Purpose</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td><code>@framework/performance</code></td>
                            <td>Performance testing: load, stress, spike tests, Core Web Vitals</td>
                        </tr>
                        <tr>
                            <td><strong>visual</strong></td>
                            <td><code>@framework/visual</code></td>
                            <td>Visual regression: baseline comparison, diff generation</td>
                        </tr>
                        <tr>
                            <td><strong>mobile</strong></td>
                            <td><code>@framework/mobile</code></td>
                            <td>Mobile testing: device emulation, responsive testing</td>
                        </tr>
                        <tr>
                            <td><strong>network</strong></td>
                            <td><code>@framework/network</code></td>
                            <td>Network interception: request mocking, response stubbing</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Utility Modules</h4>
                <table>
                    <thead><tr><th>Module</th><th>Import Path</th><th>Purpose</th></tr></thead>
                    <tbody>
                        <tr>
                            <td><strong>utils</strong></td>
                            <td><code>@framework/utils</code></td>
                            <td>General utilities: string, date, file, object helpers</td>
                        </tr>
                        <tr>
                            <td><strong>auth</strong></td>
                            <td><code>@framework/auth</code></td>
                            <td>Authentication: OAuth, SAML, Basic Auth, session management</td>
                        </tr>
                        <tr>
                            <td><strong>navigation</strong></td>
                            <td><code>@framework/navigation</code></td>
                            <td>Navigation management: URL handling, page transitions</td>
                        </tr>
                        <tr>
                            <td><strong>media</strong></td>
                            <td><code>@framework/media</code></td>
                            <td>Media handling: screenshots, video recording configuration</td>
                        </tr>
                        <tr>
                            <td><strong>diagnostics</strong></td>
                            <td><code>@framework/diagnostics</code></td>
                            <td>Page diagnostics: console logs, network errors, page health</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Test Execution Flow</h4>
                <div class="flow-diagram">
                    <div class="flow-section-title">TEST EXECUTION PIPELINE</div>

                    <!-- Input Phase -->
                    <div class="flow-row">
                        <div class="flow-node">
                            <div class="flow-node-title">CLI</div>
                            <div class="flow-node-desc">Command input</div>
                        </div>
                        <div class="flow-node">
                            <div class="flow-node-title">Config Merge</div>
                            <div class="flow-node-desc">8-level hierarchy</div>
                        </div>
                        <div class="flow-node">
                            <div class="flow-node-title">Test Parser</div>
                            <div class="flow-node-desc">Spec / BDD</div>
                        </div>
                        <div class="flow-node">
                            <div class="flow-node-title">Suite Loader</div>
                            <div class="flow-node-desc">YAML suites</div>
                        </div>
                        <div class="flow-node">
                            <div class="flow-node-title">Scheduler</div>
                            <div class="flow-node-desc">Order & distribute</div>
                        </div>
                    </div>

                    <div class="flow-arrow">â†“</div>

                    <!-- Parallel Execution -->
                    <div class="flow-section">
                        <div class="flow-section-title">PARALLEL ORCHESTRATION</div>
                        <div class="flow-row">
                            <div class="flow-node"><div class="flow-node-title">Worker 1</div></div>
                            <div class="flow-node"><div class="flow-node-title">Worker 2</div></div>
                            <div class="flow-node"><div class="flow-node-title">Worker 3</div></div>
                            <div class="flow-node"><div class="flow-node-title">Worker ...</div></div>
                            <div class="flow-node"><div class="flow-node-title">Worker N</div></div>
                        </div>
                    </div>

                    <div class="flow-arrow">â†“</div>

                    <!-- Test Execution -->
                    <div class="flow-section">
                        <div class="flow-section-title">TEST EXECUTION</div>
                        <div class="flow-row">
                            <div class="flow-node">
                                <div class="flow-node-title">Fixtures</div>
                                <div class="flow-node-desc">Setup</div>
                            </div>
                            <div class="flow-node">
                                <div class="flow-node-title">Test Body</div>
                                <div class="flow-node-desc">Execution</div>
                            </div>
                            <div class="flow-node">
                                <div class="flow-node-title">Teardown</div>
                                <div class="flow-node-desc">Cleanup</div>
                            </div>
                        </div>
                        <div style="background: rgba(148,25,107,0.15); border-radius: 4px; padding: 8px; margin-top: 10px; text-align: center; font-size: 0.7rem;">
                            Element Interaction: <strong>Locate â†’ Wait â†’ Action â†’ Track â†’ Heal</strong>
                        </div>
                    </div>

                    <div class="flow-arrow">â†“</div>

                    <!-- Result Collection -->
                    <div class="flow-section">
                        <div class="flow-section-title">RESULT COLLECTION</div>
                        <div class="flow-row">
                            <div class="flow-node">
                                <div class="flow-node-title">Steps</div>
                                <div class="flow-node-desc">Results & Actions</div>
                            </div>
                            <div class="flow-node">
                                <div class="flow-node-title">Evidence</div>
                                <div class="flow-node-desc">Screenshots, Videos</div>
                            </div>
                            <div class="flow-node">
                                <div class="flow-node-title">Metrics</div>
                                <div class="flow-node-desc">Duration, Stats</div>
                            </div>
                        </div>
                    </div>

                    <div class="flow-arrow">â†“</div>

                    <!-- Report Generation -->
                    <div class="flow-section">
                        <div class="flow-section-title">REPORT GENERATION</div>
                        <div class="flow-row">
                            <div class="flow-node">
                                <div class="flow-node-title">HTML</div>
                                <div class="flow-node-desc">Interactive</div>
                            </div>
                            <div class="flow-node">
                                <div class="flow-node-title">Excel</div>
                                <div class="flow-node-desc">Spreadsheet</div>
                            </div>
                            <div class="flow-node">
                                <div class="flow-node-title">JSON</div>
                                <div class="flow-node-desc">Machine readable</div>
                            </div>
                            <div class="flow-node">
                                <div class="flow-node-title">ADO</div>
                                <div class="flow-node-desc">Azure DevOps</div>
                            </div>
                        </div>
                    </div>
                </div>

                <h4>Self-Healing Process</h4>
                <div class="healing-flow">
                    <div class="flow-section-title">SELF-HEALING ENGINE</div>

                    <div class="healing-step">
                        <div class="healing-step-number">1</div>
                        <div class="healing-step-content">
                            <div class="healing-step-title">Element Not Found</div>
                            <div class="healing-step-desc">Original selector fails to locate element</div>
                        </div>
                    </div>

                    <div class="healing-step">
                        <div class="healing-step-number">2</div>
                        <div class="healing-step-content">
                            <div class="healing-step-title">Check Healing Store</div>
                            <div class="healing-step-desc">Look up previously successful matches</div>
                        </div>
                    </div>

                    <div class="healing-step">
                        <div class="healing-step-number">3</div>
                        <div class="healing-step-content">
                            <div class="healing-step-title">Try 8 Healing Strategies</div>
                            <div class="healing-step-desc">Systematically attempt each recovery strategy</div>
                        </div>
                    </div>

                    <div class="healing-strategies">
                        <div class="healing-strategy">1. Text Content</div>
                        <div class="healing-strategy">2. Attribute Match</div>
                        <div class="healing-strategy">3. Structural Position</div>
                        <div class="healing-strategy">4. Parent/Child</div>
                        <div class="healing-strategy">5. CSS Relaxation</div>
                        <div class="healing-strategy">6. XPath Axis</div>
                        <div class="healing-strategy">7. Visual Features</div>
                        <div class="healing-strategy">8. AI/ML Score</div>
                    </div>

                    <div class="healing-step">
                        <div class="healing-step-number">4</div>
                        <div class="healing-step-content">
                            <div class="healing-step-title">Feature Extraction (64 Dimensions)</div>
                            <div class="healing-step-desc">Tag, ID, class, text, attributes, position, styles, DOM depth, aria labels</div>
                        </div>
                    </div>

                    <div class="healing-step">
                        <div class="healing-step-number">5</div>
                        <div class="healing-step-content">
                            <div class="healing-step-title">Calculate Similarity Score (0.0 - 1.0)</div>
                            <div class="healing-step-desc">Compare features against candidate elements</div>
                        </div>
                    </div>

                    <div class="healing-result">
                        <div class="healing-result-box success">
                            <div><strong>Score â‰¥ 0.85</strong></div>
                            <div style="margin-top: 4px;">Element Found â†’ Store â†’ Continue</div>
                        </div>
                        <div class="healing-result-box failure">
                            <div><strong>Score &lt; 0.85</strong></div>
                            <div style="margin-top: 4px;">Test Fails â†’ Log â†’ Report</div>
                        </div>
                    </div>
                </div>

                <div class="info-box tip">
                    <strong>Import Shorthand</strong>
                    <p>Replace <code>@framework/</code> with <code>@mdakhan.mak/cs-playwright-test-framework/</code> in actual imports. The shorthand is used for documentation readability.</p>
                </div>
            </section>

            <!-- INSTALLATION -->
            <section id="installation">
                <h2>Installation</h2>

                <h3>Prerequisites</h3>
                <ul>
                    <li>Node.js 20.0.0 or higher</li>
                    <li>npm 8.0.0 or higher</li>
                </ul>

                <h3>Install the Framework</h3>
                <pre><code># Install from npm registry
npm install @mdakhan.mak/cs-playwright-test-framework

# Install Playwright browsers
npx playwright install</code></pre>

                <h3>Optional Dependencies</h3>
                <p>Install these optional dependencies based on your needs:</p>
                <pre><code># For Excel file support
npm install exceljs

# For database testing
npm install mssql mysql2 pg oracledb mongodb redis

# For image processing (visual testing)
npm install sharp</code></pre>
            </section>

            <!-- PROJECT STRUCTURE -->
            <section id="project-structure">
                <h2>Project Structure</h2>

                <pre><code>my-test-project/
â”œâ”€â”€ config/
â”‚   â””â”€â”€ myproject/
â”‚       â”œâ”€â”€ common/
â”‚       â”‚   â””â”€â”€ common.env          # Shared configuration
â”‚       â””â”€â”€ environments/
â”‚           â”œâ”€â”€ dev.env             # Development environment
â”‚           â”œâ”€â”€ qa.env              # QA environment
â”‚           â””â”€â”€ prod.env            # Production environment
â”œâ”€â”€ test/
â”‚   â””â”€â”€ myproject/
â”‚       â”œâ”€â”€ pages/                  # Page Objects
â”‚       â”‚   â”œâ”€â”€ LoginPage.ts
â”‚       â”‚   â””â”€â”€ DashboardPage.ts
â”‚       â”œâ”€â”€ specs/                  # Spec format tests
â”‚       â”‚   â”œâ”€â”€ login.spec.ts
â”‚       â”‚   â””â”€â”€ dashboard.spec.ts
â”‚       â”œâ”€â”€ features/               # BDD feature files
â”‚       â”‚   â””â”€â”€ login.feature
â”‚       â”œâ”€â”€ steps/                  # Step definitions
â”‚       â”‚   â””â”€â”€ login.steps.ts
â”‚       â””â”€â”€ data/                   # Test data files
â”‚           â”œâ”€â”€ users.csv
â”‚           â””â”€â”€ users.json
â”œâ”€â”€ reports/                        # Generated reports
â””â”€â”€ package.json</code></pre>
            </section>

            <!-- CONFIGURATION -->
            <section id="configuration">
                <h2>Configuration</h2>

                <h3>Configuration Hierarchy</h3>
                <p>Configuration is loaded with the following priority (highest to lowest):</p>
                <ol>
                    <li><strong>CLI Arguments</strong> - <code>--tags=@smoke</code></li>
                    <li><strong>Environment Variables</strong> - <code>export BROWSER=chrome</code></li>
                    <li><strong>Project Environment</strong> - <code>config/project/environments/dev.env</code></li>
                    <li><strong>Project Common</strong> - <code>config/project/common/common.env</code></li>
                    <li><strong>Global Environment</strong> - <code>config/global/environments/dev.env</code></li>
                    <li><strong>Global Common</strong> - <code>config/global/common/common.env</code></li>
                </ol>

                <!-- Browser Configuration -->
                <h3 id="browser-config">Browser Configuration</h3>
                <p>Complete browser configuration options available in the framework:</p>

                <h4>Core Browser Options</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER</code></td><td>string</td><td>chrome</td><td>Browser engine: <code>chromium</code>, <code>chrome</code>, <code>firefox</code>, <code>webkit</code>, <code>safari</code>, <code>edge</code></td></tr>
                        <tr><td><code>HEADLESS</code></td><td>boolean</td><td>false</td><td>Run browser in headless mode (no UI)</td></tr>
                        <tr><td><code>BROWSER_LAUNCH_TIMEOUT</code></td><td>number</td><td>30000</td><td>Browser launch timeout in milliseconds</td></tr>
                        <tr><td><code>BROWSER_SLOWMO</code></td><td>number</td><td>0</td><td>Slow down operations by specified milliseconds (useful for debugging)</td></tr>
                        <tr><td><code>BROWSER_DEVTOOLS</code></td><td>boolean</td><td>false</td><td>Open browser DevTools automatically</td></tr>
                        <tr><td><code>BROWSER_REUSE_ENABLED</code></td><td>boolean</td><td>false</td><td>Reuse browser instance across tests for faster execution</td></tr>
                        <tr><td><code>BROWSER_REUSE_CLEAR_STATE</code></td><td>boolean</td><td>false</td><td>Clear cookies/storage when reusing browser</td></tr>
                        <tr><td><code>BROWSER_AUTO_RESTART_ON_CRASH</code></td><td>boolean</td><td>true</td><td>Automatically restart browser if it crashes</td></tr>
                        <tr><td><code>BROWSER_MAX_RESTART_ATTEMPTS</code></td><td>number</td><td>3</td><td>Maximum browser restart attempts before failing</td></tr>
                        <tr><td><code>BROWSER_RESTART_MAINTAIN_STATE</code></td><td>boolean</td><td>true</td><td>Restore browser state (cookies, URL) after restart</td></tr>
                    </tbody>
                </table>

                <h4>Viewport &amp; Display Options</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER_VIEWPORT_WIDTH</code></td><td>number</td><td>1920</td><td>Browser viewport width in pixels</td></tr>
                        <tr><td><code>BROWSER_VIEWPORT_HEIGHT</code></td><td>number</td><td>1080</td><td>Browser viewport height in pixels</td></tr>
                        <tr><td><code>BROWSER_COLOR_SCHEME</code></td><td>string</td><td>light</td><td>Color scheme: <code>light</code>, <code>dark</code>, <code>no-preference</code></td></tr>
                        <tr><td><code>BROWSER_REDUCED_MOTION</code></td><td>string</td><td>no-preference</td><td>Reduced motion: <code>reduce</code>, <code>no-preference</code></td></tr>
                        <tr><td><code>BROWSER_FORCED_COLORS</code></td><td>string</td><td>none</td><td>Forced colors mode: <code>active</code>, <code>none</code></td></tr>
                    </tbody>
                </table>

                <h4>Timeout Configuration</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER_ACTION_TIMEOUT</code></td><td>number</td><td>10000</td><td>Default timeout for element actions (click, fill, etc.)</td></tr>
                        <tr><td><code>BROWSER_NAVIGATION_TIMEOUT</code></td><td>number</td><td>30000</td><td>Timeout for page navigation operations</td></tr>
                        <tr><td><code>BROWSER_AUTO_WAIT_TIMEOUT</code></td><td>number</td><td>5000</td><td>Default auto-wait timeout for element visibility</td></tr>
                        <tr><td><code>DEFAULT_TIMEOUT</code></td><td>number</td><td>10000</td><td>General default timeout used by elements</td></tr>
                    </tbody>
                </table>

                <h4>Localization &amp; Geolocation</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER_LOCALE</code></td><td>string</td><td>en-US</td><td>Browser locale (e.g., <code>en-US</code>, <code>fr-FR</code>, <code>de-DE</code>)</td></tr>
                        <tr><td><code>BROWSER_TIMEZONE</code></td><td>string</td><td>America/New_York</td><td>Browser timezone ID (e.g., <code>Asia/Kolkata</code>, <code>Europe/London</code>)</td></tr>
                        <tr><td><code>BROWSER_GEOLOCATION_LAT</code></td><td>number</td><td>-</td><td>Geolocation latitude (e.g., <code>40.7128</code>)</td></tr>
                        <tr><td><code>BROWSER_GEOLOCATION_LON</code></td><td>number</td><td>-</td><td>Geolocation longitude (e.g., <code>-74.0060</code>)</td></tr>
                        <tr><td><code>BROWSER_PERMISSIONS</code></td><td>string[]</td><td>[]</td><td>Granted permissions: <code>geolocation,notifications,clipboard-read</code></td></tr>
                    </tbody>
                </table>

                <h4>Proxy Configuration</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER_PROXY_ENABLED</code></td><td>boolean</td><td>false</td><td>Enable proxy for browser requests</td></tr>
                        <tr><td><code>BROWSER_PROXY_SERVER</code></td><td>string</td><td>-</td><td>Proxy server URL (e.g., <code>http://proxy.example.com:8080</code>)</td></tr>
                        <tr><td><code>BROWSER_PROXY_USERNAME</code></td><td>string</td><td>-</td><td>Proxy authentication username</td></tr>
                        <tr><td><code>BROWSER_PROXY_PASSWORD</code></td><td>string</td><td>-</td><td>Proxy authentication password</td></tr>
                        <tr><td><code>BROWSER_PROXY_BYPASS</code></td><td>string</td><td>-</td><td>Comma-separated domains to bypass proxy (e.g., <code>*.local,localhost</code>)</td></tr>
                    </tbody>
                </table>

                <h4>HTTP Credentials &amp; Security</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER_HTTP_USERNAME</code></td><td>string</td><td>-</td><td>HTTP Basic Auth username</td></tr>
                        <tr><td><code>BROWSER_HTTP_PASSWORD</code></td><td>string</td><td>-</td><td>HTTP Basic Auth password</td></tr>
                        <tr><td><code>BROWSER_IGNORE_HTTPS_ERRORS</code></td><td>boolean</td><td>true</td><td>Ignore SSL certificate errors</td></tr>
                        <tr><td><code>BROWSER_USER_AGENT</code></td><td>string</td><td>-</td><td>Custom User-Agent string</td></tr>
                        <tr><td><code>BROWSER_EXTRA_HEADERS</code></td><td>JSON</td><td>-</td><td>Extra HTTP headers as JSON (e.g., <code>{"X-Custom":"value"}</code>)</td></tr>
                        <tr><td><code>BROWSER_OFFLINE</code></td><td>boolean</td><td>false</td><td>Emulate offline mode</td></tr>
                    </tbody>
                </table>

                <h4>Chrome/Chromium-Specific Options</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER_INCOGNITO</code></td><td>boolean</td><td>false</td><td>Run Chrome in incognito mode</td></tr>
                        <tr><td><code>BROWSER_DISABLE_GPU</code></td><td>boolean</td><td>false</td><td>Disable GPU acceleration</td></tr>
                        <tr><td><code>BROWSER_NO_SANDBOX</code></td><td>boolean</td><td>false</td><td>Disable sandbox (required for some CI environments)</td></tr>
                        <tr><td><code>BROWSER_CHROME_ARGS</code></td><td>string[]</td><td>[]</td><td>Custom Chrome arguments (comma-separated)</td></tr>
                    </tbody>
                </table>

                <h4>Firefox-Specific Options</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER_PRIVATE</code></td><td>boolean</td><td>false</td><td>Run Firefox in private browsing mode</td></tr>
                        <tr><td><code>BROWSER_FIREFOX_ARGS</code></td><td>string[]</td><td>[]</td><td>Custom Firefox arguments (comma-separated)</td></tr>
                    </tbody>
                </table>

                <div class="info-box tip">
                    <strong>Example: Complete Browser Configuration</strong>
                    <pre><code># Browser setup for CI/CD pipeline
BROWSER=chromium
HEADLESS=true
BROWSER_NO_SANDBOX=true
BROWSER_DISABLE_GPU=true
BROWSER_VIEWPORT_WIDTH=1920
BROWSER_VIEWPORT_HEIGHT=1080

# Timeouts
BROWSER_ACTION_TIMEOUT=15000
BROWSER_NAVIGATION_TIMEOUT=60000

# Proxy for corporate network
BROWSER_PROXY_ENABLED=true
BROWSER_PROXY_SERVER=http://proxy.corp.example.com:8080
BROWSER_PROXY_BYPASS=*.internal.com,localhost

# Locale and timezone
BROWSER_LOCALE=en-GB
BROWSER_TIMEZONE=Europe/London</code></pre>
                </div>

                <!-- Media Configuration -->
                <h3 id="media-config">Media Configuration (Video, Screenshots, Traces, HAR)</h3>
                <p>Configure how the framework captures test artifacts and evidence.</p>

                <h4>Video Recording</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>BROWSER_VIDEO</code></td><td>string</td><td>off</td><td>Video recording mode: <code>off</code>, <code>never</code>, <code>always</code>, <code>retain-on-failure</code></td></tr>
                        <tr><td><code>BROWSER_VIDEO_WIDTH</code></td><td>number</td><td>1280</td><td>Video capture width in pixels</td></tr>
                        <tr><td><code>BROWSER_VIDEO_HEIGHT</code></td><td>number</td><td>720</td><td>Video capture height in pixels</td></tr>
                    </tbody>
                </table>

                <div class="info-box note">
                    <strong>Video Recording Modes:</strong>
                    <ul>
                        <li><code>off</code> / <code>never</code> - No video recording (fastest execution)</li>
                        <li><code>always</code> - Record video for every test (highest storage usage)</li>
                        <li><code>retain-on-failure</code> - Record but only keep video if test fails (recommended for CI)</li>
                    </ul>
                </div>

                <h4>Trace Recording</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>TRACE_CAPTURE_MODE</code></td><td>string</td><td>never</td><td>Trace mode: <code>never</code>, <code>always</code>, <code>retain-on-failure</code></td></tr>
                        <tr><td><code>BROWSER_TRACE_ENABLED</code></td><td>boolean</td><td>false</td><td>Legacy flag - use <code>TRACE_CAPTURE_MODE</code> instead</td></tr>
                    </tbody>
                </table>

                <div class="info-box tip">
                    <strong>Playwright Trace Viewer</strong>
                    <p>Traces can be opened with: <code>npx playwright show-trace ./test-results/traces/trace.zip</code></p>
                    <p>Traces include: screenshots, DOM snapshots, network requests, console logs, and source code.</p>
                </div>

                <h4>HAR (HTTP Archive) Recording</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>HAR_CAPTURE_MODE</code></td><td>string</td><td>never</td><td>HAR mode: <code>never</code>, <code>always</code>, <code>retain-on-failure</code></td></tr>
                        <tr><td><code>BROWSER_HAR_ENABLED</code></td><td>boolean</td><td>false</td><td>Legacy flag - use <code>HAR_CAPTURE_MODE</code> instead</td></tr>
                        <tr><td><code>BROWSER_HAR_OMIT_CONTENT</code></td><td>boolean</td><td>false</td><td>Omit response body content from HAR (reduces file size)</td></tr>
                    </tbody>
                </table>

                <h4>Screenshot Configuration</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>SCREENSHOT_ON_FAILURE</code></td><td>boolean</td><td>true</td><td>Capture screenshot on test failure</td></tr>
                        <tr><td><code>SCREENSHOT_ON_PASS</code></td><td>boolean</td><td>false</td><td>Capture screenshot on test pass</td></tr>
                        <tr><td><code>SCREENSHOT_FULL_PAGE</code></td><td>boolean</td><td>false</td><td>Capture full page screenshot (scrollable content)</td></tr>
                    </tbody>
                </table>

                <h4>Console Log Capture</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>CONSOLE_LOG_CAPTURE</code></td><td>boolean</td><td>true</td><td>Capture browser console logs during test execution</td></tr>
                    </tbody>
                </table>

                <div class="info-box tip">
                    <strong>Example: Media Configuration for CI/CD</strong>
                    <pre><code># Capture artifacts only on failure to save storage
BROWSER_VIDEO=retain-on-failure
BROWSER_VIDEO_WIDTH=1280
BROWSER_VIDEO_HEIGHT=720

TRACE_CAPTURE_MODE=retain-on-failure
HAR_CAPTURE_MODE=retain-on-failure
BROWSER_HAR_OMIT_CONTENT=true  # Reduce HAR file size

SCREENSHOT_ON_FAILURE=true
SCREENSHOT_FULL_PAGE=true
CONSOLE_LOG_CAPTURE=true</code></pre>
                </div>

                <!-- Smart Wait Configuration -->
                <h3 id="smart-wait-config">Smart Wait Configuration</h3>
                <p>Smart Wait automatically handles element visibility, stability, spinners, animations, and network activity before interacting with elements. This reduces flaky tests without manual waits.</p>

                <h4>Smart Wait Levels</h4>
                <table>
                    <thead>
                        <tr><th>Level</th><th>Description</th><th>Features</th><th>Use Case</th></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>off</code></td>
                            <td>Disabled</td>
                            <td>No automatic waits</td>
                            <td>Maximum speed, manual control required</td>
                        </tr>
                        <tr>
                            <td><code>minimal</code></td>
                            <td>Basic waits (Default)</td>
                            <td>Visibility + Spinner detection + Stale element retry (2 retries)</td>
                            <td>Fast execution with essential stability</td>
                        </tr>
                        <tr>
                            <td><code>standard</code></td>
                            <td>Balanced</td>
                            <td>Visibility + Stability + Spinners + Animations + DOM stability + Stale retry (3)</td>
                            <td>Most applications, good balance of speed/reliability</td>
                        </tr>
                        <tr>
                            <td><code>strict</code></td>
                            <td>Maximum reliability</td>
                            <td>All features: Visibility + Stability + Obscured check + Spinners + Network idle + Animations + DOM + Stale retry (3)</td>
                            <td>Complex SPAs, highly dynamic pages</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Smart Wait Feature Comparison</h4>
                <table>
                    <thead>
                        <tr><th>Feature</th><th>OFF</th><th>MINIMAL</th><th>STANDARD</th><th>STRICT</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>Wait for Visible</td><td>-</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>Wait for Stable</td><td>-</td><td>-</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>Wait for Not Obscured</td><td>-</td><td>-</td><td>-</td><td>Yes</td></tr>
                        <tr><td>Wait for Spinners (before)</td><td>-</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>Wait for Spinners (after)</td><td>-</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>Wait for Network Idle</td><td>-</td><td>-</td><td>-</td><td>Yes</td></tr>
                        <tr><td>Wait for Animations</td><td>-</td><td>-</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>Wait for DOM Stable</td><td>-</td><td>-</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>Stale Element Retry</td><td>-</td><td>2x</td><td>3x</td><td>3x</td></tr>
                    </tbody>
                </table>

                <h4>Smart Wait Environment Variables</h4>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>SMART_WAIT_LEVEL</code></td><td>string</td><td>minimal</td><td>Smart wait level: <code>off</code>, <code>minimal</code>, <code>standard</code>, <code>strict</code></td></tr>
                        <tr><td><code>SMART_WAIT_DEFAULT_TIMEOUT</code></td><td>number</td><td>10000</td><td>Default timeout for smart wait operations (ms)</td></tr>
                        <tr><td><code>SMART_WAIT_DOM_STABILITY_MS</code></td><td>number</td><td>100</td><td>Time to wait for DOM to stabilize (ms)</td></tr>
                        <tr><td><code>SMART_WAIT_NETWORK_IDLE_MS</code></td><td>number</td><td>500</td><td>Time to wait for network to be idle (ms)</td></tr>
                        <tr><td><code>SMART_WAIT_ANIMATION_TIMEOUT</code></td><td>number</td><td>5000</td><td>Maximum time to wait for animations (ms)</td></tr>
                        <tr><td><code>SMART_WAIT_SPINNER_SELECTORS</code></td><td>string</td><td>.spinner,.loading,.loader,[aria-busy="true"]</td><td>CSS selectors for spinner/loading elements (comma-separated)</td></tr>
                        <tr><td><code>SMART_WAIT_NETWORK_IGNORE</code></td><td>string</td><td>analytics,tracking,heartbeat,favicon</td><td>URL patterns to ignore for network idle (comma-separated)</td></tr>
                    </tbody>
                </table>

                <div class="info-box tip">
                    <strong>Example: Smart Wait Configuration</strong>
                    <pre><code># For most applications - balanced approach
SMART_WAIT_LEVEL=standard
SMART_WAIT_DEFAULT_TIMEOUT=15000

# For highly dynamic SPAs with many spinners
SMART_WAIT_LEVEL=strict
SMART_WAIT_SPINNER_SELECTORS=.spinner,.loading,.loader,.mat-spinner,[aria-busy="true"],.skeleton
SMART_WAIT_NETWORK_IGNORE=analytics,tracking,heartbeat,favicon,telemetry

# For simple static pages or API testing - maximum speed
SMART_WAIT_LEVEL=off</code></pre>
                </div>

                <!-- Log Levels -->
                <h3 id="log-levels">Log Levels</h3>
                <p>Control the verbosity of framework logging output.</p>

                <h4>Available Log Levels</h4>
                <table>
                    <thead>
                        <tr><th>Level</th><th>Outputs</th><th>Use Case</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>DEBUG</code></td><td>DEBUG, INFO, WARN, ERROR, PASS, FAIL</td><td>Development and troubleshooting - most verbose</td></tr>
                        <tr><td><code>INFO</code></td><td>INFO, WARN, ERROR, PASS, FAIL</td><td>Normal execution - recommended for CI/CD</td></tr>
                        <tr><td><code>WARN</code></td><td>WARN, ERROR, PASS, FAIL</td><td>Only warnings and errors</td></tr>
                        <tr><td><code>ERROR</code></td><td>ERROR, FAIL</td><td>Only errors - minimal output</td></tr>
                    </tbody>
                </table>

                <h4>Log Level Configuration</h4>
                <pre><code># In environment file
LOG_LEVEL=INFO

# Via CLI
npx cs-playwright-test --log-level=DEBUG

# In pipeline configuration
defaults:
  logLevel: INFO</code></pre>

                <div class="info-box note">
                    <strong>Environment-Specific Defaults:</strong>
                    <ul>
                        <li><strong>Local development:</strong> <code>LOG_LEVEL=DEBUG</code> for verbose output</li>
                        <li><strong>CI/CD Pipeline:</strong> <code>LOG_LEVEL=INFO</code> for balanced output</li>
                        <li><strong>Production monitoring:</strong> <code>LOG_LEVEL=WARN</code> for minimal noise</li>
                    </ul>
                </div>

                <!-- Download Configuration -->
                <h3 id="download-config">File Download Configuration</h3>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>DOWNLOAD_AUTO_SAVE</code></td><td>boolean</td><td>true</td><td>Automatically save downloaded files with proper names</td></tr>
                    </tbody>
                </table>

                <div class="info-box note">
                    <strong>Browser-Specific Download Behavior:</strong>
                    <ul>
                        <li><strong>Chromium/Edge:</strong> Download events work reliably</li>
                        <li><strong>Firefox:</strong> May have issues with Blob downloads</li>
                        <li><strong>WebKit/Safari:</strong> Known issues with download events - auto-save may not work reliably</li>
                    </ul>
                </div>

                <!-- Common Configuration Options Summary -->
                <h3>Complete Configuration Example</h3>
                <pre><code># ===========================================
# Application Configuration
# ===========================================
PROJECT=myproject
ENVIRONMENT=dev
BASE_URL=https://app.example.com
LOGIN_URL=${BASE_URL}/login

# ===========================================
# Browser Configuration
# ===========================================
BROWSER=chromium
HEADLESS=false
BROWSER_VIEWPORT_WIDTH=1920
BROWSER_VIEWPORT_HEIGHT=1080
BROWSER_ACTION_TIMEOUT=15000
BROWSER_NAVIGATION_TIMEOUT=30000
BROWSER_LOCALE=en-US
BROWSER_TIMEZONE=America/New_York

# ===========================================
# Media Artifacts
# ===========================================
BROWSER_VIDEO=retain-on-failure
TRACE_CAPTURE_MODE=retain-on-failure
HAR_CAPTURE_MODE=never
SCREENSHOT_ON_FAILURE=true
SCREENSHOT_FULL_PAGE=true

# ===========================================
# Smart Wait
# ===========================================
SMART_WAIT_LEVEL=minimal
SMART_WAIT_DEFAULT_TIMEOUT=10000
SMART_WAIT_SPINNER_SELECTORS=.spinner,.loading,.loader,[aria-busy="true"]

# ===========================================
# Logging
# ===========================================
LOG_LEVEL=INFO

# ===========================================
# Test Execution
# ===========================================
RETRY_COUNT=2
PARALLEL_WORKERS=4

# ===========================================
# Credentials (use ENCRYPTED: prefix for sensitive values)
# ===========================================
ADMIN_USERNAME=admin
ADMIN_PASSWORD=ENCRYPTED:eyJlbmNyeXB0ZWQiOi...</code></pre>

                <h3>Accessing Configuration in Tests</h3>
                <pre><code>// In spec format tests
test('Example test', async ({ config }) => {
    const baseUrl = config.get('BASE_URL');
    const password = config.get('PASSWORD', 'default123');  // With default
    const timeout = config.getNumber('TIMEOUT', 30000);
    const isHeadless = config.getBoolean('HEADLESS', false);
});

// In page objects
public async navigate(): Promise&lt;void&gt; {
    const baseUrl = this.config.get('BASE_URL');
    await this.page.goto(baseUrl);
}</code></pre>

                <div class="info-box tip">
                    <strong>Tip: Variable Interpolation</strong>
                    Use <code>${VAR_NAME}</code> syntax in config files to reference other variables:
                    <code>LOGIN_URL=${BASE_URL}/auth/login</code>
                </div>

                <div class="info-box note">
                    <strong>Note: Encrypted Values</strong>
                    Prefix sensitive values with <code>ENCRYPTED:</code> and they will be automatically decrypted when accessed via <code>config.get()</code>.
                </div>
            </section>

            <!-- PAGE OBJECTS -->
            <section id="page-objects">
                <h2>Page Objects</h2>

                <h3>Creating a Page Object</h3>
                <pre><code>import { CSBasePage, CSPage, CSGetElement, CSGetElements, CSWebElement } from '@mdakhan.mak/cs-playwright-test-framework';

@CSPage('login')
export class LoginPage extends CSBasePage {

    @CSGetElement({
        css: 'input[name="username"]',
        description: 'Username input field',
        waitForVisible: true,
        selfHeal: true,
        alternativeLocators: [
            'xpath://input[@name="username"]',
            'placeholder:Username',
            'aria-label:Username'
        ]
    })
    public usernameField!: CSWebElement;

    @CSGetElement({
        css: 'input[name="password"]',
        description: 'Password input field',
        waitForVisible: true,
        selfHeal: true
    })
    public passwordField!: CSWebElement;

    @CSGetElement({
        css: 'button[type="submit"]',
        text: 'Login',
        role: 'button',
        selfHeal: true
    })
    public loginButton!: CSWebElement;

    @CSGetElements({
        css: '.error-message',
        description: 'Error messages on the page'
    })
    public errorMessages!: CSWebElement[];

    // Page methods
    public async login(username: string, password: string): Promise&lt;void&gt; {
        await this.usernameField.fill(username);
        await this.passwordField.fill(password);
        await this.loginButton.click();
    }

    public async verifyLoginSuccess(): Promise&lt;void&gt; {
        await this.page.waitForURL('**/dashboard**');
        CSReporter.pass('Login successful');
    }

    // Override navigation
    public async navigate(): Promise&lt;void&gt; {
        const baseUrl = this.config.get('BASE_URL');
        await this.page.goto(`${baseUrl}/login`);
        await this.waitForPageLoad();
    }

    // Page state verification
    public async isAt(): Promise&lt;boolean&gt; {
        return await this.usernameField.isVisible();
    }
}</code></pre>

                <h3>@CSGetElement Options</h3>
                <table>
                    <thead>
                        <tr><th>Option</th><th>Type</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>css</code></td><td>string</td><td>CSS selector</td></tr>
                        <tr><td><code>xpath</code></td><td>string</td><td>XPath selector</td></tr>
                        <tr><td><code>text</code></td><td>string</td><td>Text content matcher</td></tr>
                        <tr><td><code>role</code></td><td>string</td><td>ARIA role (button, textbox, etc.)</td></tr>
                        <tr><td><code>testId</code></td><td>string</td><td>data-testid attribute</td></tr>
                        <tr><td><code>placeholder</code></td><td>string</td><td>Placeholder text</td></tr>
                        <tr><td><code>label</code></td><td>string</td><td>Associated label text</td></tr>
                        <tr><td><code>description</code></td><td>string</td><td>Human-readable description</td></tr>
                        <tr><td><code>waitForVisible</code></td><td>boolean</td><td>Wait for element visibility</td></tr>
                        <tr><td><code>waitForEnabled</code></td><td>boolean</td><td>Wait for element to be enabled</td></tr>
                        <tr><td><code>selfHeal</code></td><td>boolean</td><td>Enable AI self-healing</td></tr>
                        <tr><td><code>alternativeLocators</code></td><td>string[]</td><td>Fallback locators</td></tr>
                        <tr><td><code>timeout</code></td><td>number</td><td>Element-specific timeout (ms)</td></tr>
                    </tbody>
                </table>

                <h3>CSBasePage - Complete Method Reference</h3>
                <p>CSBasePage is the base class for all page objects. It provides navigation, element interaction, wait utilities, and access to configuration.</p>

                <h4>Navigation Methods</h4>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>navigate(url?: string)</code></td><td>Navigate to URL (default: BASE_URL)</td></tr>
                        <tr><td><code>navigateWithRetry(url, maxRetries)</code></td><td>Navigate with automatic retry on failure</td></tr>
                        <tr><td><code>refresh()</code></td><td>Refresh the current page</td></tr>
                        <tr><td><code>goBack()</code></td><td>Navigate to previous page in history</td></tr>
                        <tr><td><code>goForward()</code></td><td>Navigate to next page in history</td></tr>
                        <tr><td><code>getCurrentUrl()</code></td><td>Get current page URL</td></tr>
                        <tr><td><code>getTitle()</code></td><td>Get page title</td></tr>
                        <tr><td><code>waitForNavigation(options?)</code></td><td>Wait for navigation to complete</td></tr>
                        <tr><td><code>waitForPageLoad()</code></td><td>Wait for page load complete state</td></tr>
                        <tr><td><code>waitForUrl(urlOrPattern, timeout?)</code></td><td>Wait for URL to match pattern</td></tr>
                        <tr><td><code>waitForUrlChange(timeout?)</code></td><td>Wait for URL to change from current</td></tr>
                    </tbody>
                </table>

                <h4>Navigation Examples</h4>
                <pre><code>// Spec Format
test('Navigation operations', async ({ loginPage, dashboardPage }) => {
    await loginPage.navigate();  // Uses BASE_URL
    await loginPage.navigate('https://example.com/login');
    await loginPage.navigateWithRetry('https://example.com', 3);

    const currentUrl = await loginPage.getCurrentUrl();
    const title = await loginPage.getTitle();

    await loginPage.submitButton.click();
    await loginPage.waitForUrl('**/dashboard**');
    await loginPage.waitForNavigation();

    await dashboardPage.goBack();
    await dashboardPage.refresh();
});

// BDD Format
@Given('I navigate to the login page')
async navigateToLogin() {
    await this.loginPage.navigate();
}

@When('I wait for the dashboard to load')
async waitForDashboard() {
    await this.loginPage.waitForUrl('**/dashboard**');
}</code></pre>

                <h4>Page Wait Methods</h4>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>waitForPageLoad()</code></td><td>Wait for DOM content loaded state</td></tr>
                        <tr><td><code>waitForNetworkIdle(timeout?)</code></td><td>Wait for network requests to complete</td></tr>
                        <tr><td><code>waitForLoadState(state)</code></td><td>Wait for specific load state (load, domcontentloaded, networkidle)</td></tr>
                        <tr><td><code>waitForTimeout(ms)</code></td><td>Explicit wait (use sparingly)</td></tr>
                        <tr><td><code>waitForFunction(fn, arg?, options?)</code></td><td>Wait for JavaScript function to return truthy</td></tr>
                        <tr><td><code>waitForResponse(urlOrPredicate)</code></td><td>Wait for specific network response</td></tr>
                        <tr><td><code>waitForRequest(urlOrPredicate)</code></td><td>Wait for specific network request</td></tr>
                        <tr><td><code>waitForEvent(event, options?)</code></td><td>Wait for page event (dialog, popup, etc.)</td></tr>
                    </tbody>
                </table>

                <h4>Page Wait Examples</h4>
                <pre><code>// Spec Format
test('Wait operations', async ({ dashboardPage }) => {
    await dashboardPage.waitForPageLoad();
    await dashboardPage.waitForNetworkIdle();
    await dashboardPage.waitForLoadState('networkidle');

    // Wait for API response
    const response = await dashboardPage.waitForResponse('**/api/users');
    console.log('Status:', response.status());

    // Wait for JavaScript condition
    await dashboardPage.waitForFunction(() => {
        return document.querySelector('.data-loaded') !== null;
    });

    // Wait for popup
    const [popup] = await Promise.all([
        dashboardPage.waitForEvent('popup'),
        dashboardPage.openNewWindowButton.click()
    ]);
});

// BDD Format
@Then('the data should be loaded')
async waitForData() {
    await this.dashboardPage.waitForNetworkIdle();
    await this.dashboardPage.waitForFunction(() =>
        document.querySelector('.data-loaded') !== null
    );
}</code></pre>

                <h4 id="generic-element-waits">Generic Element Wait Methods</h4>
                <p>These methods use <code>CSSmartPoller</code> internally to poll for element states. They accept any <code>CSWebElement</code> and return a <code>PollResult</code> with success status and timing information.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>waitForElementToAppear(element, timeout?)</code></td><td>Wait for element to become visible (default: 15s)</td></tr>
                        <tr><td><code>waitForElementToDisappear(element, timeout?)</code></td><td>Wait for element to be hidden (default: 15s)</td></tr>
                        <tr><td><code>waitForElementText(element, text, timeout?)</code></td><td>Wait for element to contain specific text</td></tr>
                        <tr><td><code>waitForElementTextToDisappear(element, text, timeout?)</code></td><td>Wait for text to disappear from element</td></tr>
                        <tr><td><code>waitForTableData(tableElement, noDataText?, timeout?)</code></td><td>Wait for table to show actual data (not placeholder)</td></tr>
                    </tbody>
                </table>

                <h4>PollResult Return Type</h4>
                <pre><code>interface PollResult {
    success: boolean;   // Whether condition was met
    attempts: number;   // Number of polling attempts
    elapsed: number;    // Total time spent (ms)
    timedOut: boolean;  // Whether it timed out
}</code></pre>

                <h4>Generic Element Wait Examples</h4>
                <pre><code>// Wait for element to appear
test('Wait for loading complete', async ({ dashboardPage }) => {
    // Wait for spinner to disappear
    await dashboardPage.waitForElementToDisappear(dashboardPage.loadingSpinner);

    // Wait for data table to appear
    const result = await dashboardPage.waitForElementToAppear(dashboardPage.dataTable);
    if (result.success) {
        console.log(`Table appeared after ${result.elapsed}ms`);
    }
});

// Wait for text content
test('Wait for status message', async ({ orderPage }) => {
    // Wait for success message
    await orderPage.waitForElementText(orderPage.statusMessage, 'Order Confirmed');

    // Wait for loading text to disappear
    await orderPage.waitForElementTextToDisappear(orderPage.statusMessage, 'Processing...');
});

// Wait for table data (most common use case)
test('Verify table data loads', async ({ reportPage }) => {
    // Wait for "No data available" to disappear and real data to appear
    const result = await reportPage.waitForTableData(reportPage.resultsTable);

    if (result.success) {
        // Now safe to read table data
        const rows = await reportPage.getTableRows();
        expect(rows.length).toBeGreaterThan(0);
    }
});

// Page Object usage - simplified method
@CSPage('changes-history')
export class ChangesHistoryPage extends CSBasePage {
    @CSGetElement({ xpath: "//table[@class='data-table']" })
    public changesTable!: CSWebElement;

    // Simple one-liner using inherited method
    public async waitForChangesDataToLoad(timeout = 15000): Promise&lt;boolean&gt; {
        const result = await this.waitForTableData(this.changesTable, 'No data available', timeout);
        return result.success;
    }
}

// BDD Format
@Then('the changes table should display data')
async verifyChangesTableHasData() {
    const result = await this.changesPage.waitForTableData(this.changesPage.changesTable);
    if (!result.success) {
        throw new Error('Changes table did not load data within timeout');
    }
}</code></pre>

                <h4>Element Definition Methods</h4>
                <p><strong>IMPORTANT:</strong> Elements should always be defined using CSWebElement and accessed through decorators or the registerElement/getElement pattern. Never use direct Playwright methods like <code>page.getByRole()</code> or <code>page.locator()</code>.</p>
                <table>
                    <thead><tr><th>Pattern</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>@CSGetElement({ css: '...' })</code></td><td>Decorator to define element with CSS selector</td></tr>
                        <tr><td><code>@CSGetElement({ xpath: '...' })</code></td><td>Decorator to define element with XPath</td></tr>
                        <tr><td><code>@CSGetElement({ text: '...' })</code></td><td>Decorator to define element by text content</td></tr>
                        <tr><td><code>@CSGetElement({ role: '...' })</code></td><td>Decorator to define element by ARIA role</td></tr>
                        <tr><td><code>@CSGetElement({ testId: '...' })</code></td><td>Decorator to define element by data-testid</td></tr>
                        <tr><td><code>@CSGetElement({ id: '...' })</code></td><td>Decorator to define element by ID</td></tr>
                        <tr><td><code>@CSGetElement({ name: '...' })</code></td><td>Decorator to define element by name attribute</td></tr>
                        <tr><td><code>registerElement(name, CSWebElement)</code></td><td>Dynamic element registration in page object</td></tr>
                        <tr><td><code>getElement(name)</code></td><td>Retrieve registered element by name</td></tr>
                    </tbody>
                </table>

                <h4>Element Definition Examples</h4>
                <pre><code>// Page Object with Decorators (Recommended)
@CSPage('form')
export class FormPage extends CSBasePage {

    // By CSS selector
    @CSGetElement({
        css: 'button[type="submit"]',
        description: 'Submit button',
        selfHeal: true
    })
    public submitButton!: CSWebElement;

    // By role
    @CSGetElement({
        role: 'button',
        text: 'Learn more',
        description: 'Learn more link'
    })
    public learnMoreLink!: CSWebElement;

    // By test ID
    @CSGetElement({
        testId: 'agree-checkbox',
        description: 'Agree checkbox'
    })
    public agreeCheckbox!: CSWebElement;

    // By text content
    @CSGetElement({
        text: 'Welcome',
        description: 'Welcome heading'
    })
    public welcomeHeading!: CSWebElement;

    // By label (input associated with label)
    @CSGetElement({
        css: 'input[name="username"]',
        description: 'Username input',
        selfHeal: true,
        alternativeLocators: [
            'placeholder:Username',
            'css:#username'
        ]
    })
    public usernameField!: CSWebElement;

    // By placeholder
    @CSGetElement({
        css: 'input[placeholder="Search..."]',
        description: 'Search input'
    })
    public searchField!: CSWebElement;
}

// Dynamic Element Registration (Alternative)
@CSPage('dynamic')
export class DynamicPage extends CSBasePage {
    protected initializeElements(): void {
        // Register elements dynamically
        this.registerElement('submitBtn', new CSWebElement({
            css: 'button[type="submit"]',
            description: 'Submit button',
            selfHeal: true
        }));

        this.registerElement('searchInput', new CSWebElement({
            css: 'input[placeholder="Search..."]',
            description: 'Search input'
        }));
    }

    public async searchFor(term: string): Promise&lt;void&gt; {
        await this.getElement('searchInput').fill(term);
        await this.pressEnterKey();
    }
}

// Using elements in tests
test('Form submission', async ({ formPage }) => {
    await formPage.usernameField.fill('admin');
    await formPage.agreeCheckbox.check();
    await formPage.submitButton.click();
});

// BDD Format
@When('I click the submit button')
async clickSubmit() {
    await this.formPage.submitButton.click();
}

@When('I enter {string} in the username field')
async enterUsername(value: string) {
    await this.formPage.usernameField.fill(value);
}</code></pre>

                <h4>Dialog & Alert Methods (CSBasePage)</h4>
                <p>CSBasePage provides wrapper methods for handling dialogs. Use these instead of direct Playwright dialog handlers.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>acceptNextDialog(text?)</code></td><td>Accept the next dialog (OK button). Optionally provide text for prompts.</td></tr>
                        <tr><td><code>dismissNextDialog()</code></td><td>Dismiss the next dialog (Cancel button)</td></tr>
                        <tr><td><code>alwaysAcceptDialogs()</code></td><td>Auto-accept all dialogs during test execution</td></tr>
                        <tr><td><code>alwaysDismissDialogs()</code></td><td>Auto-dismiss all dialogs during test execution</td></tr>
                        <tr><td><code>getLastDialogMessage()</code></td><td>Get the message from the last handled dialog</td></tr>
                    </tbody>
                </table>

                <h4>Dialog Examples</h4>
                <pre><code>// Spec Format - Using CSBasePage wrapper methods
test('Dialog handling', async ({ settingsPage }) => {
    // Accept next alert dialog
    await settingsPage.acceptNextDialog();
    await settingsPage.showAlertButton.click();

    // Dismiss next confirmation dialog
    await settingsPage.dismissNextDialog();
    await settingsPage.showConfirmButton.click();

    // Accept prompt with input text
    await settingsPage.acceptNextDialog('John Doe');
    await settingsPage.showPromptButton.click();

    // Auto-accept all dialogs for the rest of the test
    await settingsPage.alwaysAcceptDialogs();
    await settingsPage.triggerMultipleDialogs();

    // Get last dialog message for verification
    const message = await settingsPage.getLastDialogMessage();
    console.log('Dialog said:', message);
});

// Page Object implementation
@CSPage('settings')
export class SettingsPage extends CSBasePage {

    @CSGetElement({ css: '#show-alert', description: 'Show alert button' })
    public showAlertButton!: CSWebElement;

    @CSGetElement({ css: '#show-confirm', description: 'Show confirm button' })
    public showConfirmButton!: CSWebElement;

    @CSGetElement({ css: '#show-prompt', description: 'Show prompt button' })
    public showPromptButton!: CSWebElement;

    public async confirmAndDelete(): Promise&lt;void&gt; {
        await this.acceptNextDialog();  // Prepare for confirm dialog
        await this.deleteButton.click(); // Triggers confirm dialog
    }

    public async cancelDelete(): Promise&lt;void&gt; {
        await this.dismissNextDialog(); // Prepare for confirm dialog
        await this.deleteButton.click(); // Triggers confirm dialog
    }
}

// BDD Format
@When('I accept the confirmation dialog')
async acceptDialog() {
    await this.settingsPage.acceptNextDialog();
}

@When('I dismiss the confirmation dialog')
async dismissDialog() {
    await this.settingsPage.dismissNextDialog();
}

@When('I enter {string} in the prompt dialog')
async enterPromptText(text: string) {
    await this.settingsPage.acceptNextDialog(text);
}</code></pre>

                <h4>Screenshot & Evidence Methods</h4>
                <p>Use CSReporter for evidence collection and CSWebElement for element screenshots. These integrate with the framework's reporting system.</p>
                <table>
                    <thead><tr><th>Method</th><th>Class</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>captureScreenshot(name)</code></td><td>CSReporter</td><td>Capture screenshot and add to evidence</td></tr>
                        <tr><td><code>captureFullPageScreenshot(name)</code></td><td>CSReporter</td><td>Capture full page screenshot</td></tr>
                        <tr><td><code>screenshot(options?)</code></td><td>CSWebElement</td><td>Take screenshot of specific element</td></tr>
                        <tr><td><code>screenshotToFile(path)</code></td><td>CSWebElement</td><td>Save element screenshot to file</td></tr>
                        <tr><td><code>addEvidence(name, data)</code></td><td>CSReporter</td><td>Add custom evidence to report</td></tr>
                    </tbody>
                </table>

                <h4>Screenshot Examples</h4>
                <pre><code>// Spec Format - Using framework wrapper methods
test('Screenshot operations', async ({ dashboardPage, reporter }) => {
    // Page screenshot via CSReporter (adds to evidence)
    await reporter.captureScreenshot('dashboard-initial');

    // Full page screenshot
    await reporter.captureFullPageScreenshot('dashboard-full');

    // Element screenshot via CSWebElement
    await dashboardPage.chartWidget.screenshot();  // Returns Buffer

    // Element screenshot to file
    await dashboardPage.chartWidget.screenshotToFile('chart.png');

    // Screenshot with options
    await dashboardPage.dataTable.screenshotAsPng();
    await dashboardPage.dataTable.screenshotAsJpeg(80);  // With quality

    // Screenshot with animations disabled
    await dashboardPage.animatedWidget.screenshotWithAnimationsDisabled();

    // Add custom evidence
    reporter.addEvidence('Test Data', { user: 'admin', action: 'view' });
});

// Page Object with screenshot methods
@CSPage('dashboard')
export class DashboardPage extends CSBasePage {

    @CSGetElement({ css: '.chart-widget', description: 'Chart widget' })
    public chartWidget!: CSWebElement;

    @CSGetElement({ css: '.data-table', description: 'Data table' })
    public dataTable!: CSWebElement;

    public async captureChartEvidence(): Promise&lt;void&gt; {
        await this.chartWidget.scrollIntoViewIfNeeded();
        await this.chartWidget.screenshotToFile('evidence/chart-current.png');
    }
}

// BDD Format
@Then('I capture a screenshot named {string}')
async captureScreenshot(name: string) {
    await this.reporter.captureScreenshot(name);
}

@Then('I capture the chart as evidence')
async captureChart() {
    await this.dashboardPage.chartWidget.screenshotToFile('evidence/chart.png');
}</code></pre>

                <h4>Keyboard & Mouse Methods (CSBasePage)</h4>
                <p>CSBasePage provides wrapper methods for keyboard and mouse operations. Use these instead of direct <code>page.keyboard</code> and <code>page.mouse</code> calls.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>pressKey(key)</code></td><td>Press any keyboard key (e.g., 'Enter', 'Tab', 'Control+a')</td></tr>
                        <tr><td><code>pressEnterKey()</code></td><td>Press Enter key</td></tr>
                        <tr><td><code>pressEscapeKey()</code></td><td>Press Escape key</td></tr>
                        <tr><td><code>pressTabKey()</code></td><td>Press Tab key</td></tr>
                        <tr><td><code>pressBackspaceKey()</code></td><td>Press Backspace key</td></tr>
                        <tr><td><code>pressDeleteKey()</code></td><td>Press Delete key</td></tr>
                        <tr><td><code>pressSelectAll()</code></td><td>Press Ctrl+A / Cmd+A to select all</td></tr>
                        <tr><td><code>pressCopy()</code></td><td>Press Ctrl+C / Cmd+C to copy</td></tr>
                        <tr><td><code>pressPaste()</code></td><td>Press Ctrl+V / Cmd+V to paste</td></tr>
                        <tr><td><code>pressCut()</code></td><td>Press Ctrl+X / Cmd+X to cut</td></tr>
                        <tr><td><code>typeText(text, delay?)</code></td><td>Type text character by character</td></tr>
                        <tr><td><code>mouseClickAt(x, y)</code></td><td>Click at specific coordinates</td></tr>
                        <tr><td><code>mouseDoubleClickAt(x, y)</code></td><td>Double-click at specific coordinates</td></tr>
                        <tr><td><code>scrollDown(pixels?)</code></td><td>Scroll page down (default: 300px)</td></tr>
                        <tr><td><code>scrollUp(pixels?)</code></td><td>Scroll page up (default: 300px)</td></tr>
                        <tr><td><code>scrollToTop()</code></td><td>Scroll to top of page</td></tr>
                        <tr><td><code>scrollToBottom()</code></td><td>Scroll to bottom of page</td></tr>
                        <tr><td><code>dragFromTo(fromX, fromY, toX, toY)</code></td><td>Drag from one point to another</td></tr>
                    </tbody>
                </table>

                <h4>Keyboard & Mouse Examples</h4>
                <pre><code>// Spec Format - Using CSBasePage wrapper methods
test('Keyboard and mouse operations', async ({ formPage }) => {
    // Keyboard shortcuts via CSBasePage
    await formPage.pressSelectAll();      // Ctrl+A / Cmd+A
    await formPage.pressCopy();           // Ctrl+C / Cmd+C
    await formPage.pressEscapeKey();      // Close modal

    // Common key presses
    await formPage.pressEnterKey();       // Submit form
    await formPage.pressTabKey();         // Move to next field

    // Type with delay (character by character)
    await formPage.typeText('Hello World', 100);  // 100ms delay between chars

    // Press any key combination
    await formPage.pressKey('Control+Shift+i');   // Open DevTools
    await formPage.pressKey('Alt+F4');            // Close window

    // Mouse operations
    await formPage.mouseClickAt(100, 200);        // Click at coordinates
    await formPage.mouseDoubleClickAt(150, 250);  // Double-click

    // Scrolling
    await formPage.scrollDown(500);               // Scroll down 500px
    await formPage.scrollUp(300);                 // Scroll up 300px
    await formPage.scrollToTop();                 // Scroll to page top
    await formPage.scrollToBottom();              // Scroll to page bottom

    // Drag and drop
    await formPage.dragFromTo(100, 100, 300, 300);
});

// Page Object with keyboard methods
@CSPage('editor')
export class EditorPage extends CSBasePage {

    @CSGetElement({ css: '.editor-content', description: 'Editor content area' })
    public editorContent!: CSWebElement;

    public async selectAllAndCopy(): Promise&lt;void&gt; {
        await this.editorContent.click();
        await this.pressSelectAll();
        await this.pressCopy();
    }

    public async pasteAndSubmit(): Promise&lt;void&gt; {
        await this.editorContent.click();
        await this.pressPaste();
        await this.pressEnterKey();
    }

    public async scrollToSeeContent(): Promise&lt;void&gt; {
        await this.scrollDown(500);
        await this.wait(500);  // Brief pause
        await this.scrollToBottom();
    }
}

// BDD Format
@When('I press Enter')
async pressEnter() {
    await this.formPage.pressEnterKey();
}

@When('I press Escape')
async pressEscape() {
    await this.formPage.pressEscapeKey();
}

@When('I scroll down the page')
async scrollDown() {
    await this.formPage.scrollDown(500);
}

@When('I select all and copy')
async selectAllCopy() {
    await this.editorPage.pressSelectAll();
    await this.editorPage.pressCopy();
}</code></pre>

                <h4>Viewport & Frame Methods (CSBasePage)</h4>
                <p>CSBasePage provides wrapper methods for viewport management, frame handling, and storage operations.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>setViewportSize(width, height)</code></td><td>Set viewport dimensions</td></tr>
                        <tr><td><code>setDesktopViewport()</code></td><td>Set viewport to 1920x1080</td></tr>
                        <tr><td><code>setMobileViewport(device?)</code></td><td>Set viewport for mobile device</td></tr>
                        <tr><td><code>setTabletViewport()</code></td><td>Set viewport for tablet</td></tr>
                        <tr><td><code>switchToFrame(frameSelector)</code></td><td>Switch to iframe by selector</td></tr>
                        <tr><td><code>switchToMainFrame()</code></td><td>Switch back to main frame</td></tr>
                        <tr><td><code>clearCookies()</code></td><td>Clear all cookies</td></tr>
                        <tr><td><code>getCookies()</code></td><td>Get all cookies</td></tr>
                        <tr><td><code>setCookie(cookie)</code></td><td>Set a cookie</td></tr>
                        <tr><td><code>clearLocalStorage()</code></td><td>Clear local storage</td></tr>
                        <tr><td><code>clearSessionStorage()</code></td><td>Clear session storage</td></tr>
                        <tr><td><code>setLocalStorageItem(key, value)</code></td><td>Set local storage item</td></tr>
                        <tr><td><code>getLocalStorageItem(key)</code></td><td>Get local storage item</td></tr>
                    </tbody>
                </table>

                <h4>Viewport & Frame Examples</h4>
                <pre><code>// Spec Format - Using CSBasePage wrapper methods
test('Viewport and frame operations', async ({ dashboardPage }) => {
    // Viewport management via CSBasePage
    await dashboardPage.setDesktopViewport();           // 1920x1080
    await dashboardPage.setMobileViewport('iPhone 12'); // Mobile viewport
    await dashboardPage.setTabletViewport();            // Tablet viewport
    await dashboardPage.setViewportSize(1366, 768);     // Custom size

    // Frame switching
    await dashboardPage.switchToFrame('#iframe-content');
    // ... interact with elements inside iframe ...
    await dashboardPage.switchToMainFrame();  // Return to main page

    // Cookie management
    const cookies = await dashboardPage.getCookies();
    await dashboardPage.clearCookies();
    await dashboardPage.setCookie({
        name: 'session',
        value: 'abc123',
        domain: '.example.com'
    });

    // Storage management
    await dashboardPage.setLocalStorageItem('theme', 'dark');
    const theme = await dashboardPage.getLocalStorageItem('theme');
    await dashboardPage.clearLocalStorage();
    await dashboardPage.clearSessionStorage();
});

// Page Object with utility methods
@CSPage('dashboard')
export class DashboardPage extends CSBasePage {

    @CSGetElement({ css: '#iframe-widget', description: 'Widget iframe' })
    public widgetIframe!: CSWebElement;

    public async interactWithWidget(): Promise&lt;void&gt; {
        await this.switchToFrame('#iframe-widget');
        // Interact with iframe content...
        await this.switchToMainFrame();
    }

    public async setTestMode(): Promise&lt;void&gt; {
        await this.setLocalStorageItem('testMode', 'true');
        await this.refresh();
    }

    public async clearUserData(): Promise&lt;void&gt; {
        await this.clearCookies();
        await this.clearLocalStorage();
        await this.clearSessionStorage();
    }

    public async testResponsiveLayout(): Promise&lt;void&gt; {
        // Test at different viewports
        await this.setDesktopViewport();
        await this.verifyLayout('desktop');

        await this.setTabletViewport();
        await this.verifyLayout('tablet');

        await this.setMobileViewport('iPhone 12');
        await this.verifyLayout('mobile');
    }
}

// Network interception (use CSNetworkInterceptor for advanced cases)
import { CSNetworkInterceptor } from '@mdakhan.mak/cs-playwright-test-framework/network';

test('API mocking', async ({ dashboardPage, browserManager }) => {
    const interceptor = new CSNetworkInterceptor(browserManager.getPage());

    // Mock API response
    await interceptor.mockResponse('**/api/users', {
        status: 200,
        body: JSON.stringify([{ id: 1, name: 'Mock User' }])
    });

    // Block specific requests
    await interceptor.blockRequest('**/analytics/**');

    // Run test with mocked responses
    await dashboardPage.loadUserList();
});

// BDD Format
@Given('I set the viewport to mobile')
async setMobileViewport() {
    await this.dashboardPage.setMobileViewport('iPhone 12');
}

@Given('I clear all cookies')
async clearCookies() {
    await this.dashboardPage.clearCookies();
}

@When('I switch to the widget iframe')
async switchToWidgetFrame() {
    await this.dashboardPage.switchToFrame('#iframe-widget');
}</code></pre>
            </section>

            <!-- ELEMENTS -->
            <section id="elements">
                <h2>Element Interactions - CSWebElement</h2>

                <p>CSWebElement wraps Playwright's Locator with 200+ convenience methods organized by category. All methods include automatic waiting, retry logic, and self-healing support.</p>

                <h3>Click Operations</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>click(options?)</code></td><td>Standard click with auto-wait and retry</td></tr>
                        <tr><td><code>dblclick(options?)</code></td><td>Double-click the element</td></tr>
                        <tr><td><code>tap(options?)</code></td><td>Tap for touch-enabled devices</td></tr>
                        <tr><td><code>hover(options?)</code></td><td>Hover over the element</td></tr>
                        <tr><td><code>focus()</code></td><td>Focus the element</td></tr>
                        <tr><td><code>blur()</code></td><td>Remove focus from element</td></tr>
                        <tr><td><code>clickWithForce()</code></td><td>Click bypassing actionability checks</td></tr>
                        <tr><td><code>clickWithTimeout(timeout)</code></td><td>Click with custom timeout</td></tr>
                        <tr><td><code>clickWithModifiers(modifiers)</code></td><td>Click with Ctrl/Alt/Shift/Meta</td></tr>
                        <tr><td><code>clickWithRetry(maxRetries)</code></td><td>Click with custom retry count</td></tr>
                        <tr><td><code>clickAndWaitForNavigation()</code></td><td>Click and wait for page load</td></tr>
                        <tr><td><code>clickAndWaitForResponse(urlPattern)</code></td><td>Click and wait for API response</td></tr>
                        <tr><td><code>clickAndWaitForDownload()</code></td><td>Click and wait for file download</td></tr>
                        <tr><td><code>clickIfVisible()</code></td><td>Click only if element is visible</td></tr>
                        <tr><td><code>clickIfExists()</code></td><td>Click only if element exists</td></tr>
                        <tr><td><code>rightClick()</code></td><td>Right-click (context menu)</td></tr>
                        <tr><td><code>tripleClick()</code></td><td>Triple-click to select all</td></tr>
                        <tr><td><code>clickCenter()</code></td><td>Click at element center</td></tr>
                        <tr><td><code>clickOffset(x, y)</code></td><td>Click at offset from top-left</td></tr>
                    </tbody>
                </table>

                <h4>Click Examples</h4>
                <pre><code>// Spec Format
test('Click operations', async ({ loginPage }) => {
    await loginPage.submitButton.click();
    await loginPage.submitButton.clickWithForce();
    await loginPage.submitButton.clickWithTimeout(5000);
    await loginPage.submitButton.clickWithModifiers(['Shift']);
    await loginPage.menuItem.clickAndWaitForNavigation();
    await loginPage.downloadBtn.clickAndWaitForDownload();
    await loginPage.closeModal.clickIfVisible();
});

// BDD Format
@When('I click the submit button')
async clickSubmit() {
    await this.loginPage.submitButton.click();
}

@When('I force click the overlay')
async forceClick() {
    await this.loginPage.overlay.clickWithForce();
}</code></pre>

                <h3>Input Operations</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>fill(value)</code></td><td>Clear and fill input with value</td></tr>
                        <tr><td><code>pressSequentially(text, options?)</code></td><td>Type text character by character</td></tr>
                        <tr><td><code>press(key)</code></td><td>Press a keyboard key</td></tr>
                        <tr><td><code>clear()</code></td><td>Clear input field content</td></tr>
                        <tr><td><code>setInputFiles(files)</code></td><td>Set files for file input</td></tr>
                        <tr><td><code>fillWithTimeout(value, timeout)</code></td><td>Fill with custom timeout</td></tr>
                        <tr><td><code>fillAndTab(value)</code></td><td>Fill and press Tab key</td></tr>
                        <tr><td><code>fillAndEnter(value)</code></td><td>Fill and press Enter key</td></tr>
                        <tr><td><code>fillIfEmpty(value)</code></td><td>Fill only if field is empty</td></tr>
                        <tr><td><code>appendText(text)</code></td><td>Append text without clearing</td></tr>
                        <tr><td><code>clearAndType(text)</code></td><td>Clear then type char by char</td></tr>
                        <tr><td><code>typeSlowly(text, delay)</code></td><td>Type with delay between chars</td></tr>
                        <tr><td><code>pressEnter()</code></td><td>Press Enter key</td></tr>
                        <tr><td><code>pressTab()</code></td><td>Press Tab key</td></tr>
                        <tr><td><code>pressEscape()</code></td><td>Press Escape key</td></tr>
                        <tr><td><code>pressBackspace()</code></td><td>Press Backspace key</td></tr>
                        <tr><td><code>selectAll()</code></td><td>Select all text (Ctrl+A)</td></tr>
                        <tr><td><code>copy()</code></td><td>Copy selected text (Ctrl+C)</td></tr>
                        <tr><td><code>paste()</code></td><td>Paste from clipboard (Ctrl+V)</td></tr>
                        <tr><td><code>cut()</code></td><td>Cut selected text (Ctrl+X)</td></tr>
                    </tbody>
                </table>

                <h4>Input Examples</h4>
                <pre><code>// Spec Format
test('Input operations', async ({ loginPage }) => {
    await loginPage.usernameField.fill('admin');
    await loginPage.usernameField.fillAndTab('admin');
    await loginPage.passwordField.fill('secret');
    await loginPage.searchField.fillAndEnter('search term');
    await loginPage.noteField.appendText(' additional text');
    await loginPage.codeField.typeSlowly('code123', 100);
    await loginPage.fileInput.setInputFiles('/path/to/file.pdf');
});

// BDD Format
@When('I enter username {string}')
async enterUsername(username: string) {
    await this.loginPage.usernameField.fill(username);
}

@When('I search for {string}')
async searchFor(term: string) {
    await this.loginPage.searchField.fillAndEnter(term);
}</code></pre>

                <h3>Selection Operations</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>selectOption(values)</code></td><td>Select option(s) by value, label, or index</td></tr>
                        <tr><td><code>selectByValue(value)</code></td><td>Select option by value attribute</td></tr>
                        <tr><td><code>selectByText(text)</code></td><td>Select option by visible text</td></tr>
                        <tr><td><code>selectByIndex(index)</code></td><td>Select option by zero-based index</td></tr>
                        <tr><td><code>selectMultiple(values)</code></td><td>Select multiple options (multi-select)</td></tr>
                        <tr><td><code>deselectAll()</code></td><td>Deselect all options</td></tr>
                        <tr><td><code>check()</code></td><td>Check a checkbox</td></tr>
                        <tr><td><code>uncheck()</code></td><td>Uncheck a checkbox</td></tr>
                        <tr><td><code>setChecked(checked)</code></td><td>Set checkbox to specific state</td></tr>
                        <tr><td><code>toggle()</code></td><td>Toggle checkbox state</td></tr>
                        <tr><td><code>isChecked()</code></td><td>Get checkbox/radio checked state</td></tr>
                        <tr><td><code>getSelectedOptions()</code></td><td>Get currently selected option(s)</td></tr>
                        <tr><td><code>getAllOptions()</code></td><td>Get all available options</td></tr>
                        <tr><td><code>getOptionCount()</code></td><td>Get count of available options</td></tr>
                    </tbody>
                </table>

                <h4>Selection Examples</h4>
                <pre><code>// Spec Format
test('Selection operations', async ({ formPage }) => {
    await formPage.countryDropdown.selectByText('United States');
    await formPage.countryDropdown.selectByValue('US');
    await formPage.countryDropdown.selectByIndex(5);
    await formPage.languageSelect.selectMultiple(['English', 'Spanish']);
    await formPage.agreeCheckbox.check();
    await formPage.newsletterCheckbox.setChecked(false);
    const selected = await formPage.countryDropdown.getSelectedOptions();
    const allOptions = await formPage.countryDropdown.getAllOptions();
});

// BDD Format
@When('I select country {string}')
async selectCountry(country: string) {
    await this.formPage.countryDropdown.selectByText(country);
}

@When('I agree to terms')
async agreeToTerms() {
    await this.formPage.agreeCheckbox.check();
}</code></pre>

                <h3>State & Property Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Return Type</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>isVisible()</code></td><td>boolean</td><td>Check if element is visible</td></tr>
                        <tr><td><code>isHidden()</code></td><td>boolean</td><td>Check if element is hidden</td></tr>
                        <tr><td><code>isEnabled()</code></td><td>boolean</td><td>Check if element is enabled</td></tr>
                        <tr><td><code>isDisabled()</code></td><td>boolean</td><td>Check if element is disabled</td></tr>
                        <tr><td><code>isEditable()</code></td><td>boolean</td><td>Check if element is editable</td></tr>
                        <tr><td><code>isChecked()</code></td><td>boolean</td><td>Check if checkbox/radio is checked</td></tr>
                        <tr><td><code>isFocused()</code></td><td>boolean</td><td>Check if element has focus</td></tr>
                        <tr><td><code>exists()</code></td><td>boolean</td><td>Check if element exists in DOM</td></tr>
                        <tr><td><code>count()</code></td><td>number</td><td>Get count of matching elements</td></tr>
                        <tr><td><code>textContent()</code></td><td>string</td><td>Get text content (including hidden)</td></tr>
                        <tr><td><code>innerText()</code></td><td>string</td><td>Get visible inner text</td></tr>
                        <tr><td><code>innerHTML()</code></td><td>string</td><td>Get inner HTML</td></tr>
                        <tr><td><code>inputValue()</code></td><td>string</td><td>Get input/textarea value</td></tr>
                        <tr><td><code>getAttribute(name)</code></td><td>string|null</td><td>Get attribute value</td></tr>
                        <tr><td><code>getProperty(name)</code></td><td>any</td><td>Get JavaScript property</td></tr>
                        <tr><td><code>getCssValue(property)</code></td><td>string</td><td>Get computed CSS property</td></tr>
                        <tr><td><code>hasClass(className)</code></td><td>boolean</td><td>Check if has CSS class</td></tr>
                        <tr><td><code>hasAttribute(name)</code></td><td>boolean</td><td>Check if has attribute</td></tr>
                        <tr><td><code>boundingBox()</code></td><td>object</td><td>Get element dimensions {x,y,width,height}</td></tr>
                    </tbody>
                </table>

                <h4>State Examples</h4>
                <pre><code>// Spec Format
test('State verification', async ({ formPage, expect }) => {
    const isVisible = await formPage.submitButton.isVisible();
    const isEnabled = await formPage.submitButton.isEnabled();
    const text = await formPage.welcomeMessage.textContent();
    const value = await formPage.usernameField.inputValue();
    const href = await formPage.helpLink.getAttribute('href');
    const hasError = await formPage.errorMessage.hasClass('error');
    const box = await formPage.modalDialog.boundingBox();

    expect.toBeTruthy(isVisible, 'Button should be visible');
    expect.toEqual(text, 'Welcome, Admin');
});

// BDD Format
@Then('the submit button should be enabled')
async verifySubmitEnabled() {
    const isEnabled = await this.formPage.submitButton.isEnabled();
    if (!isEnabled) throw new Error('Submit button is not enabled');
}

@Then('the welcome message should contain {string}')
async verifyWelcome(expected: string) {
    const text = await this.formPage.welcomeMessage.textContent();
    if (!text.includes(expected)) {
        throw new Error(`Expected "${expected}" in "${text}"`);
    }
}</code></pre>

                <h3>Wait Operations</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>waitFor(options?)</code></td><td>Wait for element state (attached, detached, visible, hidden)</td></tr>
                        <tr><td><code>waitForVisible(timeout?)</code></td><td>Wait until element becomes visible</td></tr>
                        <tr><td><code>waitForHidden(timeout?)</code></td><td>Wait until element disappears</td></tr>
                        <tr><td><code>waitForEnabled(timeout?)</code></td><td>Wait until element is enabled</td></tr>
                        <tr><td><code>waitForDisabled(timeout?)</code></td><td>Wait until element is disabled</td></tr>
                        <tr><td><code>waitForText(text, timeout?)</code></td><td>Wait for element to contain text</td></tr>
                        <tr><td><code>waitForTextChange(timeout?)</code></td><td>Wait for text content to change</td></tr>
                        <tr><td><code>waitForValue(value, timeout?)</code></td><td>Wait for input to have value</td></tr>
                        <tr><td><code>waitForAttribute(name, value, timeout?)</code></td><td>Wait for attribute to have value</td></tr>
                        <tr><td><code>waitForClass(className, timeout?)</code></td><td>Wait for element to have class</td></tr>
                        <tr><td><code>waitForClassRemoval(className, timeout?)</code></td><td>Wait for class to be removed</td></tr>
                        <tr><td><code>waitForStable(timeout?)</code></td><td>Wait for element to stop moving</td></tr>
                        <tr><td><code>waitForClickable(timeout?)</code></td><td>Wait until element is clickable</td></tr>
                    </tbody>
                </table>

                <h4>Wait Examples</h4>
                <pre><code>// Spec Format
test('Wait operations', async ({ dashboardPage }) => {
    await dashboardPage.loadingSpinner.waitForHidden();
    await dashboardPage.dataTable.waitForVisible();
    await dashboardPage.statusLabel.waitForText('Complete');
    await dashboardPage.progressBar.waitForAttribute('aria-valuenow', '100');
    await dashboardPage.submitButton.waitForEnabled();
    await dashboardPage.animation.waitForStable();
});

// BDD Format
@Then('the loading spinner should disappear')
async waitForLoading() {
    await this.dashboardPage.loadingSpinner.waitForHidden(30000);
}

@Then('the status should change to {string}')
async waitForStatus(status: string) {
    await this.dashboardPage.statusLabel.waitForText(status, 10000);
}</code></pre>

                <h3>Drag & Drop Operations</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>dragTo(target, options?)</code></td><td>Drag element to target element</td></tr>
                        <tr><td><code>dragAndDrop(target)</code></td><td>Alias for dragTo</td></tr>
                        <tr><td><code>dragToOffset(x, y)</code></td><td>Drag element to coordinate offset</td></tr>
                    </tbody>
                </table>

                <h4>Drag & Drop Examples</h4>
                <pre><code>// Spec Format
test('Drag and drop', async ({ kanbanPage }) => {
    const sourceCard = kanbanPage.card('Task 1');
    const targetColumn = kanbanPage.column('Done');
    await sourceCard.dragTo(targetColumn);
    await kanbanPage.slider.dragToOffset(100, 0);
});

// BDD Format
@When('I drag {string} to {string} column')
async dragCard(cardName: string, columnName: string) {
    const card = this.kanbanPage.card(cardName);
    const column = this.kanbanPage.column(columnName);
    await card.dragTo(column);
}</code></pre>

                <h3>Frame & Shadow DOM</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>frameLocator()</code></td><td>Get locator for iframe content</td></tr>
                        <tr><td><code>contentFrame()</code></td><td>Get frame for iframe element</td></tr>
                        <tr><td><code>shadowRoot()</code></td><td>Get shadow root locator</td></tr>
                        <tr><td><code>owner()</code></td><td>Get owner frame of locator</td></tr>
                    </tbody>
                </table>

                <h4>Frame & Shadow DOM Examples</h4>
                <pre><code>// Spec Format - Using CSWebElement and CSBasePage methods
test('Frame handling', async ({ dashboardPage }) => {
    // Switch to iframe using CSBasePage method
    await dashboardPage.switchToFrame('#my-iframe');
    await dashboardPage.iframeSubmitButton.click();  // CSWebElement in iframe
    await dashboardPage.switchToMainFrame();  // Return to main page

    // Access shadow DOM via CSWebElement's subLocator
    await dashboardPage.shadowHostElement.subLocator('.shadow-content').click();
});

// Page Object with iframe elements
@CSPage('dashboard')
export class DashboardPage extends CSBasePage {

    @CSGetElement({ css: '#my-iframe', description: 'Content iframe' })
    public contentIframe!: CSWebElement;

    // Define elements that exist inside the iframe
    @CSGetElement({ css: 'button.submit', description: 'Submit button in iframe' })
    public iframeSubmitButton!: CSWebElement;

    @CSGetElement({ css: '#shadow-host', description: 'Shadow DOM host' })
    public shadowHostElement!: CSWebElement;

    public async submitInIframe(): Promise&lt;void&gt; {
        await this.switchToFrame('#my-iframe');
        await this.iframeSubmitButton.click();
        await this.switchToMainFrame();
    }
}

// BDD Format
@When('I click button inside iframe')
async clickInIframe() {
    await this.dashboardPage.switchToFrame('#my-iframe');
    await this.dashboardPage.iframeSubmitButton.click();
    await this.dashboardPage.switchToMainFrame();
}</code></pre>

                <h3>Traversal & Filtering</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>first()</code></td><td>Get first matching element</td></tr>
                        <tr><td><code>last()</code></td><td>Get last matching element</td></tr>
                        <tr><td><code>nth(index)</code></td><td>Get element at index</td></tr>
                        <tr><td><code>filter(options)</code></td><td>Filter by text, hasText, has, hasNot</td></tr>
                        <tr><td><code>locator(selector)</code></td><td>Get child locator</td></tr>
                        <tr><td><code>getByRole(role, options?)</code></td><td>Find by ARIA role</td></tr>
                        <tr><td><code>getByText(text, options?)</code></td><td>Find by text content</td></tr>
                        <tr><td><code>getByLabel(text, options?)</code></td><td>Find by associated label</td></tr>
                        <tr><td><code>getByPlaceholder(text, options?)</code></td><td>Find by placeholder</td></tr>
                        <tr><td><code>getByTestId(testId)</code></td><td>Find by data-testid</td></tr>
                        <tr><td><code>getByAltText(text, options?)</code></td><td>Find by alt text</td></tr>
                        <tr><td><code>getByTitle(text, options?)</code></td><td>Find by title attribute</td></tr>
                        <tr><td><code>and(locator)</code></td><td>Match both this and other locator</td></tr>
                        <tr><td><code>or(locator)</code></td><td>Match this or other locator</td></tr>
                    </tbody>
                </table>

                <h4>Traversal Examples</h4>
                <pre><code>// Spec Format - Using CSWebElement methods
test('Element traversal', async ({ listPage }) => {
    // Get specific item from list using CSWebElement traversal
    await listPage.listItems.first().click();           // First item
    await listPage.listItems.nth(2).click();            // Third item
    await listPage.listItems.last().click();            // Last item

    // Filter elements using CSWebElement filter
    const activeItems = listPage.listItems.filter({ hasText: 'Active' });
    await activeItems.first().click();

    // Chained locator methods
    await listPage.container.getByText('Submit').click();
    await listPage.container.getByRole('button', { name: 'Save' }).click();

    // Get count of matching elements
    const count = await listPage.listItems.count();
    console.log(`Found ${count} items`);
});

// Page Object with element collections
@CSPage('list')
export class ListPage extends CSBasePage {

    @CSGetElement({ css: '.list-item', description: 'List items' })
    public listItems!: CSWebElement;

    @CSGetElement({ css: '.container', description: 'Main container' })
    public container!: CSWebElement;

    @CSGetElement({ css: 'button[type="submit"]', description: 'Submit button' })
    public submitButton!: CSWebElement;

    public async clickItemByIndex(index: number): Promise&lt;void&gt; {
        await this.listItems.nth(index).click();
    }

    public async clickFirstActiveItem(): Promise&lt;void&gt; {
        const activeItems = this.listItems.filter({ hasText: 'Active' });
        await activeItems.first().click();
    }

    public async getItemCount(): Promise&lt;number&gt; {
        return await this.listItems.count();
    }

    public async getAllItemTexts(): Promise&lt;string[]&gt; {
        return await this.listItems.allInnerTexts();
    }
}

// BDD Format
@When('I click the first item in the list')
async clickFirst() {
    await this.listPage.listItems.first().click();
}

@When('I click item number {int}')
async clickItemByNumber(num: number) {
    await this.listPage.listItems.nth(num - 1).click();  // Zero-indexed
}</code></pre>

                <h3>Screenshot & Evaluation</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>screenshot(options?)</code></td><td>Take screenshot of element</td></tr>
                        <tr><td><code>evaluate(fn, arg?)</code></td><td>Execute JS in element context</td></tr>
                        <tr><td><code>evaluateAll(fn, arg?)</code></td><td>Execute JS on all matching elements</td></tr>
                        <tr><td><code>evaluateHandle(fn, arg?)</code></td><td>Get JS handle from evaluation</td></tr>
                        <tr><td><code>highlight()</code></td><td>Visually highlight element</td></tr>
                        <tr><td><code>scrollIntoViewIfNeeded()</code></td><td>Scroll element into viewport</td></tr>
                    </tbody>
                </table>

                <h4>Screenshot & Evaluation Examples</h4>
                <pre><code>// Spec Format - Using CSWebElement methods
test('Element screenshot and evaluation', async ({ dashboardPage }) => {
    // Take element screenshot using CSWebElement
    await dashboardPage.chartWidget.screenshotToFile('chart.png');
    await dashboardPage.chartWidget.screenshotAsPng();  // Returns Buffer

    // Execute JavaScript on element
    const scrollTop = await dashboardPage.scrollableArea.evaluate(el => el.scrollTop);

    // Get all text from list items
    const texts = await dashboardPage.listItems.evaluateAll(
        els => els.map(el => el.textContent)
    );

    // Highlight for debugging
    await dashboardPage.targetElement.highlight();

    // Scroll into view
    await dashboardPage.footer.scrollIntoViewIfNeeded();
});

// Page Object with evaluation methods
@CSPage('dashboard')
export class DashboardPage extends CSBasePage {

    @CSGetElement({ css: '.chart', description: 'Chart widget' })
    public chartWidget!: CSWebElement;

    @CSGetElement({ css: '.scrollable', description: 'Scrollable area' })
    public scrollableArea!: CSWebElement;

    @CSGetElement({ css: '.item', description: 'List items' })
    public listItems!: CSWebElement;

    @CSGetElement({ css: '.footer', description: 'Page footer' })
    public footer!: CSWebElement;

    public async captureChartEvidence(): Promise&lt;void&gt; {
        await this.chartWidget.scrollIntoViewIfNeeded();
        await this.chartWidget.screenshotToFile('evidence/chart.png');
    }

    public async getScrollPosition(): Promise&lt;number&gt; {
        return await this.scrollableArea.evaluate(el => el.scrollTop);
    }
}

// BDD Format
@Then('I take a screenshot of the chart')
async screenshotChart() {
    await this.dashboardPage.chartWidget.screenshotToFile('chart.png');
}

@Then('I scroll to the footer')
async scrollToFooter() {
    await this.dashboardPage.footer.scrollIntoViewIfNeeded();
}</code></pre>

                <h3>All Elements Operations</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>all()</code></td><td>Get array of all matching locators</td></tr>
                        <tr><td><code>allInnerTexts()</code></td><td>Get array of inner texts</td></tr>
                        <tr><td><code>allTextContents()</code></td><td>Get array of text contents</td></tr>
                    </tbody>
                </table>

                <h4>All Elements Examples</h4>
                <pre><code>// Spec Format - Using CSWebElement collection methods
test('Working with multiple elements', async ({ listPage }) => {
    // Get all matching locators using CSWebElement
    const items = await listPage.listItems.all();
    for (const item of items) {
        console.log(await item.textContent());
    }

    // Get all text values at once
    const allTexts = await listPage.listItems.allInnerTexts();
    console.log('Items:', allTexts);

    // Get all text contents (includes hidden text)
    const allContents = await listPage.listItems.allTextContents();

    // Count elements
    const count = await listPage.listItems.count();
    console.log(`Found ${count} items`);
});

// Page Object with collection methods
@CSPage('list')
export class ListPage extends CSBasePage {

    @CSGetElement({ css: '.list-item', description: 'List items' })
    public listItems!: CSWebElement;

    public async verifyItemCount(expected: number): Promise&lt;void&gt; {
        const count = await this.listItems.count();
        if (count !== expected) {
            throw new Error(`Expected ${expected} items but found ${count}`);
        }
    }

    public async getAllItemTexts(): Promise&lt;string[]&gt; {
        return await this.listItems.allInnerTexts();
    }

    public async clickAllItems(): Promise&lt;void&gt; {
        const items = await this.listItems.all();
        for (const item of items) {
            await item.click();
        }
    }
}

// BDD Format
@Then('I should see {int} items in the list')
async verifyItemCount(expected: number) {
    const count = await this.listPage.listItems.count();
    if (count !== expected) {
        throw new Error(`Expected ${expected} items but found ${count}`);
    }
}

@Then('the list should contain {string}')
async verifyListContains(text: string) {
    const allTexts = await this.listPage.listItems.allInnerTexts();
    if (!allTexts.some(t => t.includes(text))) {
        throw new Error(`Text "${text}" not found in list`);
    }
}</code></pre>

                <h3>CSElementFactory - Dynamic Element Creation</h3>
                <p>CSElementFactory provides static methods for creating elements dynamically at runtime without decorators. Use this when you need to create elements based on runtime data or in situations where decorators aren't practical.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>createByCSS(selector, description?)</code></td><td>Create element with CSS selector</td></tr>
                        <tr><td><code>createByXPath(xpath, description?)</code></td><td>Create element with XPath selector</td></tr>
                        <tr><td><code>createByText(text, exact?, description?)</code></td><td>Create element by text content</td></tr>
                        <tr><td><code>createById(id, description?)</code></td><td>Create element by ID attribute</td></tr>
                        <tr><td><code>createByName(name, description?)</code></td><td>Create element by name attribute</td></tr>
                        <tr><td><code>createByRole(role, description?)</code></td><td>Create element by ARIA role</td></tr>
                        <tr><td><code>createByTestId(testId, description?)</code></td><td>Create element by data-testid</td></tr>
                        <tr><td><code>create(options)</code></td><td>Create element with full ElementOptions</td></tr>
                        <tr><td><code>createWithTemplate(template, values, description?)</code></td><td>Create element with interpolated selector</td></tr>
                        <tr><td><code>createMultiple(selector, description?)</code></td><td>Create array of elements matching selector</td></tr>
                    </tbody>
                </table>

                <h4>Instance Methods (for collections)</h4>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>getAll()</code></td><td>Get all matching elements as CSWebElement array</td></tr>
                        <tr><td><code>count()</code></td><td>Get count of matching elements</td></tr>
                        <tr><td><code>clickAll()</code></td><td>Click all matching elements</td></tr>
                        <tr><td><code>fillAll(value)</code></td><td>Fill all matching elements with value</td></tr>
                        <tr><td><code>getTexts()</code></td><td>Get text content of all elements</td></tr>
                        <tr><td><code>getValues()</code></td><td>Get input values of all elements</td></tr>
                        <tr><td><code>checkAll()</code></td><td>Check all matching checkboxes</td></tr>
                        <tr><td><code>uncheckAll()</code></td><td>Uncheck all matching checkboxes</td></tr>
                    </tbody>
                </table>

                <h4>CSElementFactory Examples</h4>
                <pre><code>import { CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';

// Spec Format - Using CSElementFactory for dynamic elements
describe('Dynamic Element Tests', () => {

    test('Create elements dynamically', async ({ reporter }) => {
        // Create by CSS
        const submitBtn = CSElementFactory.createByCSS('button[type="submit"]', 'Submit button');
        await submitBtn.click();

        // Create by XPath
        const headerXpath = CSElementFactory.createByXPath('//h1[contains(@class, "title")]', 'Page title');
        const titleText = await headerXpath.textContent();
        reporter.info(`Page title: ${titleText}`);

        // Create by ID
        const usernameField = CSElementFactory.createById('username', 'Username input');
        await usernameField.fill('admin');

        // Create by text content
        const loginLink = CSElementFactory.createByText('Sign In', true, 'Sign in link');
        await loginLink.click();

        // Create by role
        const saveButton = CSElementFactory.createByRole('button', 'Save button');
        await saveButton.waitForEnabled();
        await saveButton.click();

        // Create by test ID
        const searchBox = CSElementFactory.createByTestId('search-input', 'Search box');
        await searchBox.fill('search term');
    });

    test('Create elements with template interpolation', async ({ reporter }) => {
        // CSS template - create product card element dynamically
        const productId = '12345';
        const productCard = CSElementFactory.createWithTemplate(
            'div.product-card[data-id="{id}"]',
            { id: productId },
            `Product card for ${productId}`
        );
        await productCard.click();

        // XPath template - automatically detected as XPath
        const rowElement = CSElementFactory.createWithTemplate(
            '//tr[@data-row-id="{rowId}"]/td[{column}]',
            { rowId: 'R001', column: '3' },
            'Table cell'
        );
        const cellValue = await rowElement.textContent();
        reporter.info(`Cell value: ${cellValue}`);

        // Template with multiple parameters
        const filterButton = CSElementFactory.createWithTemplate(
            'button.filter[data-category="{category}"][data-status="{status}"]',
            { category: 'electronics', status: 'active' },
            'Category filter button'
        );
        await filterButton.click();
    });

    test('Work with element collections', async ({ reporter }) => {
        // Create factory for multiple elements
        const itemsFactory = new CSElementFactory({
            css: '.list-item',
            description: 'List items'
        });

        // Get count
        const count = await itemsFactory.count();
        reporter.info(`Found ${count} items`);

        // Get all elements
        const items = await itemsFactory.getAll();
        for (const item of items) {
            reporter.info(`Item: ${await item.textContent()}`);
        }

        // Get all text values at once
        const allTexts = await itemsFactory.getTexts();
        reporter.info(`All items: ${allTexts.join(', ')}`);

        // Perform action on all elements
        const checkboxFactory = new CSElementFactory({
            css: 'input[type="checkbox"].select-item',
            description: 'Item checkboxes'
        });
        await checkboxFactory.checkAll();  // Check all checkboxes
    });

    test('Create multiple elements from selector', async ({ reporter }) => {
        // Static method to create array of elements
        const menuItems = await CSElementFactory.createMultiple(
            'nav.sidebar a.menu-item',
            'Sidebar menu items'
        );

        reporter.info(`Found ${menuItems.length} menu items`);

        for (const item of menuItems) {
            const text = await item.textContent();
            const href = await item.getAttribute('href');
            reporter.info(`Menu: ${text} -> ${href}`);
        }
    });
});

// Page Object using CSElementFactory for dynamic elements
@CSPage('products')
export class ProductsPage extends CSBasePage {

    // Static elements using decorator
    @CSGetElement({ css: '.product-grid', description: 'Product grid' })
    public productGrid!: CSWebElement;

    // Dynamic element creation for data-driven scenarios
    public getProductCard(productId: string): CSWebElement {
        return CSElementFactory.createWithTemplate(
            'div.product-card[data-product-id="{id}"]',
            { id: productId },
            `Product card: ${productId}`
        );
    }

    public getProductByName(name: string): CSWebElement {
        return CSElementFactory.createByText(name, false, `Product: ${name}`);
    }

    public async getAllProductCards(): Promise&lt;CSWebElement[]&gt; {
        return await CSElementFactory.createMultiple(
            '.product-card',
            'All product cards'
        );
    }

    public async selectProduct(productId: string): Promise&lt;void&gt; {
        const card = this.getProductCard(productId);
        await card.scrollIntoViewIfNeeded();
        await card.click();
    }
}

// BDD Format
@When('I click the product with ID {string}')
async clickProduct(productId: string) {
    const product = CSElementFactory.createWithTemplate(
        'div.product[data-id="{id}"]',
        { id: productId },
        `Product ${productId}`
    );
    await product.click();
}

@Then('I should see {int} items in the list')
async verifyItemCount(expected: number) {
    const factory = new CSElementFactory({
        css: '.list-item',
        description: 'List items'
    });
    const count = await factory.count();
    expect(count).toBe(expected);
}</code></pre>

                <h3>CSElementResolver - Smart Element Resolution</h3>
                <p>CSElementResolver provides intelligent element finding using natural language descriptions, pattern matching, and AI-assisted resolution with self-healing capabilities.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td></tr>
                        <tr><td><code>resolveByDescription(description, options?)</code></td><td>Find element by natural language description</td></tr>
                        <tr><td><code>registerPattern(category, patterns)</code></td><td>Register custom resolution patterns</td></tr>
                        <tr><td><code>createDynamicElement(template, params)</code></td><td>Create element with template interpolation</td></tr>
                        <tr><td><code>createByRole(role, options?)</code></td><td>Create element by ARIA role</td></tr>
                        <tr><td><code>createByTestId(testId)</code></td><td>Create element by test ID</td></tr>
                        <tr><td><code>createWithinContainer(container, element)</code></td><td>Create element within a container</td></tr>
                        <tr><td><code>createNthElement(selector, index)</code></td><td>Create nth matching element</td></tr>
                        <tr><td><code>createByText(text, options?)</code></td><td>Create element by text content</td></tr>
                        <tr><td><code>createByAttribute(attribute, value, options?)</code></td><td>Create element by attribute</td></tr>
                        <tr><td><code>createByLabel(labelText)</code></td><td>Create form element by label</td></tr>
                        <tr><td><code>clearCache()</code></td><td>Clear element cache</td></tr>
                        <tr><td><code>exportHealingHistory()</code></td><td>Export healing history for persistence</td></tr>
                        <tr><td><code>importHealingHistory(history)</code></td><td>Import healing history</td></tr>
                    </tbody>
                </table>

                <h4>CSElementResolver Examples</h4>
                <pre><code>import { CSElementResolver } from '@mdakhan.mak/cs-playwright-test-framework/element';

// Spec Format - Using CSElementResolver
describe('Smart Element Resolution', () => {

    test('Resolve elements by natural language', async ({ reporter }) => {
        const resolver = CSElementResolver.getInstance();

        // Find by description - uses pattern matching and AI
        const loginBtn = await resolver.resolveByDescription('login button');
        await loginBtn.click();

        const usernameField = await resolver.resolveByDescription('username field');
        await usernameField.fill('admin');

        const submitLink = await resolver.resolveByDescription('submit link');
        await submitLink.click();

        reporter.pass('Elements resolved by natural language');
    });

    test('Use built-in resolution patterns', async ({ reporter }) => {
        const resolver = CSElementResolver.getInstance();

        // Pattern: "{text} button" -> finds button with text
        const saveBtn = await resolver.resolveByDescription('Save button');
        await saveBtn.click();

        // Pattern: "{text} field" -> finds input with placeholder
        const emailInput = await resolver.resolveByDescription('Email field');
        await emailInput.fill('test@example.com');

        // Pattern: "{text} link" -> finds link with text
        const homeLink = await resolver.resolveByDescription('Home link');
        await homeLink.click();

        // Pattern: "{text} dropdown" -> finds select
        const countrySelect = await resolver.resolveByDescription('Country dropdown');
        await countrySelect.selectOption('USA');
    });

    test('Register custom patterns', async ({ reporter }) => {
        const resolver = CSElementResolver.getInstance();

        // Register custom patterns for your app
        resolver.registerPattern('card', [
            { pattern: /^(.*)\s+card$/i, selector: '.card:has-text("{0}")', priority: 1 },
            { pattern: /^view\s+(.*)$/i, selector: '.card[data-type="{0}"]', priority: 2 }
        ]);

        resolver.registerPattern('modal', [
            { pattern: /^(.*)\s+modal$/i, selector: '.modal[data-name="{0}"]', priority: 1 },
            { pattern: /^close\s+(.*)$/i, selector: '.modal .close-btn', priority: 2 }
        ]);

        // Now you can use these patterns
        const productCard = await resolver.resolveByDescription('Product card');
        const settingsModal = await resolver.resolveByDescription('Settings modal');
    });

    test('Create elements within containers', async ({ reporter }) => {
        const resolver = CSElementResolver.getInstance();

        // Find element within a specific container
        const submitInForm = resolver.createWithinContainer(
            'form#login-form',
            'button[type="submit"]'
        );
        await submitInForm.click();

        // Create nth element
        const thirdItem = resolver.createNthElement('.list-item', 2);
        await thirdItem.click();

        // Create by label (finds associated form element)
        const passwordInput = resolver.createByLabel('Password');
        await passwordInput.fill('secret123');
    });

    test('Use caching and healing', async ({ reporter }) => {
        const resolver = CSElementResolver.getInstance();

        // Resolution with caching (faster on repeated calls)
        const element1 = await resolver.resolveByDescription('submit button', {
            cacheElements: true
        });

        // Same description returns cached element
        const element2 = await resolver.resolveByDescription('submit button');

        // Enable self-healing for resilient tests
        const healableElement = await resolver.resolveByDescription('login button', {
            selfHeal: true,
            aiEnabled: true
        });

        // Export healing history for persistence across runs
        const history = resolver.exportHealingHistory();
        reporter.info(`Healing history entries: ${Object.keys(history).length}`);

        // Clear cache when needed
        resolver.clearCache();
    });
});

// BDD Format
@When('I click the {string}')
async clickByDescription(description: string) {
    const resolver = CSElementResolver.getInstance();
    const element = await resolver.resolveByDescription(description);
    await element.click();
}

@When('I enter {string} in the {string}')
async enterInField(value: string, fieldDescription: string) {
    const resolver = CSElementResolver.getInstance();
    const field = await resolver.resolveByDescription(fieldDescription);
    await field.fill(value);
}</code></pre>
            </section>

            <!-- WAIT STRATEGIES -->
            <section id="wait-strategies">
                <h2>Wait Strategies - CSSmartWait</h2>

                <p>The framework includes an intelligent wait system that monitors multiple signals for page stability, reducing flaky tests caused by timing issues.</p>

                <h3>Smart Wait Levels</h3>
                <table>
                    <thead>
                        <tr><th>Level</th><th>Description</th><th>Use Case</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>off</code></td><td>No smart waiting</td><td>Maximum speed, stable apps</td></tr>
                        <tr><td><code>minimal</code></td><td>Network idle only</td><td>Default - balanced approach</td></tr>
                        <tr><td><code>standard</code></td><td>Network + DOM stability</td><td>Dynamic apps with AJAX</td></tr>
                        <tr><td><code>strict</code></td><td>Full detection (spinners, animations)</td><td>Complex SPAs</td></tr>
                    </tbody>
                </table>

                <h3>CSSmartWait Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance(page)</code></td><td>Get instance for page</td><td>CSSmartWait</td></tr>
                        <tr><td><code>setLevel(level)</code></td><td>Set wait level</td><td>void</td></tr>
                        <tr><td><code>waitForPageReady()</code></td><td>Wait for page to be ready</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>waitForNetworkIdle(timeout?)</code></td><td>Wait for network to be idle</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>waitForDomStable(timeout?)</code></td><td>Wait for DOM to stop changing</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>waitForNoSpinners(timeout?)</code></td><td>Wait for loading spinners to disappear</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>waitForNoAnimations(timeout?)</code></td><td>Wait for animations to complete</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>waitForElement(selector, options?)</code></td><td>Wait for element with smart conditions</td><td>Promise&lt;Locator&gt;</td></tr>
                        <tr><td><code>waitForElementVisible(selector)</code></td><td>Wait for element visibility</td><td>Promise&lt;Locator&gt;</td></tr>
                        <tr><td><code>waitForElementClickable(selector)</code></td><td>Wait for element to be clickable</td><td>Promise&lt;Locator&gt;</td></tr>
                        <tr><td><code>waitForText(text, options?)</code></td><td>Wait for text to appear</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>waitForUrl(url, options?)</code></td><td>Wait for URL match</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>waitForCondition(fn, options?)</code></td><td>Wait for custom condition</td><td>Promise&lt;T&gt;</td></tr>
                        <tr><td><code>disable()</code></td><td>Temporarily disable smart wait</td><td>void</td></tr>
                        <tr><td><code>enable()</code></td><td>Re-enable smart wait</td><td>void</td></tr>
                    </tbody>
                </table>

                <h3>Wait Component Classes</h3>
                <ul>
                    <li><strong>CSDomStabilityMonitor</strong> - Monitors DOM mutations for stability</li>
                    <li><strong>CSNetworkIdleTracker</strong> - Tracks pending network requests</li>
                    <li><strong>CSSpinnerDetector</strong> - Detects loading indicators</li>
                    <li><strong>CSAnimationDetector</strong> - Waits for CSS animations to complete</li>
                    <li><strong>CSSmartPoller</strong> - Unified polling utility with configurable strategies</li>
                </ul>

                <h3 id="smart-poller">CSSmartPoller - Advanced Polling Utility</h3>
                <p>CSSmartPoller provides flexible polling with backoff strategies. It's used internally by CSBasePage's generic wait methods and can be used directly for custom polling scenarios.</p>

                <h4>Import</h4>
                <pre><code>import { CSSmartPoller } from '@mdakhan.mak/cs-playwright-test-framework/wait';
import type { SmartPollOptions, PollResult, BackoffStrategy } from '@mdakhan.mak/cs-playwright-test-framework/wait';</code></pre>

                <h4>CSSmartPoller Methods</h4>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>poll(options)</code></td><td>Poll with custom condition</td><td>Promise&lt;PollResult&gt;</td></tr>
                        <tr><td><code>pollForVisible(page, selector, timeout?)</code></td><td>Poll until element visible</td><td>Promise&lt;PollResult&gt;</td></tr>
                        <tr><td><code>pollForHidden(page, selector, timeout?)</code></td><td>Poll until element hidden</td><td>Promise&lt;PollResult&gt;</td></tr>
                        <tr><td><code>pollForText(page, selector, text, timeout?)</code></td><td>Poll until element has text</td><td>Promise&lt;PollResult&gt;</td></tr>
                        <tr><td><code>pollForAttribute(page, selector, attr, value, timeout?)</code></td><td>Poll until attribute matches</td><td>Promise&lt;PollResult&gt;</td></tr>
                        <tr><td><code>pollForCount(page, selector, count, timeout?)</code></td><td>Poll until element count matches</td><td>Promise&lt;PollResult&gt;</td></tr>
                        <tr><td><code>pollWithStaleRetry(condition, validate, timeout?, interval?)</code></td><td>Poll with auto stale element retry</td><td>Promise&lt;{success, result}&gt;</td></tr>
                    </tbody>
                </table>

                <h4>Backoff Strategies</h4>
                <table>
                    <thead><tr><th>Strategy</th><th>Description</th><th>Best For</th></tr></thead>
                    <tbody>
                        <tr><td><code>none</code></td><td>Fixed interval (default)</td><td>Fast-changing UI, short waits</td></tr>
                        <tr><td><code>linear</code></td><td>Interval increases linearly</td><td>Medium-length waits</td></tr>
                        <tr><td><code>exponential</code></td><td>Interval doubles each attempt</td><td>API polling, slow operations</td></tr>
                        <tr><td><code>fibonacci</code></td><td>Interval follows fibonacci sequence</td><td>Gradual backoff, long waits</td></tr>
                    </tbody>
                </table>

                <h4>SmartPollOptions Interface</h4>
                <pre><code>interface SmartPollOptions {
    condition: () => Promise&lt;boolean&gt;;  // Condition to check
    timeout: number;                     // Maximum time to wait (ms)
    interval: number;                    // Base interval between checks (ms)
    backoff: BackoffStrategy;            // 'none' | 'linear' | 'exponential' | 'fibonacci'
    maxInterval: number;                 // Maximum interval when using backoff
    message: string;                     // Description for logging
    throwOnTimeout: boolean;             // Throw error on timeout (default: false)
    onProgress?: (attempt: number, elapsed: number) => void;  // Progress callback
}</code></pre>

                <h4>CSSmartPoller Examples</h4>
                <pre><code>import { CSSmartPoller } from '@mdakhan.mak/cs-playwright-test-framework/wait';

// Basic polling with custom condition
const poller = new CSSmartPoller(page);

const result = await poller.poll({
    condition: async () => {
        const count = await page.locator('.data-row').count();
        return count >= 5;  // Wait for at least 5 rows
    },
    timeout: 30000,
    interval: 500,
    backoff: 'none',
    message: 'Wait for data rows to load',
    throwOnTimeout: false
});

if (result.success) {
    console.log(`Condition met after ${result.attempts} attempts in ${result.elapsed}ms`);
} else {
    console.log(`Timed out after ${result.attempts} attempts`);
}

// Exponential backoff for API polling
const apiResult = await poller.poll({
    condition: async () => {
        const response = await fetch('/api/status');
        const data = await response.json();
        return data.status === 'complete';
    },
    timeout: 60000,
    interval: 1000,
    backoff: 'exponential',
    maxInterval: 10000,  // Cap at 10 seconds
    message: 'Wait for job completion'
});

// Quick helper methods
await poller.pollForVisible(page, '.success-message', 10000);
await poller.pollForHidden(page, '.loading-spinner', 15000);
await poller.pollForText(page, '.status', 'Complete', 20000);
await poller.pollForCount(page, '.list-item', 10, 30000);

// Poll with progress callback
await poller.poll({
    condition: async () => await checkCondition(),
    timeout: 30000,
    interval: 1000,
    backoff: 'linear',
    message: 'Processing...',
    onProgress: (attempt, elapsed) => {
        console.log(`Attempt ${attempt}, elapsed: ${elapsed}ms`);
    }
});</code></pre>

                <h3>Configuration</h3>
                <pre><code># Environment variables
SMART_WAIT_LEVEL=minimal          # off, minimal, standard, strict
SMART_WAIT_TIMEOUT=30000          # Default timeout in ms
SMART_WAIT_POLL_INTERVAL=100      # Polling interval in ms
SMART_WAIT_ENABLED=true           # Enable/disable globally</code></pre>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';

describe('Smart Wait Tests', () => {

    test('Wait for page to be fully loaded', async ({ dashboardPage, smartWait }) => {
        await dashboardPage.navigate();

        // Wait for page to be ready (network idle + DOM stable)
        await smartWait.waitForPageReady();

        // Now interact with elements safely using CSWebElement
        await dashboardPage.dynamicContent.click();
    });

    test('Wait for specific element conditions', async ({ dashboardPage, smartWait }) => {
        await dashboardPage.navigate();

        // Wait for CSWebElement to be visible
        await dashboardPage.pageTitle.waitForVisible();

        // Wait for button to be clickable (visible + enabled)
        await dashboardPage.submitButton.waitForEnabled();
        await dashboardPage.submitButton.click();

        // Wait for modal with custom timeout
        await dashboardPage.modalDialog.waitForVisible(10000);
    });

    test('Wait for dynamic content', async ({ feedPage, smartWait }) => {
        await feedPage.navigate();

        // Wait for loading spinners to disappear
        await smartWait.waitForNoSpinners();

        // Wait for specific text to appear
        await smartWait.waitForText('Posts loaded');

        // Wait for animations to complete
        await smartWait.waitForNoAnimations();
    });

    test('Custom wait conditions', async ({ dashboardPage, smartWait }) => {
        await dashboardPage.navigate();

        // Wait for custom condition with polling
        const chartData = await smartWait.waitForCondition(async () => {
            return await dashboardPage.chartWidget.evaluate(() => {
                return (window as any).chartData;
            });
        }, {
            timeout: 15000,
            interval: 500,
            message: 'Wait for chart data to load'
        });

        console.log(`Chart has ${chartData.length} data points`);
    });

    test('Different wait levels for different scenarios', async ({ staticPage, dashboardPage, smartWait, reporter }) => {
        // For quick static pages
        smartWait.setLevel('minimal');
        await staticPage.navigate();
        await smartWait.waitForPageReady();
        reporter.info('Static page loaded with minimal wait');

        // For complex SPA
        smartWait.setLevel('strict');
        await dashboardPage.navigate();
        await smartWait.waitForPageReady();  // Waits for everything
        reporter.info('Dashboard loaded with strict wait');
    });

    test('Wait for URL navigation', async ({ homePage, smartWait }) => {
        await homePage.navigate();
        await homePage.loginLink.click();

        // Wait for URL to change using CSBasePage method
        await homePage.waitForUrlContains('/login');

        // Or use smartWait for pattern matching
        await smartWait.waitForUrl('**/login', { timeout: 5000 });
    });

    test('Disable smart wait for speed-critical sections', async ({ searchPage, smartWait }) => {
        await searchPage.navigate();

        // Disable for known stable section
        smartWait.disable();

        await searchPage.quickSearchField.fill('test');
        await searchPage.pressEnterKey();  // CSBasePage method

        // Re-enable for dynamic results
        smartWait.enable();
        await smartWait.waitForPageReady();
    });
});</code></pre>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: wait-strategies.feature
@wait @smart-wait
Feature: Smart Wait Strategies

  Scenario: Wait for dynamic content to load
    Given I navigate to the dashboard
    When I wait for the page to be fully loaded
    Then all widgets should be visible

  Scenario: Handle loading states
    Given I navigate to the data report page
    When I wait for the loading spinner to disappear
    And I wait for the report data to appear
    Then I should see the complete report

// Step definitions: wait.steps.ts
import { Given, When, Then, StepClass } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSSmartWait } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { DashboardPage } from '../pages/DashboardPage';
import { ReportPage } from '../pages/ReportPage';

@StepClass()
export class WaitSteps {
    private smartWait!: CSSmartWait;
    private dashboardPage!: DashboardPage;
    private reportPage!: ReportPage;

    @Given('I navigate to the dashboard')
    async navigateToDashboard() {
        this.smartWait = CSSmartWait.getInstance(this.page);
        this.dashboardPage = new DashboardPage(this.page);
        await this.dashboardPage.navigate();  // Uses page object navigation
    }

    @Given('I navigate to the data report page')
    async navigateToReport() {
        this.smartWait = CSSmartWait.getInstance(this.page);
        this.reportPage = new ReportPage(this.page);
        await this.reportPage.navigate();  // Uses page object navigation
    }

    @When('I wait for the page to be fully loaded')
    async waitForPageReady() {
        this.smartWait.setLevel('strict');
        await this.smartWait.waitForPageReady();
        CSReporter.info('Page fully loaded');
    }

    @When('I wait for the loading spinner to disappear')
    async waitForNoSpinner() {
        await this.smartWait.waitForNoSpinners();
        CSReporter.info('Loading spinner disappeared');
    }

    @When('I wait for the report data to appear')
    async waitForReportData() {
        // Use CSWebElement's waitForVisible method
        await this.reportPage.reportTableRows.waitForVisible(30000);
        CSReporter.info('Report data appeared');
    }

    @Then('all widgets should be visible')
    async verifyWidgetsVisible() {
        // Use CSWebElement for element interactions
        const count = await this.dashboardPage.widgets.count();
        expect(count).toBeGreaterThan(0);

        const allItems = await this.dashboardPage.widgets.all();
        for (const widget of allItems) {
            const isVisible = await widget.isVisible();
            expect(isVisible).toBe(true);
        }

        CSReporter.pass(`All ${count} widgets are visible`);
    }

    @Then('I should see the complete report')
    async verifyCompleteReport() {
        // Use CSWebElement for element count
        const count = await this.reportPage.reportTableRows.count();
        expect(count).toBeGreaterThan(0);
        CSReporter.pass(`Report loaded with ${count} rows`);
    }
}</code></pre>

                <div class="info-box tip">
                    <strong>Wait Strategy Tips</strong>
                    <ul>
                        <li>Use <code>minimal</code> level for most tests - it provides good stability without over-waiting</li>
                        <li>Use <code>strict</code> for complex SPAs with heavy animations</li>
                        <li>Avoid <code>page.waitForTimeout()</code> - use condition-based waits instead</li>
                        <li>Set appropriate timeouts based on your application's load times</li>
                    </ul>
                </div>
            </section>

            <!-- BROWSER MANAGEMENT -->
            <section id="browser-management">
                <h2>Browser Management - CSBrowserManager</h2>

                <p>CSBrowserManager provides comprehensive browser lifecycle management with worker-thread awareness for parallel execution.</p>

                <h3>Supported Browsers</h3>
                <table>
                    <thead><tr><th>Browser</th><th>Config Value</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td>Chromium</td><td><code>chromium</code></td><td>Default Playwright Chromium</td></tr>
                        <tr><td>Chrome</td><td><code>chrome</code></td><td>Google Chrome (installed)</td></tr>
                        <tr><td>Edge</td><td><code>edge</code></td><td>Microsoft Edge (installed)</td></tr>
                        <tr><td>Firefox</td><td><code>firefox</code></td><td>Mozilla Firefox</td></tr>
                        <tr><td>WebKit</td><td><code>webkit</code></td><td>WebKit engine (Safari-like)</td></tr>
                        <tr><td>Safari</td><td><code>safari</code></td><td>Safari (macOS only)</td></tr>
                    </tbody>
                </table>

                <h3>CSBrowserManager Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance (worker-aware)</td></tr>
                        <tr><td><code>initialize(options?)</code></td><td>Initialize browser with options</td></tr>
                        <tr><td><code>getPage()</code></td><td>Get current active page</td></tr>
                        <tr><td><code>getContext()</code></td><td>Get current browser context</td></tr>
                        <tr><td><code>getBrowser()</code></td><td>Get browser instance</td></tr>
                        <tr><td><code>switchBrowser(browserType)</code></td><td>Switch to different browser</td></tr>
                        <tr><td><code>createNewContext(options?)</code></td><td>Create new browser context</td></tr>
                        <tr><td><code>createNewPage()</code></td><td>Create new page in current context</td></tr>
                        <tr><td><code>closeCurrentPage()</code></td><td>Close the current page</td></tr>
                        <tr><td><code>closeAllPages()</code></td><td>Close all pages except current</td></tr>
                        <tr><td><code>clearContextAndReauthenticate()</code></td><td>Clear cookies/storage for new session</td></tr>
                        <tr><td><code>setCookies(cookies)</code></td><td>Set browser cookies</td></tr>
                        <tr><td><code>getCookies()</code></td><td>Get all cookies</td></tr>
                        <tr><td><code>clearCookies()</code></td><td>Clear all cookies</td></tr>
                        <tr><td><code>setStorageState(path)</code></td><td>Load storage state from file</td></tr>
                        <tr><td><code>saveStorageState(path)</code></td><td>Save storage state to file</td></tr>
                        <tr><td><code>setGeolocation(latitude, longitude)</code></td><td>Set geolocation</td></tr>
                        <tr><td><code>grantPermissions(permissions)</code></td><td>Grant browser permissions</td></tr>
                        <tr><td><code>setOffline(offline)</code></td><td>Toggle offline mode</td></tr>
                        <tr><td><code>setUserAgent(userAgent)</code></td><td>Set custom user agent</td></tr>
                        <tr><td><code>setViewport(width, height)</code></td><td>Set viewport size</td></tr>
                        <tr><td><code>maximize()</code></td><td>Maximize browser window</td></tr>
                        <tr><td><code>cleanup()</code></td><td>Clean up all resources</td></tr>
                    </tbody>
                </table>

                <h3>Browser Initialization</h3>
                <pre><code>// Spec Format - auto-initialized via fixtures
test('Browser operations', async ({ browserManager, page }) => {
    // Get current browser info
    const browser = browserManager.getBrowser();
    console.log('Browser type:', browser.browserType().name());

    // Get current context
    const context = browserManager.getContext();
    console.log('Pages count:', context.pages().length);
});

// BDD Format - access via step definition
@Given('I initialize the browser with custom options')
async initBrowser() {
    const browserManager = CSBrowserManager.getInstance();
    await browserManager.initialize({
        headless: false,
        viewport: { width: 1920, height: 1080 },
        locale: 'en-US',
        timezoneId: 'America/New_York'
    });
}</code></pre>

                <h3>Browser Switching</h3>
                <pre><code>// Spec Format
test('Cross-browser testing', async ({ browserManager, loginPage }) => {
    // Test in Chromium (default)
    await loginPage.navigate();
    await loginPage.login('Admin', 'admin123');
    await loginPage.verifyLoginSuccess();

    // Switch to Firefox
    await browserManager.switchBrowser('firefox');
    await loginPage.navigate();
    await loginPage.login('Admin', 'admin123');
    await loginPage.verifyLoginSuccess();

    // Switch to WebKit
    await browserManager.switchBrowser('webkit');
    await loginPage.navigate();
    await loginPage.login('Admin', 'admin123');
    await loginPage.verifyLoginSuccess();
});

// BDD Format
@Given('I switch to {string} browser')
async switchBrowser(browserType: string) {
    const browserManager = CSBrowserManager.getInstance();
    await browserManager.switchBrowser(browserType);
}</code></pre>

                <h3>Context Management</h3>
                <pre><code>// Spec Format
test('Multi-user testing', async ({ browserManager, loginPage }) => {
    // User 1 session
    await loginPage.login('User1', 'pass1');
    await loginPage.verifyLoginSuccess();

    // Save User 1 session
    await browserManager.saveStorageState('user1-state.json');

    // Clear and start fresh for User 2
    await browserManager.clearContextAndReauthenticate();
    await loginPage.login('User2', 'pass2');
    await loginPage.verifyLoginSuccess();

    // Restore User 1 session
    await browserManager.setStorageState('user1-state.json');
    // Now logged in as User 1 again
});

// BDD Format
@Given('I start a new browser session')
async newSession() {
    const browserManager = CSBrowserManager.getInstance();
    await browserManager.clearContextAndReauthenticate();
}

@Given('I save the session as {string}')
async saveSession(name: string) {
    const browserManager = CSBrowserManager.getInstance();
    await browserManager.saveStorageState(`sessions/${name}.json`);
}</code></pre>

                <h3>Cookie Management</h3>
                <pre><code>// Spec Format
test('Cookie operations', async ({ browserManager }) => {
    // Set cookies
    await browserManager.setCookies([
        { name: 'session', value: 'abc123', domain: 'example.com' },
        { name: 'prefs', value: 'dark_mode', domain: 'example.com' }
    ]);

    // Get all cookies
    const cookies = await browserManager.getCookies();
    console.log('Cookies:', cookies);

    // Clear cookies
    await browserManager.clearCookies();
});

// BDD Format
@Given('I set the session cookie to {string}')
async setSessionCookie(value: string) {
    const browserManager = CSBrowserManager.getInstance();
    const baseUrl = new URL(this.config.get('BASE_URL'));
    await browserManager.setCookies([
        { name: 'session', value, domain: baseUrl.hostname }
    ]);
}</code></pre>

                <h3>Device Emulation & Permissions</h3>
                <pre><code>// Spec Format
test('Device emulation', async ({ browserManager }) => {
    // Set viewport
    await browserManager.setViewport(375, 812);  // iPhone X

    // Set user agent
    await browserManager.setUserAgent(
        'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
    );

    // Set geolocation
    await browserManager.setGeolocation(37.7749, -122.4194);  // San Francisco

    // Grant permissions
    await browserManager.grantPermissions(['geolocation', 'camera', 'microphone']);

    // Toggle offline mode
    await browserManager.setOffline(true);
    // Test offline behavior...
    await browserManager.setOffline(false);
});

// BDD Format
@Given('I am using a mobile device')
async useMobileDevice() {
    const browserManager = CSBrowserManager.getInstance();
    await browserManager.setViewport(375, 812);
    await browserManager.setUserAgent(
        'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)'
    );
}

@Given('I am in {string}')
async setLocation(city: string) {
    const browserManager = CSBrowserManager.getInstance();
    const locations = {
        'San Francisco': { lat: 37.7749, lng: -122.4194 },
        'New York': { lat: 40.7128, lng: -74.0060 },
        'London': { lat: 51.5074, lng: -0.1278 }
    };
    const loc = locations[city];
    await browserManager.setGeolocation(loc.lat, loc.lng);
}</code></pre>

                <h3>Multiple Pages & Tabs</h3>
                <pre><code>// Spec Format
test('Multiple tabs', async ({ browserManager, navigate }) => {
    // Create new page/tab
    const newPage = await browserManager.createNewPage();

    // Navigate in new page using browserManager
    await browserManager.switchToPage(newPage);
    await navigate('https://other-site.com');

    // Switch back to original page
    await browserManager.switchToOriginalPage();

    // Close specific page
    await browserManager.closePage(newPage);

    // Close all but current
    await browserManager.closeAllPages();
});

// BDD Format
@When('I open a new tab and navigate to {string}')
async openNewTab(url: string) {
    const browserManager = CSBrowserManager.getInstance();
    const newPage = await browserManager.createNewPage();
    await browserManager.switchToPage(newPage);
    await this.navigate(url);  // Use CSBasePage's navigate method
}</code></pre>
            </section>

            <!-- SPEC FORMAT -->
            <section id="spec-format">
                <h2>Spec Format Tests</h2>

                <p>The Spec format provides a Playwright-aligned testing API with automatic fixture injection, data-driven testing, execution modes, and comprehensive annotations. This is the recommended format for new test projects.</p>

                <h3>Quick Start</h3>
                <pre><code>import { describe, test, beforeEach, afterEach, beforeAll, afterAll } from '@mdakhan.mak/cs-playwright-test-framework/spec';

describe('Login Feature', {
    tags: ['@login', '@smoke', '@TestPlanId:417']
}, () => {

    beforeEach(async ({ navigate, config }) => {
        const baseUrl = config.get('BASE_URL');
        await navigate(baseUrl);
    });

    test('Valid login with correct credentials', {
        tags: ['@TC001', '@critical', '@TestCaseId:419']
    }, async ({ loginPage, reporter, config }) => {
        const password = config.get('APP_PASSWORD', 'admin123');

        await loginPage.enterUsername('Admin');
        await loginPage.enterPassword(password);
        await loginPage.clickLoginButton();

        await loginPage.verifyLoginSuccess();
        reporter.pass('Login verified successfully');
    });
});</code></pre>

                <h3>CLI Commands</h3>
                <table>
                    <thead><tr><th>Command</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>npx cs-playwright-test --project=myproject --specs=test/**/*.spec.ts</code></td><td>Run all spec files</td></tr>
                        <tr><td><code>npx cs-playwright-test --project=myproject --specs=test/login.spec.ts --test="Valid login"</code></td><td>Run specific test by name</td></tr>
                        <tr><td><code>npx cs-playwright-test --project=myproject --specs=test/**/*.spec.ts --grep="login|logout"</code></td><td>Run tests matching pattern</td></tr>
                        <tr><td><code>npx cs-playwright-test --project=myproject --specs=test/**/*.spec.ts --tags="@smoke"</code></td><td>Run tests with specific tags</td></tr>
                        <tr><td><code>npx cs-playwright-test --project=myproject --specs=test/**/*.spec.ts --parallel --workers=4</code></td><td>Run in parallel</td></tr>
                        <tr><td><code>npx cs-playwright-test generate-fixtures --project=myproject</code></td><td>Generate typed fixtures for IntelliSense</td></tr>
                    </tbody>
                </table>

                <h4>CLI Options</h4>
                <table>
                    <thead><tr><th>Option</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>--project &lt;name&gt;</code></td><td>Project name (required)</td></tr>
                        <tr><td><code>--specs &lt;path&gt;</code></td><td>Path to spec files (glob pattern)</td></tr>
                        <tr><td><code>--test &lt;name&gt;</code></td><td>Run specific test(s) by name (comma-separated)</td></tr>
                        <tr><td><code>--grep &lt;pattern&gt;</code></td><td>Run tests matching regex pattern</td></tr>
                        <tr><td><code>--tags &lt;tags&gt;</code></td><td>Filter by tags (@smoke, @TC001)</td></tr>
                        <tr><td><code>--parallel</code></td><td>Enable parallel execution</td></tr>
                        <tr><td><code>--workers &lt;n&gt;</code></td><td>Number of parallel workers (default: 4)</td></tr>
                        <tr><td><code>--headless</code></td><td>Run in headless mode</td></tr>
                        <tr><td><code>--headed</code></td><td>Run with visible browser</td></tr>
                        <tr><td><code>--browser &lt;type&gt;</code></td><td>Browser: chromium, firefox, webkit, edge</td></tr>
                        <tr><td><code>--retries &lt;n&gt;</code></td><td>Retry failed tests</td></tr>
                        <tr><td><code>--timeout &lt;ms&gt;</code></td><td>Test timeout in milliseconds</td></tr>
                        <tr><td><code>--debug</code></td><td>Enable debug mode</td></tr>
                        <tr><td><code>--lazy-steps</code></td><td>Enable lazy step loading (30-60x faster startup)</td></tr>
                    </tbody>
                </table>

                <h3>Typed Fixtures with fixture.d.ts</h3>

                <p>The framework auto-generates a <code>fixtures.d.ts</code> file that provides TypeScript IntelliSense for your page objects. Generate it once when setting up your project or when adding new page objects.</p>

                <pre><code># Generate typed fixtures for IntelliSense
npx cs-playwright-test generate-fixtures --project=myproject</code></pre>

                <p>This creates <code>test/myproject/fixtures.d.ts</code>:</p>
                <pre><code>/**
 * CS Playwright Test Framework - Typed Fixtures Declaration
 * Auto-generated by: npx cs-playwright-test generate-fixtures
 *
 * DO NOT EDIT MANUALLY - Regenerate when adding new pages:
 *   npx cs-playwright-test generate-fixtures --project=&lt;your-project&gt;
 */

// Import page classes for type references
import { DashboardPage } from './pages/DashboardPage';
import { LoginPage } from './pages/LoginPage';

// Augment SpecFixtures interface with page types
declare module '@mdakhan.mak/cs-playwright-test-framework/spec' {
    interface SpecFixtures {
        dashboardPage: DashboardPage;
        loginPage: LoginPage;
    }
}</code></pre>

                <p>With this file, you get full IntelliSense for <code>loginPage</code> and <code>dashboardPage</code> in your tests.</p>

                <h3>Auto-Injected Fixtures</h3>
                <table>
                    <thead><tr><th>Fixture</th><th>Type</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>page</code></td><td>Page</td><td>Playwright page instance</td></tr>
                        <tr><td><code>config</code></td><td>CSConfigurationManager</td><td>Configuration access via config.get()</td></tr>
                        <tr><td><code>reporter</code></td><td>CSReporter</td><td>Test reporting (pass, fail, info, warn)</td></tr>
                        <tr><td><code>expect</code></td><td>CSExpect</td><td>Assertions with auto-screenshots</td></tr>
                        <tr><td><code>navigate</code></td><td>function</td><td>Navigate to URL: await navigate(url)</td></tr>
                        <tr><td><code>browserManager</code></td><td>CSBrowserManager</td><td>Browser switching and context control</td></tr>
                        <tr><td><code>ctx</code></td><td>CSContext</td><td>Test context for sharing data between tests</td></tr>
                        <tr><td><code>data</code></td><td>object</td><td>Current data row in data-driven tests</td></tr>
                        <tr><td><code>iteration</code></td><td>object</td><td>Iteration info: index, current, total, isFirst, isLast</td></tr>
                        <tr><td><code>db</code></td><td>CSDatabaseManager</td><td>Database operations</td></tr>
                        <tr><td><code>apiClient</code></td><td>CSAPIClient</td><td>API testing client</td></tr>
                        <tr><td><code>loginPage, dashboardPage, etc.</code></td><td>@CSPage</td><td>Auto-injected page objects (based on @CSPage decorators)</td></tr>
                    </tbody>
                </table>

                <h3>Execution Modes</h3>

                <h4>describe.serial() - Sequential Execution</h4>
                <p>Tests run in order on the SAME worker. If one test fails, remaining tests are SKIPPED. Use for dependent test flows.</p>
                <pre><code>describe.serial('Login Flow - Dependent Steps', {
    tags: ['@serial', '@login', '@TestPlanId:600']
}, () => {

    beforeAll('Initialize session', async ({ ctx, reporter }) => {
        ctx.set('sessionStart', Date.now());
        reporter.info('Starting serial login flow');
    });

    afterAll('Report session duration', async ({ ctx, reporter }) => {
        const duration = Date.now() - Number(ctx.get('sessionStart'));
        reporter.info(`Flow completed in ${duration}ms`);
    });

    test('Step 1: Navigate to login', { tags: ['@TC601'] }, async ({ loginPage, ctx }) => {
        await loginPage.navigate();
        ctx.set('navigated', true);  // Share data with next test
    });

    test('Step 2: Enter credentials', { tags: ['@TC602'] }, async ({ loginPage, ctx, config }) => {
        if (!ctx.get('navigated')) throw new Error('Step 1 failed');

        const password = config.get('APP_PASSWORD', 'admin123');
        await loginPage.enterUsername('Admin');
        await loginPage.enterPassword(password);
        ctx.set('credentialsEntered', true);
    });

    test('Step 3: Submit and verify', { tags: ['@TC603'] }, async ({ loginPage, ctx }) => {
        if (!ctx.get('credentialsEntered')) throw new Error('Step 2 failed');

        await loginPage.clickLoginButton();
        await loginPage.verifyLoginSuccess();
    });
});</code></pre>

                <h4>describe.parallel() - Parallel Execution</h4>
                <p>Tests run on DIFFERENT workers simultaneously. Each test is independent. Use for tests that don't share state.</p>
                <pre><code>describe.parallel('Independent Module Tests', {
    tags: ['@parallel', '@modules']
}, () => {

    test('Navigate to Admin module', { tags: ['@TC611'] }, async ({ loginPage, dashboardPage, config }) => {
        // Each test logs in independently
        const password = config.get('APP_PASSWORD', 'admin123');
        await loginPage.navigate();
        await loginPage.login('Admin', password);

        await dashboardPage.clickMenuItem('Admin');
        await dashboardPage.verifyPageHeader('Admin');
    });

    test('Navigate to PIM module', { tags: ['@TC612'] }, async ({ loginPage, dashboardPage, config }) => {
        const password = config.get('APP_PASSWORD', 'admin123');
        await loginPage.navigate();
        await loginPage.login('Admin', password);

        await dashboardPage.clickMenuItem('PIM');
        await dashboardPage.verifyPageHeader('PIM');
    });
});</code></pre>

                <h4>describe.configure() - Configure Mode Settings</h4>
                <pre><code>describe('Configured Tests', { tags: ['@configured'] }, () => {
    // Configure all tests in this describe
    describe.configure({
        mode: 'serial',       // 'serial' or 'parallel'
        timeout: 60000,       // Test timeout in ms
        retries: 1            // Number of retries on failure
    });

    test('Test with custom settings', async ({ dashboardPage }) => {
        await dashboardPage.verifyDashboardLoaded();
    });
});</code></pre>

                <h4>describe.skip() and describe.fixme()</h4>
                <pre><code>// Skip entire describe block
describe.skip('Legacy Module Tests', { tags: ['@legacy'] }, () => {
    test('Legacy feature', async () => {
        // These tests will not run
    });
});

// Mark describe as needing fixes (with reason)
describe.fixme('New Reporting Module', 'Module not yet deployed to test environment', () => {
    test('Generate report', async () => {
        // Skipped with reason shown in report
    });
});</code></pre>

                <h3>Test Annotations (Decorator Style)</h3>
                <table>
                    <thead><tr><th>Annotation</th><th>Description</th><th>Effect</th></tr></thead>
                    <tbody>
                        <tr><td><code>test.skip(title, reason, fn)</code></td><td>Skip test with reason</td><td>Test skipped, shows in report</td></tr>
                        <tr><td><code>test.fixme(title, reason, fn)</code></td><td>Mark as broken/needs fix</td><td>Test skipped, flagged as fixme</td></tr>
                        <tr><td><code>test.fail(title, reason, fn)</code></td><td>Expected to fail</td><td>Failure = pass, pass = fail</td></tr>
                        <tr><td><code>test.slow(title, fn)</code></td><td>Slow test</td><td>3x timeout automatically</td></tr>
                    </tbody>
                </table>

                <pre><code>describe('Test Annotations Demo', { tags: ['@annotations'] }, () => {

    // Normal test
    test('Normal test', { tags: ['@TC631'] }, async ({ dashboardPage }) => {
        await dashboardPage.verifyDashboardLoaded();
    });

    // Skipped test with reason
    test.skip('Bulk employee import', 'CSV import feature temporarily disabled', async () => {
        // Will not run - skipped
    });

    // Fixme test with reason
    test.fixme('Advanced search filters', 'Search autocomplete has known bug #789', async () => {
        // Will not run - marked as fixme
    });

    // Expected failure - test passes if assertion fails
    test.fail('Invalid session handling', 'Known bug: Session not invalidated on browser close', async ({ dashboardPage }) => {
        // This assertion is expected to fail
        await dashboardPage.verifyPageHeader('NonExistentPage');
    });

    // Slow test - automatically gets 3x timeout
    test.slow('Full menu navigation cycle', async ({ dashboardPage, reporter }) => {
        const menus = ['Admin', 'PIM', 'Leave', 'Time', 'Recruitment'];

        for (const menu of menus) {
            await dashboardPage.clickMenuItem(menu);
            await dashboardPage.verifyPageHeader(menu);
        }
        reporter.pass('Completed full menu navigation');
    });
});</code></pre>

                <h3>Runtime Annotations (Inside Test Body)</h3>
                <p>Conditionally skip, fail, or extend timeout based on runtime conditions.</p>

                <pre><code>describe('Runtime Annotations', { tags: ['@runtime'] }, () => {

    test('Skip in CI environment', { tags: ['@local-only'] }, async ({ dashboardPage, reporter }) => {
        const isCI = process.env.CI === 'true';
        test.skip(isCI, 'Visual validation requires real browser - skipping in CI');

        // Only runs locally
        await dashboardPage.verifyDashboardLoaded();
        reporter.pass('Local-only visual validation completed');
    });

    test('Conditional fixme based on feature flag', { tags: ['@feature-flag'] }, async ({ config }) => {
        const newUIEnabled = config.get('NEW_UI_ENABLED', 'false') === 'true';
        test.fixme(!newUIEnabled, 'New UI feature flag not enabled');

        // Only runs if NEW_UI_ENABLED=true
    });

    test('Expected failure on Firefox', { tags: ['@browser-compat'] }, async ({ dashboardPage }) => {
        const browserName = process.env.BROWSER || 'chromium';
        test.fail(browserName === 'firefox', 'Known Firefox rendering issue');

        await dashboardPage.verifyDashboardLoaded();
    });

    test('Extended timeout for slow network', { tags: ['@timeout'] }, async ({ dashboardPage }) => {
        const isSlowNetwork = process.env.SLOW_NETWORK === 'true';
        if (isSlowNetwork) {
            test.setTimeout(120000); // 2 minutes
        }

        await dashboardPage.verifyDashboardLoaded();
    });

    test('Slow test flag at runtime', async ({ dashboardPage, config }) => {
        const isHeavyTest = config.get('HEAVY_TEST', 'false') === 'true';
        test.slow(isHeavyTest, 'Heavy test iteration - extended timeout');

        await dashboardPage.verifyAllMenuItemsVisible();
    });
});</code></pre>

                <h3>test.info() API</h3>
                <p>Access test metadata, add custom annotations, and attach files to reports.</p>

                <pre><code>describe('Test Info API', { tags: ['@testinfo'] }, () => {

    test('Access test metadata', { tags: ['@metadata'] }, async ({ reporter }) => {
        const info = test.info();

        reporter.info(`Test title: ${info.title}`);
        reporter.info(`Title path: ${info.titlePath.join(' > ')}`);
        reporter.info(`Retry attempt: ${info.retry}`);
        reporter.info(`Project: ${info.project}`);
        reporter.info(`Timeout: ${info.timeout}ms`);
    });

    test('Add custom annotations', { tags: ['@custom-annotations'] }, async ({ dashboardPage }) => {
        const info = test.info();

        // Add custom annotations that appear in reports
        info.annotations.push({ type: 'owner', description: 'QA Team' });
        info.annotations.push({ type: 'jira', description: 'OHRM-1234' });
        info.annotations.push({ type: 'category', description: 'Smoke Test' });
        info.annotations.push({ type: 'priority', description: 'P1' });

        await dashboardPage.verifyDashboardLoaded();
    });

    test('Attach files to report', { tags: ['@attachments'] }, async ({ dashboardPage }) => {
        const info = test.info();
        const menuItems = await dashboardPage.getMenuItems();

        // Attach JSON data
        await info.attach('menu-items', {
            body: JSON.stringify({ menus: menuItems, count: menuItems.length }, null, 2),
            contentType: 'application/json'
        });

        // Attach text log
        await info.attach('execution-log', {
            body: `Test executed at: ${new Date().toISOString()}\nMenus found: ${menuItems.length}`,
            contentType: 'text/plain'
        });

        // Attach from buffer
        await info.attach('screenshot', {
            body: await dashboardPage.screenshot(),
            contentType: 'image/png'
        });
    });
});</code></pre>

                <h3>Test Steps - test.step()</h3>
                <p>Organize test actions into logical groups with hierarchical structure, timing, and return values.</p>

                <h4>test.step Methods</h4>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>test.step(title, body)</code></td><td>Create named step</td><td>Promise&lt;T&gt; (body return value)</td></tr>
                        <tr><td><code>test.step.skip(title, body)</code></td><td>Skip step (shows in report)</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>test.step.fixme(title, body)</code></td><td>Mark step as broken</td><td>Promise&lt;void&gt;</td></tr>
                    </tbody>
                </table>

                <pre><code>test('Complete workflow with nested steps', { tags: ['@workflow'] }, async ({ loginPage, dashboardPage, config }) => {
    const password = config.get('APP_PASSWORD', 'admin123');

    // Basic step
    await test.step('Navigate to application', async () => {
        await loginPage.navigate();
    });

    // Nested steps for complex flows
    await test.step('Authenticate user', async () => {
        await test.step('Enter username', async () => {
            await loginPage.enterUsername('Admin');
        });

        await test.step('Enter password', async () => {
            await loginPage.enterPassword(password);
        });

        await test.step('Submit form', async () => {
            await loginPage.clickLoginButton();
        });
    });

    // Step with return value
    const menuCount = await test.step('Count menu items', async () => {
        const items = await dashboardPage.getMenuItems();
        return items.length;
    });

    await test.step('Verify menu count', async () => {
        if (menuCount < 5) {
            throw new Error(`Expected at least 5 menu items, found ${menuCount}`);
        }
    });

    // Skip optional step (shows in report as skipped)
    await test.step.skip('Configure advanced settings', async () => {
        // This step is skipped but visible in report
    });

    // Mark step as needs fix
    await test.step.fixme('Export to PDF', async () => {
        // Known issue - tracked in report
    });
});</code></pre>

                <h3>Named Hooks</h3>
                <p>Hooks can have descriptive titles that appear in reports, making it clear what each hook does.</p>

                <pre><code>describe('Named Hooks Demo', { tags: ['@hooks'] }, () => {

    // Named beforeAll - title appears in report
    beforeAll('Initialize test session', async ({ ctx, reporter }) => {
        ctx.set('sessionId', `session-${Date.now()}`);
        ctx.set('testsRun', 0);
        reporter.info(`Test session initialized: ${ctx.get('sessionId')}`);
    });

    // Named afterAll
    afterAll('Report session statistics', async ({ ctx, reporter }) => {
        const testsRun = Number(ctx.get('testsRun'));
        reporter.info(`Session completed: ${testsRun} tests executed`);
    });

    // Named beforeEach
    beforeEach('Login before each test', async ({ loginPage, config }) => {
        const password = config.get('APP_PASSWORD', 'admin123');
        await loginPage.navigate();
        await loginPage.login('Admin', password);
    });

    // Named afterEach
    afterEach('Log test duration', async ({ ctx, reporter }) => {
        const testsRun = Number(ctx.get('testsRun')) + 1;
        ctx.set('testsRun', testsRun);
        reporter.info(`Test completed (test #${testsRun})`);
    });

    test('Dashboard check', { tags: ['@TC671'] }, async ({ dashboardPage }) => {
        await dashboardPage.verifyDashboardLoaded();
    });
});</code></pre>

                <h3>Browser Management</h3>
                <p>Switch browsers and clear context during test execution for multi-user workflows.</p>

                <pre><code>describe('Browser Management', { tags: ['@browser'] }, () => {

    test('Switch browser during test', { tags: ['@switch'] }, async ({ loginPage, config, browserManager }) => {
        const password = config.get('APP_PASSWORD', 'admin123');

        // Login in default browser (chromium)
        await loginPage.login('Admin', password);
        await loginPage.verifyLoginSuccess();

        // Switch to Edge - session is lost, starts fresh
        await browserManager.switchBrowser('edge');
        await loginPage.waitForPageLoad();

        // Verify browser type
        const browserType = browserManager.getCurrentBrowserType();
        expect(browserType).toBe('edge');

        // Login again in Edge
        await loginPage.login('Admin', password);
        await loginPage.verifyLoginSuccess();
    });

    test('Multi-user workflow with context clearing', { tags: ['@multi-user'] }, async ({ loginPage, dashboardPage, config, browserManager }) => {
        const password = config.get('APP_PASSWORD', 'admin123');

        // User 1: Requester logs in
        await loginPage.login('Admin', password);
        await loginPage.verifyLoginSuccess();
        await dashboardPage.clickMenuItem('Leave');

        // Clear context for different user (preserves test context)
        await browserManager.clearContextAndReauthenticate();
        await loginPage.waitForPageLoad();

        // User 2: Approver logs in
        await loginPage.login('Admin', password);
        await loginPage.verifyLoginSuccess();
    });

    test('Context clearing preserves test data', { tags: ['@context'] }, async ({ loginPage, config, browserManager, ctx }) => {
        const password = config.get('APP_PASSWORD', 'admin123');
        await loginPage.login('Admin', password);

        // Save data in test context
        ctx.set('testData', 'preserved-value');

        // Clear browser context (cookies, storage)
        await browserManager.clearContextAndReauthenticate();
        await loginPage.waitForPageLoad();

        // Test context still has data
        const savedData = ctx.get('testData');
        expect(savedData).toBe('preserved-value');
    });
});</code></pre>

                <h3>Describe and Test Options</h3>
                <table>
                    <thead><tr><th>Option</th><th>Level</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>tags</code></td><td>describe, test</td><td>Array of tags for filtering and ADO mapping</td></tr>
                        <tr><td><code>enabled</code></td><td>describe, test</td><td>Enable/disable (default: true)</td></tr>
                        <tr><td><code>mode</code></td><td>describe</td><td>'serial' or 'parallel'</td></tr>
                        <tr><td><code>timeout</code></td><td>describe, test</td><td>Timeout in milliseconds</td></tr>
                        <tr><td><code>retries</code></td><td>describe, test</td><td>Number of retries on failure</td></tr>
                        <tr><td><code>dataSource</code></td><td>describe, test</td><td>Data source for data-driven tests</td></tr>
                        <tr><td><code>useData</code></td><td>test</td><td>true/false to control data iteration</td></tr>
                        <tr><td><code>dependsOn</code></td><td>test</td><td>Test dependency by tag or name</td></tr>
                        <tr><td><code>expectedToFail</code></td><td>test</td><td>Mark as expected failure with reason</td></tr>
                    </tbody>
                </table>

                <h3>ADO Integration Tags</h3>
                <p>Tags for Azure DevOps test case mapping. These are inherited from describe to tests.</p>

                <pre><code>describe('ADO Integration', {
    tags: ['@TestPlanId:417', '@TestSuiteId:418']  // Feature-level tags
}, () => {

    test('Login test', {
        tags: ['@TestCaseId:419', '@smoke', '@critical']  // Single test case
    }, async ({ loginPage }) => {
        // Maps to ADO Test Case 419
    });

    test('Logout test', {
        tags: ['@TestCaseId:{420,421,422}', '@regression']  // Multiple test cases
    }, async ({ dashboardPage }) => {
        // Maps to ADO Test Cases 420, 421, 422
    });
});

/*
 * Supported ADO tag formats:
 * - @TestPlanId:417        - Maps to Test Plan
 * - @TestSuiteId:418       - Maps to Test Suite
 * - @TestCaseId:419        - Maps to single Test Case
 * - @TestCaseId:{419,420}  - Maps to multiple Test Cases
 */</code></pre>
            </section>

            <!-- BDD FORMAT -->
            <section id="bdd-format">
                <h2>BDD/Cucumber Tests</h2>

                <h3>Feature File</h3>
                <pre><code>@login @smoke
Feature: User Authentication
  As a user I want to login to the application

  Background:
    Given I navigate to the login page

  @TC001 @critical
  Scenario: Successful login with valid credentials
    When I enter username "Admin"
    And I enter password "{config:PASSWORD}"
    And I click the login button
    Then I should see the dashboard
    And the welcome message should contain "Admin"

  @TC002 @negative
  Scenario: Login fails with invalid credentials
    When I enter username "invalid"
    And I enter password "wrong"
    And I click the login button
    Then I should see an error message
    And the error should contain "Invalid credentials"

  @TC003 @data-driven
  Scenario Outline: Login with different users
    When I enter username "&lt;username&gt;"
    And I enter password "&lt;password&gt;"
    And I click the login button
    Then I should see the "&lt;expected&gt;" result

    Examples:
      | username | password  | expected  |
      | Admin    | admin123  | success   |
      | User1    | user123   | success   |
      | Invalid  | wrong     | error     |</code></pre>

                <h3>Step Definitions</h3>
                <pre><code>import { CSBDDStepDef, Page, StepDefinitions } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporting';

@StepDefinitions
export class LoginSteps {

    @Page('login')
    private loginPage!: LoginPage;

    @Page('dashboard')
    private dashboardPage!: DashboardPage;

    @CSBDDStepDef('I navigate to the login page')
    async navigateToLogin() {
        await this.loginPage.navigate();
        CSReporter.pass('Navigated to login page');
    }

    @CSBDDStepDef('I enter username {string}')
    async enterUsername(username: string) {
        await this.loginPage.enterUsername(username);
        CSReporter.info(`Entered username: ${username}`);
    }

    @CSBDDStepDef('I enter password {string}')
    async enterPassword(password: string) {
        await this.loginPage.enterPassword(password);
        CSReporter.info('Entered password');
    }

    @CSBDDStepDef('I click the login button')
    async clickLogin() {
        await this.loginPage.clickLoginButton();
    }

    @CSBDDStepDef('I should see the dashboard')
    async verifyDashboard() {
        await this.dashboardPage.verifyLoaded();
        CSReporter.pass('Dashboard is visible');
    }

    @CSBDDStepDef('the welcome message should contain {string}')
    async verifyWelcome(expectedText: string) {
        const message = await this.dashboardPage.getWelcomeMessage();
        if (!message.includes(expectedText)) {
            throw new Error(`Expected "${expectedText}" in welcome message`);
        }
        CSReporter.pass(`Welcome message contains: ${expectedText}`);
    }
}</code></pre>

                <h3>Config Parameter Injection</h3>
                <pre><code># In feature file, use {config:KEY} syntax
When I enter password "{config:PASSWORD}"

# Framework automatically resolves to config.get('PASSWORD')</code></pre>

                <h3>BDD External Data Sources</h3>
                <p>The framework supports multiple ways to define external data sources in feature files for data-driven BDD testing.</p>

                <h4>Method 1: @DataProvider Tag</h4>
                <p>Use the <code>@DataProvider</code> tag on a Scenario Outline to specify external data source.</p>

                <pre><code>Feature: Data-Driven Login with @DataProvider

  # CSV Data Source
  @DataProvider(source="test/data/users.csv", type="csv")
  Scenario Outline: Login with CSV data
    Given I am on the login page
    When I enter username "&lt;username&gt;" and password "&lt;password&gt;"
    And I click the login button
    Then I should see "&lt;expected&gt;" result

    Examples:
      | username | password | expected |

  # Excel Data Source with specific sheet
  @DataProvider(source="test/data/users.xlsx", type="excel", sheet="LoginData")
  Scenario Outline: Login with Excel data
    Given I am on the login page
    When I enter username "&lt;username&gt;" and password "&lt;password&gt;"
    Then login result should be "&lt;result&gt;"

    Examples:
      | username | password | result |

  # JSON Data Source with JSONPath
  @DataProvider(source="test/data/users.json", type="json", path="$.testcases[*]")
  Scenario Outline: Login with JSON data
    Given I am on the login page
    When I login as "&lt;username&gt;" with "&lt;password&gt;"
    Then I verify "&lt;expectedResult&gt;"

    Examples:
      | username | password | expectedResult |

  # With filter - only run active test cases with priority <= 2
  @DataProvider(source="test/data/users.csv", type="csv", filter="active=true&priority<=2")
  Scenario Outline: Login with filtered data
    When I login as "&lt;username&gt;"
    Then result is "&lt;expected&gt;"

    Examples:
      | username | expected |</code></pre>

                <h4>@DataProvider Tag Parameters</h4>
                <table>
                    <thead><tr><th>Parameter</th><th>Required</th><th>Description</th><th>Example</th></tr></thead>
                    <tbody>
                        <tr><td><code>source</code></td><td>Yes</td><td>Path to data file (relative to project root)</td><td><code>test/data/users.csv</code></td></tr>
                        <tr><td><code>type</code></td><td>No*</td><td>Data source type: csv, json, excel, xml, database</td><td><code>excel</code></td></tr>
                        <tr><td><code>sheet</code></td><td>No</td><td>Excel sheet name (defaults to first sheet)</td><td><code>LoginData</code></td></tr>
                        <tr><td><code>path</code></td><td>No</td><td>JSONPath for JSON files</td><td><code>$.users[*]</code></td></tr>
                        <tr><td><code>xpath</code></td><td>No</td><td>XPath for XML files</td><td><code>//user</code></td></tr>
                        <tr><td><code>filter</code></td><td>No</td><td>Filter expression to select rows</td><td><code>active=true</code></td></tr>
                        <tr><td><code>connection</code></td><td>No</td><td>Database connection name</td><td><code>PRACTICE_MYSQL</code></td></tr>
                        <tr><td><code>query</code></td><td>No</td><td>SQL query for database type</td><td><code>SELECT * FROM users</code></td></tr>
                    </tbody>
                </table>
                <p><em>* Type is auto-detected from file extension if not specified</em></p>

                <h4>Method 2: Examples JSON Configuration</h4>
                <p>Inline JSON configuration in the Examples section name.</p>

                <pre><code>Feature: Data-Driven with Examples JSON Config

  @data-driven
  Scenario Outline: Login with JSON-configured data source
    Given I am on the login page
    When I enter username "&lt;username&gt;" and password "&lt;password&gt;"
    Then I should see "&lt;expected&gt;"

    # JSON configuration as Examples name
    Examples: {"type": "json", "source": "test/data/users.json", "path": "$.testcases[*]"}
      | username | password | expected |

  @data-driven
  Scenario Outline: Login with Excel-configured data source
    When I login as "&lt;username&gt;"
    Then result is "&lt;result&gt;"

    # Excel with sheet specification
    Examples: {"type": "excel", "source": "test/data/tests.xlsx", "sheet": "LoginTests"}
      | username | result |

  @data-driven
  Scenario Outline: Login with CSV and filter
    When I test user "&lt;username&gt;"
    Then status is "&lt;status&gt;"

    # CSV with filter
    Examples: {"type": "csv", "source": "test/data/users.csv", "filter": "role=Admin|role=Manager"}
      | username | status |

  @data-driven
  Scenario Outline: Database-driven test
    When I verify user "&lt;username&gt;" exists
    Then account status is "&lt;status&gt;"

    # Database query as data source
    Examples: {"type": "database", "connection": "PRACTICE_MYSQL", "query": "SELECT username, status FROM users WHERE active=1"}
      | username | status |</code></pre>

                <h4>Examples JSON Configuration Options</h4>
                <pre><code># CSV
Examples: {"type": "csv", "source": "path/to/file.csv"}
Examples: {"type": "csv", "source": "path/to/file.csv", "filter": "column=value"}

# JSON with JSONPath
Examples: {"type": "json", "source": "path/to/file.json", "path": "$.data[*]"}
Examples: {"type": "json", "source": "path/to/file.json", "path": "$.users[?(@.active==true)]"}

# Excel with sheet
Examples: {"type": "excel", "source": "path/to/file.xlsx", "sheet": "SheetName"}
Examples: {"type": "excel", "source": "path/to/file.xlsx", "sheet": "Sheet1", "filter": "status=active"}

# XML with XPath
Examples: {"type": "xml", "source": "path/to/file.xml", "xpath": "//testcase"}

# Database
Examples: {"type": "database", "connection": "DB_NAME", "query": "SELECT * FROM table"}

# API endpoint
Examples: {"type": "api", "url": "https://api.example.com/data", "path": "$.results[*]"}</code></pre>

                <h4>Method 3: Feature-Level @DataProvider</h4>
                <p>Apply data source to all Scenario Outlines in a feature file.</p>

                <pre><code>@DataProvider(source="test/data/comprehensive-users.csv", type="csv")
Feature: Comprehensive User Tests

  # This scenario will use the feature-level data source
  Scenario Outline: Verify user login
    When I login as "&lt;username&gt;" with "&lt;password&gt;"
    Then result is "&lt;loginResult&gt;"

    Examples:
      | username | password | loginResult |

  # This scenario also uses the feature-level data source
  Scenario Outline: Verify user permissions
    Given I am logged in as "&lt;username&gt;"
    When I check permissions
    Then I should have "&lt;role&gt;" access

    Examples:
      | username | role |

  # Regular scenario (not outline) - runs once, not affected by @DataProvider
  Scenario: Verify login page loads
    Given I navigate to the login page
    Then the login form should be visible</code></pre>

                <h4>Combining with Dynamic Placeholders</h4>
                <p>Data files can use dynamic placeholders that are resolved at runtime.</p>

                <pre><code># test/data/dynamic-users.csv
username,password,email,sessionId
admin_&lt;random&gt;,&lt;config:ADMIN_PASSWORD&gt;,&lt;generate:email&gt;,&lt;uuid&gt;
user_&lt;timestamp&gt;,pass123,test@example.com,&lt;uuid&gt;</code></pre>

                <pre><code>@DataProvider(source="test/data/dynamic-users.csv", type="csv")
Feature: Dynamic Data Tests

  Scenario Outline: Test with dynamic data
    # &lt;username&gt; will be like "admin_k2x9m4n" (random resolved)
    # &lt;password&gt; will be the actual config value (decrypted if encrypted)
    # &lt;email&gt; will be a generated email like "test_1735689600@example.com"
    # &lt;sessionId&gt; will be a UUID
    When I create user "&lt;username&gt;" with email "&lt;email&gt;"
    And I authenticate with password "&lt;password&gt;"
    Then session ID "&lt;sessionId&gt;" should be valid

    Examples:
      | username | password | email | sessionId |</code></pre>

                <h4>Scenario Context Variables</h4>
                <p>Share data between steps using scenario context.</p>

                <pre><code>Feature: Context Variable Sharing

  Scenario: Create and verify user
    Given I create a new user
      # Step stores: ctx.set('userId', '12345')
      # Step stores: ctx.set('userName', 'testuser')
    When I update user with ID "{scenario:userId}"
    Then user "{scenario:userName}" should be updated
    And I delete user "{scenario:userId}"</code></pre>

                <div class="info-box tip">
                    <strong>BDD Data Source Best Practices</strong>
                    <ul>
                        <li>Use <code>@DataProvider</code> tag for clean, readable feature files</li>
                        <li>Use <code>Examples: {json}</code> format when you need inline configuration</li>
                        <li>Keep data files in a <code>test/data/</code> directory structure</li>
                        <li>Use filters to run subsets of data without modifying files</li>
                        <li>Use <code>{config:KEY}</code> for environment-specific values in steps</li>
                        <li>Use <code>{scenario:var}</code> to share data between steps</li>
                        <li>Dynamic placeholders (<code>&lt;random&gt;</code>, <code>&lt;uuid&gt;</code>) are resolved when data loads</li>
                    </ul>
                </div>
            </section>

            <!-- DATA-DRIVEN -->
            <section id="data-driven">
                <h2>Data-Driven Testing</h2>

                <p>The framework supports comprehensive data-driven testing with multiple data sources, filtering, and smart iteration control. Data can be defined at describe or test level.</p>

                <h3>Data Source Types</h3>
                <table>
                    <thead><tr><th>Type</th><th>Description</th><th>Options</th></tr></thead>
                    <tbody>
                        <tr><td><code>inline</code></td><td>Array of objects defined in code</td><td><code>data</code>: Array of row objects</td></tr>
                        <tr><td><code>csv</code></td><td>CSV file</td><td><code>source</code>: File path</td></tr>
                        <tr><td><code>json</code></td><td>JSON file with JSONPath selector</td><td><code>source</code>, <code>path</code>: JSONPath expression</td></tr>
                        <tr><td><code>excel</code></td><td>Excel file (.xlsx)</td><td><code>source</code>, <code>sheet</code>: Sheet name</td></tr>
                        <tr><td><code>xml</code></td><td>XML file with XPath selector</td><td><code>source</code>, <code>xpath</code>: XPath expression</td></tr>
                        <tr><td><code>database</code></td><td>Database query</td><td><code>connection</code>, <code>query</code>: SQL query</td></tr>
                        <tr><td><code>api</code></td><td>API endpoint</td><td><code>url</code>, <code>method</code>, <code>path</code>: JSONPath</td></tr>
                    </tbody>
                </table>

                <h3>Iteration Object</h3>
                <p>The <code>iteration</code> fixture provides information about the current data iteration:</p>
                <table>
                    <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>index</code></td><td>number</td><td>Zero-based index (0, 1, 2...)</td></tr>
                        <tr><td><code>current</code></td><td>number</td><td>One-based index (1, 2, 3...)</td></tr>
                        <tr><td><code>total</code></td><td>number</td><td>Total number of data rows</td></tr>
                        <tr><td><code>isFirst</code></td><td>boolean</td><td>True if first iteration</td></tr>
                        <tr><td><code>isLast</code></td><td>boolean</td><td>True if last iteration</td></tr>
                    </tbody>
                </table>

                <h3>Pattern 1: Inline Data Array</h3>
                <pre><code>describe('Login with inline data', {
    tags: ['@inline-data'],
    dataSource: {
        type: 'inline',
        data: [
            { username: 'Admin', password: 'admin123', expectedResult: 'success' },
            { username: 'Invalid', password: 'wrong', expectedResult: 'failure' },
            { username: 'Test', password: 'test123', expectedResult: 'failure' }
        ]
    }
}, () => {
    test('Login with {username}', async ({ loginPage, reporter, data }) => {
        await loginPage.enterUsername(data.username);
        await loginPage.enterPassword(data.password);
        await loginPage.clickLoginButton();

        if (data.expectedResult === 'success') {
            await loginPage.verifyLoginSuccess();
            reporter.pass(`Login successful for ${data.username}`);
        } else {
            await loginPage.verifyErrorMessage('Invalid credentials');
            reporter.pass(`Login failed as expected for ${data.username}`);
        }
    });
});</code></pre>

                <h3>Pattern 2: CSV Data Source</h3>
                <pre><code>describe('Login with CSV data', {
    tags: ['@csv-data'],
    dataSource: {
        type: 'csv',
        source: 'test/myproject/data/users.csv'
    }
}, () => {
    test('Login with CSV row', async ({ loginPage, reporter, data, iteration }) => {
        reporter.info(`Iteration ${iteration.current}/${iteration.total}: Testing ${data.username}`);
        reporter.info(`First: ${iteration.isFirst}, Last: ${iteration.isLast}`);

        await loginPage.enterUsername(data.username);
        await loginPage.enterPassword(data.password);
        await loginPage.clickLoginButton();

        if (data.expectedResult === 'success') {
            await loginPage.verifyLoginSuccess();
        } else {
            await loginPage.verifyErrorMessage('Invalid credentials');
        }
    });
});</code></pre>

                <h3>Pattern 3: JSON Data Source with JSONPath</h3>
                <pre><code>describe('Login with JSON data', {
    tags: ['@json-data'],
    dataSource: {
        type: 'json',
        source: 'test/myproject/data/users.json',
        path: '$.data[*]'  // JSONPath to extract array
    }
}, () => {
    test('Login with JSON row', async ({ loginPage, data }) => {
        await loginPage.login(data.username, data.password);
    });
});</code></pre>

                <h3>Pattern 4: Excel Data Source</h3>
                <pre><code>describe('Login with Excel data', {
    tags: ['@excel-data'],
    dataSource: {
        type: 'excel',
        source: 'test/myproject/data/users.xlsx',
        sheet: 'Users'  // Specific sheet name
    }
}, () => {
    test('Login with Excel row', async ({ loginPage, data }) => {
        await loginPage.login(data.username, data.password);
    });
});</code></pre>

                <h3>Pattern 5: XML Data Source with XPath</h3>
                <pre><code>describe('Login with XML data', {
    tags: ['@xml-data'],
    dataSource: {
        type: 'xml',
        source: 'test/myproject/data/users.xml',
        xpath: '//user'  // XPath to select nodes
    }
}, () => {
    test('Login with XML row', async ({ loginPage, data }) => {
        await loginPage.login(data.username, data.password);
    });
});</code></pre>

                <h3>Pattern 6: Database Data Source</h3>
                <pre><code>describe('Login with database data', {
    tags: ['@database-data'],
    dataSource: {
        type: 'database',
        connection: 'PRACTICE_MYSQL',  // Uses DB_PRACTICE_MYSQL_* env vars
        query: 'SELECT username, password, expectedResult FROM test_users WHERE active = 1'
    }
}, () => {
    test('Login with database row', async ({ loginPage, reporter, data }) => {
        reporter.info(`Testing database user: ${data.username}`);
        await loginPage.login(data.username, data.password);
    });
});</code></pre>

                <h3>Pattern 7: API Data Source</h3>
                <pre><code>describe('Login with API data', {
    tags: ['@api-data'],
    dataSource: {
        type: 'api',
        url: 'https://api.example.com/test-users',
        method: 'GET',
        path: '$.users[*]'  // JSONPath to extract from response
    }
}, () => {
    test('Login with API row', async ({ loginPage, reporter, data }) => {
        reporter.info(`Testing API user: ${data.username}`);
        await loginPage.login(data.username, data.password);
    });
});</code></pre>

                <h3>Pattern 8: Environment-Specific Data Paths</h3>
                <pre><code>describe('Login with environment-specific data', {
    tags: ['@env-data'],
    dataSource: {
        type: 'json',
        source: 'test/myproject/data/{env}/users.json',  // {env} replaced at runtime
        path: '$.users[*]'
    }
}, () => {
    test('Login with environment data', async ({ loginPage, reporter, config, data }) => {
        const env = config.get('ENVIRONMENT', 'dev');
        reporter.info(`Testing with ${env} environment data: ${data.username}`);
        await loginPage.login(data.username, data.password);
    });
});</code></pre>

                <h3>Data Filtering - Complete Reference</h3>
                <p>Filter expressions allow you to select specific rows from data sources without modifying the source files. Filters work with all data source types (CSV, JSON, Excel, XML, Database, API).</p>

                <h4>Comparison Operators</h4>
                <table>
                    <thead><tr><th>Operator</th><th>Name</th><th>Syntax</th><th>Description</th><th>Example</th></tr></thead>
                    <tbody>
                        <tr><td><code>=</code></td><td>Equals</td><td><code>field=value</code></td><td>Exact match (case-insensitive for strings, numeric for numbers)</td><td><code>status=active</code></td></tr>
                        <tr><td><code>!=</code></td><td>Not Equals</td><td><code>field!=value</code></td><td>Not equal to value</td><td><code>status!=disabled</code></td></tr>
                        <tr><td><code>&lt;&gt;</code></td><td>Not Equals (alt)</td><td><code>field&lt;&gt;value</code></td><td>Alternative syntax for not equals</td><td><code>status&lt;&gt;disabled</code></td></tr>
                        <tr><td><code>&gt;</code></td><td>Greater Than</td><td><code>field&gt;value</code></td><td>Greater than (numeric or lexicographic)</td><td><code>priority&gt;2</code></td></tr>
                        <tr><td><code>&lt;</code></td><td>Less Than</td><td><code>field&lt;value</code></td><td>Less than (numeric or lexicographic)</td><td><code>priority&lt;5</code></td></tr>
                        <tr><td><code>&gt;=</code></td><td>Greater or Equal</td><td><code>field&gt;=value</code></td><td>Greater than or equal to</td><td><code>priority&gt;=3</code></td></tr>
                        <tr><td><code>&lt;=</code></td><td>Less or Equal</td><td><code>field&lt;=value</code></td><td>Less than or equal to</td><td><code>priority&lt;=2</code></td></tr>
                        <tr><td><code>~</code></td><td>Contains</td><td><code>field~value</code></td><td>Case-insensitive substring match</td><td><code>tags~smoke</code></td></tr>
                        <tr><td><code>:</code></td><td>In List</td><td><code>field:val1,val2,val3</code></td><td>Value matches any in comma-separated list</td><td><code>role:Admin,Manager,Lead</code></td></tr>
                    </tbody>
                </table>

                <h4>Logical Operators</h4>
                <table>
                    <thead><tr><th>Operator</th><th>Name</th><th>Syntax</th><th>Description</th><th>Example</th></tr></thead>
                    <tbody>
                        <tr><td><code>&amp;</code></td><td>AND</td><td><code>filter1&amp;filter2</code></td><td>All conditions must be true</td><td><code>active=true&amp;priority&lt;=2</code></td></tr>
                        <tr><td><code>AND</code></td><td>AND (keyword)</td><td><code>filter1 AND filter2</code></td><td>Alternative AND syntax (case-insensitive)</td><td><code>active=true AND priority&lt;=2</code></td></tr>
                        <tr><td><code>|</code></td><td>OR</td><td><code>filter1|filter2</code></td><td>Any condition must be true</td><td><code>role=Admin|role=Manager</code></td></tr>
                        <tr><td><code>OR</code></td><td>OR (keyword)</td><td><code>filter1 OR filter2</code></td><td>Alternative OR syntax (case-insensitive)</td><td><code>role=Admin OR role=Manager</code></td></tr>
                    </tbody>
                </table>

                <h4>Operator Behavior Details</h4>
                <div class="info-box note">
                    <strong>Type-Aware Comparisons</strong>
                    <ul>
                        <li><strong>Numeric comparison:</strong> If both field value and filter value are valid numbers, numeric comparison is used</li>
                        <li><strong>String comparison:</strong> For non-numeric values, case-insensitive string comparison is used</li>
                        <li><strong>Boolean fields:</strong> Use <code>field=true</code> or <code>field=false</code> (string matching)</li>
                        <li><strong>Empty/null:</strong> Use <code>field=</code> (empty string) to match empty values</li>
                    </ul>
                </div>

                <h4>Filter Examples by Operator</h4>
                <pre><code>// EQUALS (=) - Case-insensitive string match or numeric equality
filter: 'status=active'           // Matches "active", "Active", "ACTIVE"
filter: 'priority=1'              // Matches numeric 1
filter: 'executeTest=true'        // Matches string "true"
filter: 'environment=QA'          // Matches "qa", "QA", "Qa"

// NOT EQUALS (!=, &lt;&gt;) - Exclude matching rows
filter: 'status!=disabled'        // Exclude disabled rows
filter: 'priority!=0'             // Exclude priority 0
filter: 'environment&lt;&gt;PROD'       // Exclude production data

// GREATER THAN (&gt;) and LESS THAN (&lt;)
filter: 'priority&gt;2'              // Priority greater than 2
filter: 'priority&lt;5'              // Priority less than 5
filter: 'order&gt;100'               // Order number greater than 100

// GREATER/LESS OR EQUAL (&gt;=, &lt;=)
filter: 'priority&gt;=3'             // Priority 3 or higher
filter: 'priority&lt;=2'             // Priority 2 or lower
filter: 'retryCount&lt;=3'           // Max 3 retries

// CONTAINS (~) - Substring match (case-insensitive)
filter: 'tags~smoke'              // Tags containing "smoke" (e.g., "smoke,regression")
filter: 'description~login'       // Description containing "login"
filter: 'name~admin'              // Name containing "admin" anywhere
filter: 'email~@gmail'            // Gmail addresses

// IN LIST (:) - Match any value in comma-separated list
filter: 'role:Admin,Manager,Lead' // Role is Admin OR Manager OR Lead
filter: 'environment:QA,UAT'      // Environment is QA or UAT
filter: 'browser:chrome,firefox'  // Browser is chrome or firefox
filter: 'priority:1,2'            // Priority is 1 or 2</code></pre>

                <h4>Combining Filters with Logical Operators</h4>
                <pre><code>// AND Logic (&amp;) - All conditions must match
filter: 'executeTest=true&amp;priority&lt;=2'
// â†’ Rows where executeTest is true AND priority is 2 or less

filter: 'status=active&amp;role=Admin&amp;environment=QA'
// â†’ Active Admin users in QA environment

filter: 'enabled=true&amp;category~smoke&amp;priority&lt;3'
// â†’ Enabled rows with "smoke" in category and priority under 3

// OR Logic (|) - Any condition can match
filter: 'role=Admin|role=Manager'
// â†’ Rows where role is Admin OR Manager

filter: 'priority=1|priority=2|priority=3'
// â†’ Rows with priority 1, 2, or 3 (equivalent to priority:1,2,3)

filter: 'status=pending|status=in_progress'
// â†’ Pending or in-progress items

// Using keyword syntax (AND, OR)
filter: 'status=active AND priority&lt;=2'
filter: 'role=Admin OR role=Manager'

// Complex combinations
filter: 'executeTest=true&amp;priority&lt;=2&amp;status!=skipped'
// â†’ Executable, high priority, not skipped

filter: 'environment:QA,UAT&amp;browser:chrome,firefox&amp;enabled=true'
// â†’ QA/UAT environment, Chrome/Firefox browser, enabled tests</code></pre>

                <h4>Spec Format Filter Examples</h4>
                <pre><code>// Simple equality filter
describe('Active users only', {
    dataSource: {
        type: 'csv',
        source: 'test/data/users.csv',
        filter: 'status=active'
    }
}, () => { /* tests */ });

// Numeric comparison filter
describe('High priority tests', {
    dataSource: {
        type: 'json',
        source: 'test/data/testcases.json',
        path: '$.tests[*]',
        filter: 'priority<=2'
    }
}, () => { /* tests */ });

// Contains filter for tags
describe('Smoke tests only', {
    dataSource: {
        type: 'excel',
        source: 'test/data/tests.xlsx',
        sheet: 'TestCases',
        filter: 'tags~smoke'
    }
}, () => { /* tests */ });

// In-list filter for multiple values
describe('Admin and Manager roles', {
    dataSource: {
        type: 'csv',
        source: 'test/data/users.csv',
        filter: 'role:Admin,Manager,TeamLead'
    }
}, () => { /* tests */ });

// Combined AND filter
describe('Ready high-priority tests', {
    dataSource: {
        type: 'csv',
        source: 'test/data/tests.csv',
        filter: 'executeTest=true&amp;priority<=2&amp;status=ready'
    }
}, () => { /* tests */ });

// Combined OR filter
describe('Critical or blocker issues', {
    dataSource: {
        type: 'json',
        source: 'test/data/issues.json',
        path: '$.issues[*]',
        filter: 'severity=critical|severity=blocker'
    }
}, () => { /* tests */ });

// Complex multi-condition filter
describe('Production smoke tests', {
    dataSource: {
        type: 'csv',
        source: 'test/data/comprehensive-tests.csv',
        filter: 'enabled=true&amp;tags~smoke&amp;environment:PROD,UAT&amp;priority<=2'
    }
}, () => { /* tests */ });</code></pre>

                <h4>BDD Feature File Filter Examples</h4>
                <pre><code># Simple filter
@DataProvider(source="test/data/users.csv", type="csv", filter="status=active")
Scenario Outline: Test active users
  When I login as "&lt;username&gt;"
  Then login should succeed

# Multiple conditions with AND
@DataProvider(source="test/data/tests.csv", type="csv", filter="enabled=true&amp;priority<=2")
Scenario Outline: Run high-priority enabled tests
  When I execute test "&lt;testName&gt;"
  Then result should be "&lt;expected&gt;"

# OR filter for multiple roles
@DataProvider(source="test/data/users.csv", type="csv", filter="role=Admin|role=Manager")
Scenario Outline: Test admin and manager users
  Given I login as "&lt;username&gt;" with role "&lt;role&gt;"
  Then I should have admin access

# In-list filter
@DataProvider(source="test/data/users.csv", type="csv", filter="environment:QA,UAT,DEV")
Scenario Outline: Test non-production environments
  When I test in "&lt;environment&gt;"
  Then environment config should load

# Contains filter
@DataProvider(source="test/data/tests.xlsx", type="excel", sheet="Regression", filter="tags~smoke")
Scenario Outline: Run smoke tests
  When I execute "&lt;testCase&gt;"
  Then it should pass

# Using Examples JSON format with filter
Examples: {"type": "csv", "source": "test/data/users.csv", "filter": "active=true&amp;role:Admin,User"}</code></pre>

                <h4>Sample Data File for Filters</h4>
                <pre><code># test/data/comprehensive-tests.csv
testId,testName,priority,status,enabled,tags,environment,role,browser
TC001,Login Admin,1,ready,true,smoke regression,QA,Admin,chrome
TC002,Login User,2,ready,true,smoke,QA,User,chrome
TC003,Create Order,1,ready,true,smoke critical,PROD,Admin,firefox
TC004,View Report,3,draft,false,regression,UAT,Manager,chrome
TC005,Delete User,2,ready,true,admin smoke,QA,Admin,chrome
TC006,Export Data,2,skipped,true,regression,DEV,User,firefox
TC007,Bulk Upload,1,ready,true,smoke critical,PROD,Admin,edge

# Filter examples for this data:
# filter="enabled=true"           â†’ TC001,TC002,TC003,TC005,TC006,TC007
# filter="priority<=2"            â†’ TC001,TC002,TC003,TC005,TC006,TC007
# filter="status=ready"           â†’ TC001,TC002,TC003,TC005,TC007
# filter="tags~smoke"             â†’ TC001,TC002,TC003,TC005,TC007
# filter="role:Admin,Manager"     â†’ TC001,TC003,TC004,TC005,TC007
# filter="environment=QA"         â†’ TC001,TC002,TC005
# filter="browser!=chrome"        â†’ TC003,TC006,TC007
# filter="enabled=true&amp;priority<=2&amp;tags~smoke" â†’ TC001,TC002,TC003,TC005,TC007</code></pre>

                <div class="info-box warning">
                    <strong>Filter Limitations &amp; Notes</strong>
                    <ul>
                        <li><strong>No parentheses:</strong> Complex grouping like <code>(A OR B) AND C</code> is not supported. Use simpler expressions or apply multiple filters.</li>
                        <li><strong>AND takes precedence:</strong> When mixing <code>&amp;</code> and <code>|</code>, OR is evaluated first (top-level split), then AND conditions.</li>
                        <li><strong>Case sensitivity:</strong> Column names are case-sensitive. Values in <code>=</code>, <code>!=</code>, <code>~</code> comparisons are case-insensitive.</li>
                        <li><strong>Whitespace:</strong> Trim whitespace from filter expressions. <code>field = value</code> may not work; use <code>field=value</code>.</li>
                        <li><strong>Special characters:</strong> Avoid using <code>&amp;</code>, <code>|</code>, <code>=</code>, <code>:</code>, <code>~</code> in filter values.</li>
                    </ul>
                </div>

                <h3>Smart Data Iteration Control</h3>
                <p>The framework auto-detects whether a test uses the <code>data</code> fixture and only iterates when needed.</p>

                <pre><code>describe('Smart Data Iteration Control', {
    tags: ['@smart-data'],
    dataSource: {
        type: 'inline',
        data: [
            { module: 'Admin', expectedHeader: 'Admin' },
            { module: 'PIM', expectedHeader: 'PIM' },
            { module: 'Leave', expectedHeader: 'Leave' }
        ]
    }
}, () => {

    // AUTO-DETECT: Uses 'data' parameter - runs 3 times (once per data row)
    test('Navigate to {module} module using data', async ({ dashboardPage, reporter, data }) => {
        await dashboardPage.clickMenuItem(data.module);
        await dashboardPage.verifyPageHeader(data.expectedHeader);
        reporter.pass(`Navigated to ${data.module} using data iteration`);
    });

    // AUTO-DETECT: No 'data' parameter - runs only ONCE
    test('Verify login page elements exist', async ({ loginPage, reporter }) => {
        // Framework auto-detects that 'data' is not in parameters
        // Runs once despite describe having data
        const isOnLogin = await loginPage.isAt();
        reporter.pass('Login page elements verified - ran once');
    });

    // EXPLICIT OPT-OUT: useData: false - runs ONCE even with 'data' parameter
    test('Verify dashboard loads after login', {
        useData: false  // Explicit opt-out
    }, async ({ loginPage, dashboardPage, reporter, data }) => {
        // Even though 'data' is in parameters, useData: false means run once
        // Note: 'data' will be an empty object {} when run without iteration
        await loginPage.login('Admin', 'admin123');
        await loginPage.verifyLoginSuccess();
        reporter.pass('Dashboard verified - ran once due to useData: false');
    });

    // EXPLICIT OPT-IN: useData: true - forces iteration
    test('Force data iteration with useData true', {
        useData: true  // Explicit opt-in
    }, async ({ loginPage, reporter, data: testData }) => {
        // Using renamed destructuring: { data: testData }
        // Even if auto-detect might miss it, useData: true ensures iteration
        reporter.pass(`Tested with module: ${testData.module}`);
    });
});</code></pre>

                <h3>Test-Level Data Source Override</h3>
                <p>Tests can have their own dataSource that overrides the describe-level data.</p>

                <pre><code>describe('Test-Level Data Source Override', {
    tags: ['@test-level-data'],
    dataSource: {
        type: 'inline',
        data: [
            { user: 'Admin', role: 'Administrator' },
            { user: 'User1', role: 'ESS' }
        ]
    }
}, () => {

    // Uses describe-level data (2 iterations: Admin, User1)
    test('Login with describe-level user data', async ({ loginPage, reporter, data }) => {
        await loginPage.login(data.user, 'admin123');
        reporter.pass(`Tested login with ${data.user} (${data.role})`);
    });

    // Has OWN dataSource - ignores describe-level (3 iterations: Recruitment, Time, Directory)
    test('Navigate to module with test-level data', {
        dataSource: {
            type: 'inline',
            data: [
                { module: 'Recruitment', header: 'Recruitment' },
                { module: 'Time', header: 'Time' },
                { module: 'Directory', header: 'Directory' }
            ]
        }
    }, async ({ dashboardPage, reporter, data }) => {
        await dashboardPage.clickMenuItem(data.module);
        await dashboardPage.verifyPageHeader(data.header);
        reporter.pass(`Navigated to ${data.module} using test-level data`);
    });

    // Setup/teardown test - runs once
    test('Verify application is accessible', {
        useData: false
    }, async ({ loginPage, reporter }) => {
        const isOnLogin = await loginPage.isAt();
        reporter.pass('Application health check passed - ran once');
    });
});</code></pre>

                <h3>Mixed Data Usage in Serial Mode</h3>
                <pre><code>describe.serial('Serial Mode with Mixed Data Usage', {
    tags: ['@serial-mixed-data'],
    dataSource: {
        type: 'inline',
        data: [
            { step: 'setup', action: 'Initialize' },
            { step: 'test', action: 'Execute' },
            { step: 'cleanup', action: 'Teardown' }
        ]
    }
}, () => {

    // Setup step - runs once (auto-detect: no data usage)
    test('Setup: Initialize test environment', async ({ loginPage, reporter, config }) => {
        // No 'data' parameter - runs once automatically
        const password = config.get('APP_PASSWORD', 'admin123');
        await loginPage.login('Admin', password);
        await loginPage.verifyLoginSuccess();
        reporter.pass('Setup completed - ran once (auto-detect)');
    });

    // Main test - iterates with data (uses data fixture)
    test('Execute step: {step} - {action}', async ({ dashboardPage, reporter, data }) => {
        // Uses 'data' parameter - iterates 3 times
        reporter.info(`Executing: ${data.step} - ${data.action}`);
        await dashboardPage.verifyPageHeader('Dashboard');
        reporter.pass(`Completed iteration: ${data.step}`);
    });

    // Cleanup step - runs once (explicit opt-out)
    test('Cleanup: Reset test environment', {
        useData: false
    }, async ({ dashboardPage, reporter }) => {
        // Explicit useData: false - runs once
        await dashboardPage.clickLogoutOption();
        reporter.pass('Cleanup completed - ran once (useData: false)');
    });
});</code></pre>

                <div class="tip">
                    <strong>ðŸ’¡ Best Practices:</strong>
                    <ul>
                        <li>Use <code>useData: false</code> for setup/teardown tests in data-driven describes</li>
                        <li>Use <code>{variable}</code> in test titles for clear iteration naming</li>
                        <li>Access <code>iteration.isLast</code> for cleanup logic on last iteration</li>
                        <li>Test-level <code>dataSource</code> completely overrides describe-level data</li>
                        <li>Filter data at source level to reduce test execution time</li>
                    </ul>
                </div>
            </section>

            <!-- TEST DEPENDENCIES -->
            <section id="test-dependencies">
                <h2>Test Dependencies</h2>

                <h3>Using dependsOn Option</h3>
                <pre><code>describe('Workflow with dependencies', {
    mode: 'serial'  // Required for dependencies
}, () => {
    test('Setup: Create user', {
        tags: ['@setup']
    }, async ({ ctx }) => {
        ctx.set('userId', 'user-123');
    });

    test('Verify: User exists', {
        tags: ['@verify'],
        dependsOn: '@setup'  // Skipped if setup fails
    }, async ({ ctx }) => {
        const userId = ctx.get('userId');
        // verify user...
    });

    test('Update: Modify user', {
        dependsOn: ['@setup', '@verify']  // Multiple dependencies
    }, async ({ ctx }) => {
        // update user...
    });
});</code></pre>

                <h3>Workflow Pattern</h3>
                <pre><code>describe.workflow('Approval Process', {
    tags: ['@workflow']
}, () => {
    // Step 1 - No dependencies (first step)
    test('Step 1: Create request', async ({ ctx }) => {
        ctx.set('requestId', 'REQ-001');
    });

    // Step 2 - Auto-depends on Step 1
    test('Step 2: Submit for approval', async ({ ctx }) => {
        const requestId = ctx.get('requestId');
        // submit...
    });

    // Step 3 - Auto-depends on Step 2
    test('Step 3: Approve request', async ({ ctx }) => {
        // approve...
    });

    // Cleanup - Always runs even if previous steps fail
    test.cleanup('Cleanup: Reset state', async ({ ctx }) => {
        // cleanup...
    });
});</code></pre>
            </section>

            <!-- API TESTING -->
            <section id="api-testing">
                <h2>API Testing - CSAPIClient</h2>

                <p>CSAPIClient provides comprehensive HTTP client capabilities for REST API testing.</p>

                <h3>CSAPIClient Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td></tr>
                        <tr><td><code>get(url, options?)</code></td><td>HTTP GET request</td></tr>
                        <tr><td><code>post(url, body?, options?)</code></td><td>HTTP POST request</td></tr>
                        <tr><td><code>put(url, body?, options?)</code></td><td>HTTP PUT request</td></tr>
                        <tr><td><code>patch(url, body?, options?)</code></td><td>HTTP PATCH request</td></tr>
                        <tr><td><code>delete(url, options?)</code></td><td>HTTP DELETE request</td></tr>
                        <tr><td><code>head(url, options?)</code></td><td>HTTP HEAD request</td></tr>
                        <tr><td><code>options(url, options?)</code></td><td>HTTP OPTIONS request</td></tr>
                        <tr><td><code>setBaseUrl(url)</code></td><td>Set base URL for all requests</td></tr>
                        <tr><td><code>setAuth(config)</code></td><td>Set authentication (basic, bearer, oauth, apikey)</td></tr>
                        <tr><td><code>setDefaultHeaders(headers)</code></td><td>Set default headers for all requests</td></tr>
                        <tr><td><code>setTimeout(ms)</code></td><td>Set default request timeout</td></tr>
                        <tr><td><code>builder(url)</code></td><td>Create request builder for fluent API</td></tr>
                        <tr><td><code>createContext(name)</code></td><td>Create named API context</td></tr>
                        <tr><td><code>switchContext(name)</code></td><td>Switch to named context</td></tr>
                        <tr><td><code>uploadFile(url, file, fieldName, data?)</code></td><td>Upload file with multipart form</td></tr>
                        <tr><td><code>downloadFile(url, savePath)</code></td><td>Download file to path</td></tr>
                        <tr><td><code>testConnection(url)</code></td><td>Test API connectivity</td></tr>
                        <tr><td><code>healthCheck(url)</code></td><td>Perform health check</td></tr>
                    </tbody>
                </table>

                <h3>Basic Requests</h3>
                <pre><code>// Spec Format
import { CSAPIClient } from '@mdakhan.mak/cs-playwright-test-framework/api';

test('API operations', async ({ reporter }) => {
    const api = CSAPIClient.getInstance();
    api.setBaseUrl('https://api.example.com');
    api.setAuth({ type: 'bearer', credentials: { token: 'abc123' } });

    // GET request
    const users = await api.get('/users');
    reporter.info(`Found ${users.body.length} users`);

    // GET with query params
    const filtered = await api.get('/users', {
        params: { status: 'active', page: 1, limit: 10 }
    });

    // POST request
    const newUser = await api.post('/users', {
        name: 'John Doe',
        email: 'john@example.com'
    });
    reporter.pass(`Created user with ID: ${newUser.body.id}`);

    // PUT request
    await api.put('/users/123', { name: 'Updated Name' });

    // PATCH request
    await api.patch('/users/123', { status: 'inactive' });

    // DELETE request
    await api.delete('/users/123');
});

// BDD Format
@When('I create a new user via API')
async createUserAPI() {
    const api = CSAPIClient.getInstance();
    const response = await api.post('/users', {
        name: 'Test User',
        email: 'test@example.com'
    });
    this.ctx.set('createdUserId', response.body.id);
    CSReporter.pass(`User created: ${response.body.id}`);
}</code></pre>

                <!-- Authentication Types -->
                <h3 id="api-auth">Authentication Types</h3>
                <p>CSAPIClient supports 11 authentication types for comprehensive API testing:</p>

                <table>
                    <thead>
                        <tr><th>Type</th><th>Description</th><th>Credentials Required</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>basic</code></td><td>HTTP Basic Authentication</td><td><code>username</code>, <code>password</code></td></tr>
                        <tr><td><code>bearer</code></td><td>Bearer Token Authentication</td><td><code>token</code></td></tr>
                        <tr><td><code>apikey</code></td><td>API Key in header or query param</td><td><code>apiKey</code> + <code>headerName</code> or <code>parameterName</code></td></tr>
                        <tr><td><code>oauth2</code></td><td>OAuth 2.0 Authentication</td><td><code>clientId</code>, <code>clientSecret</code>, <code>tokenUrl</code>, etc.</td></tr>
                        <tr><td><code>digest</code></td><td>HTTP Digest Authentication</td><td><code>username</code>, <code>password</code></td></tr>
                        <tr><td><code>jwt</code></td><td>JSON Web Token</td><td><code>token</code> or generation params</td></tr>
                        <tr><td><code>aws</code></td><td>AWS Signature (v2 or v4)</td><td><code>accessKey</code>, <code>secretKey</code>, <code>region</code>, <code>service</code></td></tr>
                        <tr><td><code>ntlm</code></td><td>Windows NTLM Authentication</td><td><code>username</code>, <code>password</code>, <code>domain</code></td></tr>
                        <tr><td><code>hawk</code></td><td>Hawk Authentication</td><td><code>hawkId</code>, <code>hawkKey</code></td></tr>
                        <tr><td><code>certificate</code></td><td>Client Certificate (mTLS)</td><td><code>certificate</code>, <code>privateKey</code>, <code>passphrase</code></td></tr>
                        <tr><td><code>custom</code></td><td>Custom Authentication Function</td><td><code>customAuth</code> function</td></tr>
                    </tbody>
                </table>

                <h4>Authentication Examples</h4>
                <pre><code>// Basic Authentication
api.setAuth({
    type: 'basic',
    credentials: { username: 'admin', password: 'secret123' }
});

// Bearer Token
api.setAuth({
    type: 'bearer',
    credentials: { token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...' }
});

// API Key (in header)
api.setAuth({
    type: 'apikey',
    credentials: { apiKey: 'your-api-key-here' },
    options: { headerName: 'X-API-Key' }  // Or use parameterName for query param
});

// API Key (in query parameter)
api.setAuth({
    type: 'apikey',
    credentials: { apiKey: 'your-api-key-here' },
    options: { parameterName: 'api_key' }
});

// OAuth2 - Client Credentials
api.setAuth({
    type: 'oauth2',
    credentials: {
        clientId: 'your-client-id',
        clientSecret: 'your-client-secret'
    },
    options: {
        tokenUrl: 'https://auth.example.com/oauth/token',
        grantType: 'client_credentials',
        scope: 'read write'
    }
});

// OAuth2 - Password Grant
api.setAuth({
    type: 'oauth2',
    credentials: {
        clientId: 'your-client-id',
        clientSecret: 'your-client-secret',
        username: 'user@example.com',
        password: 'userpassword'
    },
    options: {
        tokenUrl: 'https://auth.example.com/oauth/token',
        grantType: 'password'
    }
});

// AWS Signature v4
api.setAuth({
    type: 'aws',
    credentials: {
        accessKey: 'AKIAIOSFODNN7EXAMPLE',
        secretKey: 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',
        sessionToken: 'optional-session-token'  // For temporary credentials
    },
    options: {
        region: 'us-east-1',
        service: 's3',
        signatureVersion: 'v4'
    }
});

// NTLM (Windows Authentication)
api.setAuth({
    type: 'ntlm',
    credentials: {
        username: 'domain\\user',
        password: 'password',
        domain: 'CORP',
        workstation: 'WORKSTATION'
    }
});

// Client Certificate (mTLS)
api.setAuth({
    type: 'certificate',
    credentials: {
        certificate: fs.readFileSync('/path/to/cert.pem'),
        privateKey: fs.readFileSync('/path/to/key.pem'),
        passphrase: 'optional-passphrase'
    },
    options: {
        certificateType: 'pem',  // 'pem', 'der', 'pfx', 'p12'
        validateCertificate: true
    }
});

// Custom Authentication
api.setAuth({
    type: 'custom',
    credentials: {
        customAuth: async (request) => {
            // Generate custom signature or token
            const signature = await generateSignature(request);
            request.headers = {
                ...request.headers,
                'X-Custom-Signature': signature
            };
            return request;
        }
    }
});
</code></pre>

                <h4>OAuth 2.0 Grant Types</h4>
                <table>
                    <thead><tr><th>Grant Type</th><th>Use Case</th></tr></thead>
                    <tbody>
                        <tr><td><code>authorization_code</code></td><td>Web apps with user login (requires redirect)</td></tr>
                        <tr><td><code>client_credentials</code></td><td>Machine-to-machine authentication</td></tr>
                        <tr><td><code>password</code></td><td>Direct username/password (legacy)</td></tr>
                        <tr><td><code>refresh_token</code></td><td>Refresh expired access tokens</td></tr>
                        <tr><td><code>implicit</code></td><td>Public clients (deprecated)</td></tr>
                        <tr><td><code>device_code</code></td><td>IoT devices with limited input</td></tr>
                        <tr><td><code>urn:ietf:params:oauth:grant-type:jwt-bearer</code></td><td>JWT assertion</td></tr>
                        <tr><td><code>urn:ietf:params:oauth:grant-type:saml2-bearer</code></td><td>SAML assertion</td></tr>
                        <tr><td><code>urn:ietf:params:oauth:grant-type:token-exchange</code></td><td>Token exchange</td></tr>
                    </tbody>
                </table>

                <!-- Request Options -->
                <h3 id="api-options">Request Options</h3>
                <table>
                    <thead>
                        <tr><th>Option</th><th>Type</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>url</code></td><td>string</td><td>Request URL (required)</td></tr>
                        <tr><td><code>method</code></td><td>string</td><td>HTTP method: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, TRACE, CONNECT</td></tr>
                        <tr><td><code>headers</code></td><td>object</td><td>Request headers</td></tr>
                        <tr><td><code>body</code></td><td>any</td><td>Request body (JSON, FormData, string, Buffer)</td></tr>
                        <tr><td><code>query</code></td><td>object</td><td>Query parameters</td></tr>
                        <tr><td><code>params</code></td><td>object</td><td>URL path parameters</td></tr>
                        <tr><td><code>timeout</code></td><td>number</td><td>Request timeout in milliseconds</td></tr>
                        <tr><td><code>retries</code></td><td>number</td><td>Number of retry attempts</td></tr>
                        <tr><td><code>retryDelay</code></td><td>number</td><td>Delay between retries (ms)</td></tr>
                        <tr><td><code>retryStrategy</code></td><td>string</td><td>Retry strategy: <code>exponential</code>, <code>linear</code>, <code>fibonacci</code>, <code>constant</code>, <code>custom</code></td></tr>
                        <tr><td><code>auth</code></td><td>object</td><td>Authentication config (see above)</td></tr>
                        <tr><td><code>proxy</code></td><td>object</td><td>Proxy configuration</td></tr>
                        <tr><td><code>followRedirects</code></td><td>boolean</td><td>Follow HTTP redirects (default: true)</td></tr>
                        <tr><td><code>maxRedirects</code></td><td>number</td><td>Maximum redirects to follow</td></tr>
                        <tr><td><code>compress</code></td><td>boolean</td><td>Accept compressed responses</td></tr>
                        <tr><td><code>responseType</code></td><td>string</td><td><code>json</code>, <code>text</code>, <code>buffer</code>, <code>stream</code>, <code>arraybuffer</code>, <code>blob</code></td></tr>
                        <tr><td><code>validateStatus</code></td><td>function</td><td>Custom status validation function</td></tr>
                        <tr><td><code>keepAlive</code></td><td>boolean</td><td>Enable HTTP keep-alive</td></tr>
                        <tr><td><code>socketTimeout</code></td><td>number</td><td>Socket timeout (ms)</td></tr>
                        <tr><td><code>onUploadProgress</code></td><td>function</td><td>Upload progress callback</td></tr>
                        <tr><td><code>onDownloadProgress</code></td><td>function</td><td>Download progress callback</td></tr>
                    </tbody>
                </table>

                <h4>Proxy Configuration</h4>
                <pre><code>api.setProxy({
    host: 'proxy.example.com',
    port: 8080,
    protocol: 'http',  // 'http', 'https', 'socks', 'socks4', 'socks5'
    auth: {
        username: 'proxyuser',
        password: 'proxypass'
    }
});</code></pre>

                <h4>SSL/TLS Certificate Options</h4>
                <pre><code>const response = await api.get('/secure-endpoint', {
    rejectUnauthorized: true,  // Validate server certificate
    cert: fs.readFileSync('/path/to/client-cert.pem'),
    key: fs.readFileSync('/path/to/client-key.pem'),
    ca: fs.readFileSync('/path/to/ca-cert.pem'),
    passphrase: 'cert-passphrase'
});</code></pre>

                <h3>Request Builder Pattern</h3>
                <pre><code>const response = await api.builder('/users')
    .post()
    .setJsonBody({ name: 'John' })
    .setHeader('X-Custom', 'value')
    .setBasicAuth('user', 'password')
    .setTimeout(30000)
    .setRetries(3)
    .execute();</code></pre>

                <h3>Response Validation</h3>
                <pre><code>import { CSAPIValidator } from '@mdakhan.mak/cs-playwright-test-framework/api';

const validator = new CSAPIValidator();

const result = await validator.validate(response, [
    { type: 'status', config: { code: 200 } },
    { type: 'header', config: { name: 'Content-Type', value: 'application/json' } },
    { type: 'jsonpath', config: { path: '$.data.length', operator: 'gt', value: 0 } },
    { type: 'schema', config: { schema: userSchema } }
]);

if (!result.valid) {
    console.log('Validation errors:', result.errors);
}</code></pre>

                <h3>API Chains</h3>
                <pre><code>import { CSAPIRunner } from '@mdakhan.mak/cs-playwright-test-framework/api';

const runner = CSAPIRunner.getInstance();

const chain = runner.createChain('user-flow', [
    // Step 1: Login
    runner.createRequestStep('login', {
        method: 'POST',
        url: '/auth/login',
        body: { username: 'admin', password: 'admin123' }
    }),

    // Step 2: Extract token
    runner.createExtractionStep('extract-token', 'login', [
        { path: '$.token', variable: 'authToken' }
    ]),

    // Step 3: Get users with token
    runner.createRequestStep('get-users', {
        method: 'GET',
        url: '/users',
        headers: { 'Authorization': 'Bearer ${authToken}' }
    }),

    // Step 4: Validate response
    runner.createValidationStep('validate', 'get-users', [
        { type: 'status', config: { code: 200 } }
    ])
]);

const results = await runner.runChain(chain);</code></pre>

                <h3 id="file-upload-download">File Upload &amp; Download</h3>
                <p>Complete support for file transfers in API testing.</p>

                <h4>File Upload Methods</h4>
                <pre><code>// Simple file upload (multipart/form-data)
const response = await api.uploadFile(
    '/api/upload',           // URL
    '/path/to/file.pdf',     // File path
    'document',              // Form field name (default: 'file')
    { description: 'My document', category: 'reports' }  // Additional form fields
);

// Upload with progress tracking
const response = await api.request({
    url: '/api/upload',
    method: 'POST',
    body: formData,
    onUploadProgress: (progress) => {
        console.log(`Uploaded ${progress.loaded} of ${progress.total} bytes (${progress.percent}%)`);
    }
});

// Upload multiple files using request builder
const response = await api.builder('/api/upload')
    .post()
    .setMultipartFormData({
        file1: fs.createReadStream('/path/to/file1.pdf'),
        file2: fs.createReadStream('/path/to/file2.jpg'),
        metadata: JSON.stringify({ userId: 123 })
    })
    .execute();

// Upload with custom content type
const response = await api.post('/api/upload', fs.readFileSync('/path/to/file.json'), {
    headers: {
        'Content-Type': 'application/json',
        'Content-Disposition': 'attachment; filename="data.json"'
    }
});
</code></pre>

                <h4>File Download Methods</h4>
                <pre><code>// Download file to disk
await api.downloadFile(
    '/api/files/123',           // URL
    '/path/to/save/report.pdf'  // Destination path
);

// Download with progress tracking
const response = await api.get('/api/files/123', {
    responseType: 'stream',
    onDownloadProgress: (progress) => {
        console.log(`Downloaded ${progress.loaded} of ${progress.total} bytes (${progress.percent}%)`);
    }
});

// Download as buffer
const response = await api.get('/api/files/123', {
    responseType: 'buffer'
});
fs.writeFileSync('/path/to/save.pdf', response.body);

// Download with authentication
await api.downloadFile('/api/secure-files/123', '/path/to/save.pdf', {
    auth: {
        type: 'bearer',
        credentials: { token: 'your-token' }
    }
});

// Verify downloaded file
const downloadedFile = '/path/to/downloaded.pdf';
await api.downloadFile('/api/files/123', downloadedFile);
const stats = fs.statSync(downloadedFile);
reporter.info(`Downloaded file size: ${stats.size} bytes`);
</code></pre>

                <h4>Browser-Based File Upload</h4>
                <pre><code>// In Spec format - upload via browser file input
test('Upload file via browser', async ({ page, reporter }) => {
    // Method 1: Standard file input upload
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles('/path/to/document.pdf');
    reporter.pass('File selected for upload');

    // Method 2: Upload multiple files
    await fileInput.setInputFiles([
        '/path/to/file1.pdf',
        '/path/to/file2.jpg',
        '/path/to/file3.docx'
    ]);
    reporter.pass('Multiple files selected');

    // Method 3: Clear file selection
    await fileInput.setInputFiles([]);
    reporter.info('File selection cleared');

    // Method 4: Upload with hidden input (common in modern UIs)
    // Some file inputs are hidden - use force option
    await page.locator('input[type="file"]').setInputFiles('/path/to/file.pdf');

    // Method 5: Handle file chooser dialog (drag-drop or button click)
    const [fileChooser] = await Promise.all([
        page.waitForEvent('filechooser'),
        page.click('button.upload-btn')  // Button that triggers file dialog
    ]);
    await fileChooser.setFiles('/path/to/file.pdf');
    reporter.pass('File uploaded via file chooser dialog');

    // Method 6: Upload with specific MIME type
    await fileInput.setInputFiles({
        name: 'test-data.json',
        mimeType: 'application/json',
        buffer: Buffer.from(JSON.stringify({ key: 'value' }))
    });
    reporter.pass('File uploaded from buffer with MIME type');
});

// Upload in Page Object
@CSPage({ name: 'Upload Page' })
class UploadPage extends CSBasePage {
    @CSGetElement({ css: 'input[type="file"]' })
    private fileInput: CSWebElement;

    @CSGetElement({ css: '.upload-dropzone' })
    private dropzone: CSWebElement;

    async uploadFile(filePath: string): Promise&lt;void&gt; {
        await this.fileInput.uploadFile(filePath);
        CSReporter.pass(`Uploaded: ${filePath}`);
    }

    async uploadMultipleFiles(filePaths: string[]): Promise&lt;void&gt; {
        await this.fileInput.uploadFiles(filePaths);
        CSReporter.pass(`Uploaded ${filePaths.length} files`);
    }

    async uploadViaDropzone(filePath: string): Promise&lt;void&gt; {
        // For drag-drop zones that use file chooser
        const [fileChooser] = await Promise.all([
            this.page.waitForEvent('filechooser'),
            this.dropzone.click()
        ]);
        await fileChooser.setFiles(filePath);
        CSReporter.pass(`Uploaded via dropzone: ${filePath}`);
    }
}
</code></pre>

                <h4>Browser-Based File Download</h4>
                <pre><code>// In Spec format - download via browser
test('Download file via browser', async ({ page, reporter }) => {
    // Wait for download event and trigger download
    const [download] = await Promise.all([
        page.waitForEvent('download'),
        page.click('a.download-link')
    ]);

    // Get download info
    const suggestedFilename = download.suggestedFilename();
    reporter.info(`Downloading: ${suggestedFilename}`);

    // Save to custom location
    await download.saveAs(`./downloads/${suggestedFilename}`);

    // Verify download completed
    const path = await download.path();
    reporter.pass(`File downloaded to: ${path}`);
});
</code></pre>

                <div class="info-box tip">
                    <strong>File Upload/Download Notes:</strong>
                    <ul>
                        <li>Use <code>responseType: 'buffer'</code> for binary files to avoid encoding issues</li>
                        <li>For large files, use <code>responseType: 'stream'</code> to avoid memory issues</li>
                        <li>Progress callbacks work with both upload and download operations</li>
                        <li>Browser-based downloads are automatically saved with proper filenames when <code>DOWNLOAD_AUTO_SAVE=true</code></li>
                    </ul>
                </div>
            </section>

            <!-- API VALIDATORS -->
            <section id="api-validators">
                <h2>API Validators</h2>

                <p>The framework provides a comprehensive set of validators for API response validation. These validators can be used independently or combined for thorough response verification.</p>

                <h3>CSSchemaValidator</h3>
                <p>Validates API responses against JSON Schema specifications (draft-04 through 2020-12).</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>validate(response, config)</code></td><td>Validate response body against schema</td><td>CSValidationResult</td></tr>
                        <tr><td><code>cacheSchema(id, schema)</code></td><td>Cache schema for reuse</td><td>void</td></tr>
                        <tr><td><code>getCachedSchema(id)</code></td><td>Get cached schema</td><td>any</td></tr>
                        <tr><td><code>clearCache()</code></td><td>Clear schema cache</td><td>void</td></tr>
                    </tbody>
                </table>

                <h4>Schema Validation Options</h4>
                <table>
                    <thead><tr><th>Option</th><th>Type</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>schema</code></td><td>object</td><td>JSON Schema to validate against</td></tr>
                        <tr><td><code>version</code></td><td>string</td><td>Schema version (draft-04, draft-06, draft-07, 2019-09, 2020-12)</td></tr>
                        <tr><td><code>strict</code></td><td>boolean</td><td>Disallow additional properties</td></tr>
                        <tr><td><code>coerceTypes</code></td><td>boolean</td><td>Coerce types to match schema</td></tr>
                        <tr><td><code>validateFormats</code></td><td>boolean</td><td>Validate string formats (email, date, etc.)</td></tr>
                        <tr><td><code>custom</code></td><td>function</td><td>Custom validation function</td></tr>
                    </tbody>
                </table>

                <h3>CSJSONPathValidator</h3>
                <p>Validates specific paths in JSON responses using JSONPath expressions.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>validate(response, config)</code></td><td>Validate path in response</td><td>CSValidationResult</td></tr>
                        <tr><td><code>expectPath(path, value?)</code></td><td>Create exists/equals config</td><td>CSJSONPathValidationConfig</td></tr>
                        <tr><td><code>expectPathNotExists(path)</code></td><td>Create not-exists config</td><td>CSJSONPathValidationConfig</td></tr>
                        <tr><td><code>expectPathType(path, type)</code></td><td>Create type-check config</td><td>CSJSONPathValidationConfig</td></tr>
                        <tr><td><code>expectPathPattern(path, pattern)</code></td><td>Create pattern-match config</td><td>CSJSONPathValidationConfig</td></tr>
                        <tr><td><code>expectPathContains(path, value)</code></td><td>Create contains config</td><td>CSJSONPathValidationConfig</td></tr>
                        <tr><td><code>expectArrayLength(path, length)</code></td><td>Create array length config</td><td>CSJSONPathValidationConfig</td></tr>
                    </tbody>
                </table>

                <h4>Supported JSONPath Syntax</h4>
                <table>
                    <thead><tr><th>Expression</th><th>Description</th><th>Example</th></tr></thead>
                    <tbody>
                        <tr><td><code>$</code></td><td>Root element</td><td><code>$</code></td></tr>
                        <tr><td><code>$.property</code></td><td>Property access</td><td><code>$.user.name</code></td></tr>
                        <tr><td><code>$[index]</code></td><td>Array index</td><td><code>$.items[0]</code></td></tr>
                        <tr><td><code>$[*]</code></td><td>Wildcard - all elements</td><td><code>$.items[*].id</code></td></tr>
                        <tr><td><code>$..[property]</code></td><td>Recursive descent</td><td><code>$..name</code></td></tr>
                        <tr><td><code>$[start:end]</code></td><td>Array slice</td><td><code>$.items[0:5]</code></td></tr>
                        <tr><td><code>$[?(@.prop==value)]</code></td><td>Filter expression</td><td><code>$[?(@.status=="active")]</code></td></tr>
                    </tbody>
                </table>

                <h3>CSBodyValidator</h3>
                <p>Validates the entire response body for content, format, and size.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>validate(response, config)</code></td><td>Validate response body</td><td>CSValidationResult</td></tr>
                        <tr><td><code>expectEquals(value)</code></td><td>Create equals config</td><td>CSBodyValidationConfig</td></tr>
                        <tr><td><code>expectContains(value)</code></td><td>Create contains config</td><td>CSBodyValidationConfig</td></tr>
                        <tr><td><code>expectNotContains(value)</code></td><td>Create not-contains config</td><td>CSBodyValidationConfig</td></tr>
                        <tr><td><code>expectPattern(pattern)</code></td><td>Create pattern config</td><td>CSBodyValidationConfig</td></tr>
                        <tr><td><code>expectEmpty()</code></td><td>Create empty config</td><td>CSBodyValidationConfig</td></tr>
                        <tr><td><code>expectJson()</code></td><td>Create valid JSON config</td><td>CSBodyValidationConfig</td></tr>
                        <tr><td><code>expectXml()</code></td><td>Create valid XML config</td><td>CSBodyValidationConfig</td></tr>
                        <tr><td><code>expectLength(config)</code></td><td>Create length config</td><td>CSBodyValidationConfig</td></tr>
                        <tr><td><code>expectSize(config)</code></td><td>Create size config (bytes)</td><td>CSBodyValidationConfig</td></tr>
                    </tbody>
                </table>

                <h3>CSStatusCodeValidator</h3>
                <p>Validates HTTP status codes with category and range support.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>validate(response, config)</code></td><td>Validate status code</td><td>CSValidationResult</td></tr>
                        <tr><td><code>expectStatus(code)</code></td><td>Expect specific status</td><td>CSStatusValidationConfig</td></tr>
                        <tr><td><code>expectSuccess()</code></td><td>Expect 2xx status</td><td>CSStatusValidationConfig</td></tr>
                        <tr><td><code>expectRedirect()</code></td><td>Expect 3xx status</td><td>CSStatusValidationConfig</td></tr>
                        <tr><td><code>expectClientError()</code></td><td>Expect 4xx status</td><td>CSStatusValidationConfig</td></tr>
                        <tr><td><code>expectServerError()</code></td><td>Expect 5xx status</td><td>CSStatusValidationConfig</td></tr>
                        <tr><td><code>expectRange(min, max)</code></td><td>Expect status in range</td><td>CSStatusValidationConfig</td></tr>
                        <tr><td><code>expectNot(status)</code></td><td>Expect not specific status</td><td>CSStatusValidationConfig</td></tr>
                        <tr><td><code>isSuccess(status)</code></td><td>Check if 2xx</td><td>boolean</td></tr>
                        <tr><td><code>isError(status)</code></td><td>Check if 4xx or 5xx</td><td>boolean</td></tr>
                    </tbody>
                </table>

                <h3>CSHeaderValidator</h3>
                <p>Validates response headers including CORS, security, and caching headers.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>validate(response, config)</code></td><td>Validate headers</td><td>CSValidationResult</td></tr>
                    </tbody>
                </table>

                <h4>Header Validation Options</h4>
                <table>
                    <thead><tr><th>Option</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>name</code></td><td>Header name to validate</td></tr>
                        <tr><td><code>value</code></td><td>Expected value (string or RegExp)</td></tr>
                        <tr><td><code>exists</code></td><td>Header must exist</td></tr>
                        <tr><td><code>notExists</code></td><td>Header must not exist</td></tr>
                        <tr><td><code>cors</code></td><td>CORS headers validation config</td></tr>
                        <tr><td><code>security</code></td><td>Security headers validation config</td></tr>
                        <tr><td><code>caching</code></td><td>Caching headers validation config</td></tr>
                    </tbody>
                </table>

                <h4>Security Headers Config</h4>
                <pre><code>security: {
    contentSecurityPolicy: true,      // Expect CSP header
    strictTransportSecurity: { maxAge: 31536000, includeSubDomains: true },
    xContentTypeOptions: true,         // Expect X-Content-Type-Options: nosniff
    xFrameOptions: 'DENY',             // DENY or SAMEORIGIN
    xXssProtection: true,              // X-XSS-Protection header
    referrerPolicy: 'strict-origin-when-cross-origin'
}</code></pre>

                <h3>CSResponseTimeValidator</h3>
                <p>Validates response time performance thresholds.</p>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>validate(response, config)</code></td><td>Validate response time</td><td>CSValidationResult</td></tr>
                    </tbody>
                </table>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';
import {
    CSSchemaValidator,
    CSJSONPathValidator,
    CSBodyValidator,
    CSStatusCodeValidator,
    CSHeaderValidator
} from '@mdakhan.mak/cs-playwright-test-framework/api';

describe('API Validation Tests', { tags: '@api @validation' }, () => {

    test('Validate response against JSON Schema', async ({ apiClient, reporter }) => {
        const response = await apiClient.get('/api/users/123');

        const schemaValidator = new CSSchemaValidator();
        const result = schemaValidator.validate(response, {
            schema: {
                type: 'object',
                required: ['id', 'name', 'email'],
                properties: {
                    id: { type: 'integer' },
                    name: { type: 'string', minLength: 1 },
                    email: { type: 'string', format: 'email' },
                    role: { type: 'string', enum: ['admin', 'user', 'guest'] },
                    createdAt: { type: 'string', format: 'date-time' }
                },
                additionalProperties: false
            },
            strict: true,
            validateFormats: true
        });

        if (!result.valid) {
            result.errors?.forEach(err => reporter.warn(`Schema error: ${err.message}`));
        }
        expect(result.valid).toBe(true);
    });

    test('Validate specific JSON paths', async ({ apiClient, reporter }) => {
        const response = await apiClient.get('/api/users');

        const pathValidator = new CSJSONPathValidator();

        // Validate multiple paths
        const result = pathValidator.validate(response, {
            multiple: [
                { path: '$.data', type: 'array' },
                { path: '$.data[0].id', type: 'number' },
                { path: '$.data[*].email', pattern: /@.*\.com$/ },
                { path: '$.pagination.total', type: 'number', custom: (val) => val > 0 || 'Total must be positive' },
                { path: '$.data', length: { min: 1, max: 100 } }
            ]
        });

        expect(result.valid).toBe(true);
        reporter.pass(`Validated ${result.metadata?.pathsValidated} JSON paths`);
    });

    test('Validate response body content', async ({ apiClient, reporter }) => {
        const response = await apiClient.get('/api/health');

        const bodyValidator = new CSBodyValidator();
        const result = bodyValidator.validate(response, {
            isJson: true,
            contains: 'healthy',
            notContains: ['error', 'failure'],
            size: { max: 10240 }  // Max 10KB
        });

        expect(result.valid).toBe(true);
        reporter.info(`Body size: ${result.metadata?.bodySize} bytes`);
    });

    test('Validate status code categories', async ({ apiClient, reporter }) => {
        const statusValidator = new CSStatusCodeValidator();

        // Test successful response
        const response = await apiClient.get('/api/users');
        const result = statusValidator.validate(response, {
            category: 'success',
            not: [204]  // Expect content
        });
        expect(result.valid).toBe(true);

        // Test error handling
        const errorResponse = await apiClient.get('/api/nonexistent');
        const errorResult = statusValidator.validate(errorResponse, {
            expected: [404],
            category: 'client_error'
        });
        expect(errorResult.valid).toBe(true);
    });

    test('Validate security headers', async ({ apiClient, reporter }) => {
        const response = await apiClient.get('/api/secure-endpoint');

        const headerValidator = new CSHeaderValidator();
        const result = headerValidator.validate(response, {
            security: {
                contentSecurityPolicy: true,
                strictTransportSecurity: { maxAge: 31536000, includeSubDomains: true },
                xContentTypeOptions: true,
                xFrameOptions: 'DENY',
                xXssProtection: true
            }
        });

        if (!result.valid) {
            result.errors?.forEach(err => reporter.warn(`Missing security header: ${err.message}`));
        }
    });

    test('Validate CORS headers', async ({ apiClient, reporter }) => {
        const response = await apiClient.options('/api/users', {
            headers: { 'Origin': 'https://example.com' }
        });

        const headerValidator = new CSHeaderValidator();
        const result = headerValidator.validate(response, {
            cors: {
                allowOrigin: ['https://example.com', 'https://app.example.com'],
                allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
                allowHeaders: ['Content-Type', 'Authorization'],
                allowCredentials: true,
                maxAge: 86400
            }
        });

        expect(result.valid).toBe(true);
    });

    test('Validate caching headers', async ({ apiClient, reporter }) => {
        const response = await apiClient.get('/api/static/config');

        const headerValidator = new CSHeaderValidator();
        const result = headerValidator.validate(response, {
            caching: {
                cacheControl: { maxAge: 3600, public: true },
                etag: true,
                vary: ['Accept', 'Accept-Encoding']
            }
        });

        expect(result.valid).toBe(true);
    });

    test('Custom validation with transform', async ({ apiClient, reporter }) => {
        const response = await apiClient.get('/api/encrypted-data');

        const bodyValidator = new CSBodyValidator();
        const result = bodyValidator.validate(response, {
            transform: (body) => {
                // Decrypt or transform body before validation
                return JSON.parse(Buffer.from(body.data, 'base64').toString());
            },
            isJson: true,
            custom: (body) => {
                if (!body.timestamp) return 'Missing timestamp';
                if (Date.now() - new Date(body.timestamp).getTime() > 3600000) {
                    return 'Data is stale (older than 1 hour)';
                }
                return true;
            }
        });

        expect(result.valid).toBe(true);
    });

    test('Combine multiple validators', async ({ apiClient, reporter }) => {
        const response = await apiClient.post('/api/orders', {
            customerId: 123,
            items: [{ productId: 'P001', quantity: 2 }]
        });

        const statusValidator = new CSStatusCodeValidator();
        const schemaValidator = new CSSchemaValidator();
        const pathValidator = new CSJSONPathValidator();

        // All validations must pass
        const statusResult = statusValidator.validate(response, { expected: 201 });
        expect(statusResult.valid).toBe(true);

        const schemaResult = schemaValidator.validate(response, {
            schema: {
                type: 'object',
                required: ['orderId', 'status', 'createdAt'],
                properties: {
                    orderId: { type: 'string', pattern: '^ORD-\\d+$' },
                    status: { type: 'string', enum: ['pending', 'confirmed'] },
                    createdAt: { type: 'string', format: 'date-time' }
                }
            }
        });
        expect(schemaResult.valid).toBe(true);

        const pathResult = pathValidator.validate(response, {
            path: '$.orderId',
            pattern: /^ORD-\d{6,}$/
        });
        expect(pathResult.valid).toBe(true);

        reporter.pass('All validations passed');
    });
});</code></pre>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: api-validation.feature
@api @validation
Feature: API Response Validation

  @schema
  Scenario: Validate user response against schema
    Given I have the user schema "schemas/user.json"
    When I send a GET request to "/api/users/123"
    Then the response should match the user schema
    And the response should have property "id" of type "number"
    And the response should have property "email" matching pattern "@.*\\.com$"

  @security
  Scenario: Validate security headers on API responses
    When I send a GET request to "/api/secure/data"
    Then the response should have header "Content-Security-Policy"
    And the response should have header "X-Content-Type-Options" with value "nosniff"
    And the response should have header "Strict-Transport-Security"

  @performance
  Scenario: Validate response time thresholds
    When I send a GET request to "/api/users"
    Then the response time should be less than 500 milliseconds
    And the response size should be less than 100 kilobytes

// Step definitions: api-validation.steps.ts
import { Given, When, Then, StepClass } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import {
    CSSchemaValidator,
    CSJSONPathValidator,
    CSHeaderValidator,
    CSStatusCodeValidator
} from '@mdakhan.mak/cs-playwright-test-framework/api';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

@StepClass()
export class APIValidationSteps {
    private schemaValidator = new CSSchemaValidator();
    private pathValidator = new CSJSONPathValidator();
    private headerValidator = new CSHeaderValidator();
    private lastResponse: any;
    private currentSchema: any;

    @Given('I have the user schema {string}')
    async loadSchema(schemaPath: string) {
        const fs = require('fs').promises;
        const schemaContent = await fs.readFile(schemaPath, 'utf-8');
        this.currentSchema = JSON.parse(schemaContent);
        CSReporter.info(`Loaded schema from ${schemaPath}`);
    }

    @Then('the response should match the user schema')
    validateAgainstSchema() {
        const result = this.schemaValidator.validate(this.lastResponse, {
            schema: this.currentSchema,
            strict: true
        });

        if (!result.valid) {
            result.errors?.forEach(err =>
                CSReporter.warn(`Schema validation error: ${err.message}`)
            );
        }

        expect(result.valid).toBe(true);
        CSReporter.pass('Response matches schema');
    }

    @Then('the response should have property {string} of type {string}')
    validatePropertyType(path: string, expectedType: string) {
        const result = this.pathValidator.validate(this.lastResponse, {
            path: `$.${path}`,
            type: expectedType
        });

        expect(result.valid).toBe(true);
        CSReporter.pass(`Property "${path}" is of type "${expectedType}"`);
    }

    @Then('the response should have property {string} matching pattern {string}')
    validatePropertyPattern(path: string, pattern: string) {
        const result = this.pathValidator.validate(this.lastResponse, {
            path: `$.${path}`,
            pattern: new RegExp(pattern)
        });

        expect(result.valid).toBe(true);
        CSReporter.pass(`Property "${path}" matches pattern "${pattern}"`);
    }

    @Then('the response should have header {string}')
    validateHeaderExists(headerName: string) {
        const result = this.headerValidator.validate(this.lastResponse, {
            name: headerName,
            exists: true
        });

        expect(result.valid).toBe(true);
        CSReporter.pass(`Header "${headerName}" exists`);
    }

    @Then('the response should have header {string} with value {string}')
    validateHeaderValue(headerName: string, expectedValue: string) {
        const result = this.headerValidator.validate(this.lastResponse, {
            name: headerName,
            value: expectedValue
        });

        expect(result.valid).toBe(true);
        CSReporter.pass(`Header "${headerName}" = "${expectedValue}"`);
    }

    @Then('the response time should be less than {int} milliseconds')
    validateResponseTime(maxMs: number) {
        const duration = this.lastResponse.duration || 0;
        expect(duration).toBeLessThan(maxMs);
        CSReporter.pass(`Response time ${duration}ms < ${maxMs}ms`);
    }
}</code></pre>

                <div class="tip">
                    <strong>ðŸ’¡ Tip:</strong> Cache frequently used schemas using <code>schemaValidator.cacheSchema(id, schema)</code> to improve validation performance across tests. Use the <code>multiple</code> option in JSONPath validation to check multiple paths in a single call.
                </div>
            </section>

            <!-- DATABASE TESTING -->
            <section id="database-testing">
                <h2>Database Testing - CSDatabase</h2>

                <p>CSDatabase provides unified database access for multiple database types with lazy adapter loading, transaction support, stored procedures, bulk operations, and result export capabilities.</p>

                <h3>CSDatabase Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance(alias?)</code></td><td>Get database instance by alias</td><td>Promise&lt;CSDatabase&gt;</td></tr>
                        <tr><td><code>create(config, alias)</code></td><td>Create new database connection</td><td>Promise&lt;CSDatabase&gt;</td></tr>
                        <tr><td><code>connectWithConnectionString(connStr, alias)</code></td><td>Connect using connection string</td><td>Promise&lt;CSDatabase&gt;</td></tr>
                        <tr><td><code>connect()</code></td><td>Establish database connection</td><td>Promise&lt;DatabaseConnection&gt;</td></tr>
                        <tr><td><code>disconnect()</code></td><td>Close database connection</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>disconnectAll()</code></td><td>Close all database connections</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>query(sql, params?, options?)</code></td><td>Execute SQL query with parameters</td><td>Promise&lt;ResultSet&gt;</td></tr>
                        <tr><td><code>execute(sql, params?)</code></td><td>Execute SQL statement</td><td>Promise&lt;ResultSet&gt;</td></tr>
                        <tr><td><code>executeWithPlan(sql, params?)</code></td><td>Execute with query execution plan</td><td>Promise&lt;ResultSet&gt;</td></tr>
                        <tr><td><code>queryByName(name, params?)</code></td><td>Execute predefined query from config</td><td>Promise&lt;ResultSet&gt;</td></tr>
                        <tr><td><code>queryFromFile(filePath, params?)</code></td><td>Execute SQL from file</td><td>Promise&lt;ResultSet&gt;</td></tr>
                        <tr><td><code>executeStoredProcedure(name, params?)</code></td><td>Call stored procedure</td><td>Promise&lt;ResultSet&gt;</td></tr>
                        <tr><td><code>executeFunction(name, params?)</code></td><td>Call database function</td><td>Promise&lt;any&gt;</td></tr>
                        <tr><td><code>executeBatch(operations)</code></td><td>Execute batch operations in transaction</td><td>Promise&lt;ResultSet[]&gt;</td></tr>
                        <tr><td><code>bulkInsert(table, data, options?)</code></td><td>Bulk insert records</td><td>Promise&lt;number&gt;</td></tr>
                        <tr><td><code>prepare(sql)</code></td><td>Create prepared statement</td><td>Promise&lt;PreparedStatement&gt;</td></tr>
                        <tr><td><code>beginTransaction(options?)</code></td><td>Start transaction with isolation level</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>commitTransaction()</code></td><td>Commit transaction</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>rollbackTransaction(savepoint?)</code></td><td>Rollback transaction or to savepoint</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>createSavepoint(name)</code></td><td>Create transaction savepoint</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>getMetadata()</code></td><td>Get database metadata</td><td>Promise&lt;DatabaseMetadata&gt;</td></tr>
                        <tr><td><code>getTableInfo(tableName)</code></td><td>Get table column information</td><td>Promise&lt;TableInfo&gt;</td></tr>
                        <tr><td><code>exportResult(result, format, path)</code></td><td>Export result to file (csv/json/xml/excel)</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>importData(table, path, format)</code></td><td>Import data from file into table</td><td>Promise&lt;number&gt;</td></tr>
                        <tr><td><code>isConnected()</code></td><td>Check connection status</td><td>boolean</td></tr>
                        <tr><td><code>getType()</code></td><td>Get database type</td><td>DatabaseType</td></tr>
                        <tr><td><code>getAlias()</code></td><td>Get connection alias</td><td>string</td></tr>
                        <tr><td><code>getPoolStats()</code></td><td>Get connection pool statistics</td><td>PoolStats</td></tr>
                    </tbody>
                </table>

                <h3>CSDatabaseManager Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton manager instance</td><td>CSDatabaseManager</td></tr>
                        <tr><td><code>createConnection(alias, config?)</code></td><td>Create named connection</td><td>Promise&lt;CSDatabase&gt;</td></tr>
                        <tr><td><code>getConnection(alias)</code></td><td>Get existing connection by alias</td><td>CSDatabase</td></tr>
                        <tr><td><code>closeConnection(alias)</code></td><td>Close specific connection</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>closeAllConnections()</code></td><td>Close all connections</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>beginTransaction(alias?)</code></td><td>Begin transaction on connection</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>rollbackTransaction(alias?)</code></td><td>Rollback transaction on connection</td><td>Promise&lt;void&gt;</td></tr>
                    </tbody>
                </table>

                <h3>Supported Databases</h3>
                <table>
                    <thead><tr><th>Database</th><th>Type Value</th><th>Default Port</th><th>Required Package</th></tr></thead>
                    <tbody>
                        <tr><td>SQL Server</td><td><code>sqlserver</code></td><td>1433</td><td>mssql (included)</td></tr>
                        <tr><td>MySQL</td><td><code>mysql</code></td><td>3306</td><td>mysql2 (optional)</td></tr>
                        <tr><td>PostgreSQL</td><td><code>postgresql</code></td><td>5432</td><td>pg (optional)</td></tr>
                        <tr><td>Oracle</td><td><code>oracle</code></td><td>1521</td><td>oracledb (optional)</td></tr>
                        <tr><td>MongoDB</td><td><code>mongodb</code></td><td>27017</td><td>mongodb (optional)</td></tr>
                        <tr><td>Redis</td><td><code>redis</code></td><td>6379</td><td>redis (optional)</td></tr>
                    </tbody>
                </table>

                <h3>Transaction Isolation Levels</h3>
                <table>
                    <thead><tr><th>Level</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>READ_UNCOMMITTED</code></td><td>Dirty reads possible, lowest isolation</td></tr>
                        <tr><td><code>READ_COMMITTED</code></td><td>Default - no dirty reads</td></tr>
                        <tr><td><code>REPEATABLE_READ</code></td><td>No phantom reads within transaction</td></tr>
                        <tr><td><code>SERIALIZABLE</code></td><td>Highest isolation, full locking</td></tr>
                        <tr><td><code>SNAPSHOT</code></td><td>SQL Server only - version-based isolation</td></tr>
                    </tbody>
                </table>

                <h3 id="database-config">Database Configuration</h3>
                <p>All database configuration uses the pattern <code>DB_{ALIAS}_{OPTION}</code> where <code>{ALIAS}</code> is your connection name (e.g., <code>CORPORATE</code>, <code>REPORTING</code>).</p>

                <h4>Common Configuration Options (All Databases)</h4>
                <table>
                    <thead><tr><th>Variable Pattern</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>DB_{ALIAS}_TYPE</code></td><td>string</td><td>sqlserver</td><td>Database type: <code>sqlserver</code>, <code>mysql</code>, <code>postgresql</code>, <code>oracle</code>, <code>mongodb</code>, <code>redis</code></td></tr>
                        <tr><td><code>DB_{ALIAS}_HOST</code></td><td>string</td><td>-</td><td>Database server hostname or IP (required)</td></tr>
                        <tr><td><code>DB_{ALIAS}_PORT</code></td><td>number</td><td>varies</td><td>Database port (see defaults per DB type)</td></tr>
                        <tr><td><code>DB_{ALIAS}_DATABASE</code></td><td>string</td><td>-</td><td>Database name (required)</td></tr>
                        <tr><td><code>DB_{ALIAS}_USERNAME</code></td><td>string</td><td>-</td><td>Database username (required unless using Windows auth)</td></tr>
                        <tr><td><code>DB_{ALIAS}_PASSWORD</code></td><td>string</td><td>-</td><td>Database password (required unless using Windows auth)</td></tr>
                        <tr><td><code>DB_{ALIAS}_CONNECTION_TIMEOUT</code></td><td>number</td><td>60000</td><td>Connection timeout in milliseconds</td></tr>
                        <tr><td><code>DB_{ALIAS}_REQUEST_TIMEOUT</code></td><td>number</td><td>15000</td><td>Query/request timeout in milliseconds</td></tr>
                    </tbody>
                </table>

                <h4>Connection Pool Configuration</h4>
                <table>
                    <thead><tr><th>Variable Pattern</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>DB_{ALIAS}_POOL_MIN</code></td><td>number</td><td>0</td><td>Minimum pool connections</td></tr>
                        <tr><td><code>DB_{ALIAS}_POOL_MAX</code></td><td>number</td><td>10</td><td>Maximum pool connections</td></tr>
                        <tr><td><code>DB_{ALIAS}_POOL_IDLE_TIMEOUT</code></td><td>number</td><td>30000</td><td>Idle connection timeout (ms)</td></tr>
                        <tr><td><code>DB_{ALIAS}_POOL_ACQUIRE_TIMEOUT</code></td><td>number</td><td>30000</td><td>Timeout to acquire connection from pool (ms)</td></tr>
                        <tr><td><code>DB_{ALIAS}_POOL_VALIDATE_ON_BORROW</code></td><td>boolean</td><td>false</td><td>Validate connection before use</td></tr>
                        <tr><td><code>DB_{ALIAS}_POOL_TEST_ON_BORROW</code></td><td>boolean</td><td>false</td><td>Test connection before use</td></tr>
                    </tbody>
                </table>

                <h4>SQL Server-Specific Options</h4>
                <table>
                    <thead><tr><th>Variable Pattern</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>DB_{ALIAS}_TRUSTED_CONNECTION</code></td><td>boolean</td><td>false</td><td>Windows Integrated Authentication (no username/password needed)</td></tr>
                        <tr><td><code>DB_{ALIAS}_ENCRYPT</code></td><td>boolean</td><td>false</td><td>Encrypt connection to SQL Server</td></tr>
                        <tr><td><code>DB_{ALIAS}_TRUST_SERVER_CERTIFICATE</code></td><td>boolean</td><td>false</td><td>Trust self-signed certificates</td></tr>
                    </tbody>
                </table>

                <div class="info-box note">
                    <strong>SQL Server Windows Authentication Modes:</strong>
                    <ul>
                        <li><strong>Trusted Connection (Kerberos):</strong> Set <code>DB_{ALIAS}_TRUSTED_CONNECTION=true</code> without username/password - uses current Windows user</li>
                        <li><strong>NTLM Authentication:</strong> Set <code>DB_{ALIAS}_TRUSTED_CONNECTION=true</code> WITH username/password - uses NTLM with specified domain credentials</li>
                        <li><strong>SQL Authentication:</strong> Set <code>DB_{ALIAS}_TRUSTED_CONNECTION=false</code> (or omit) - uses SQL username/password</li>
                    </ul>
                </div>

                <h4>SSL/TLS Configuration (All Databases)</h4>
                <table>
                    <thead><tr><th>Variable Pattern</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>DB_{ALIAS}_SSL</code></td><td>boolean</td><td>false</td><td>Enable SSL/TLS encryption</td></tr>
                        <tr><td><code>DB_{ALIAS}_SSL_CA</code></td><td>string</td><td>-</td><td>Path to CA certificate file</td></tr>
                        <tr><td><code>DB_{ALIAS}_SSL_CERT</code></td><td>string</td><td>-</td><td>Path to client certificate file</td></tr>
                        <tr><td><code>DB_{ALIAS}_SSL_KEY</code></td><td>string</td><td>-</td><td>Path to client private key file</td></tr>
                        <tr><td><code>DB_{ALIAS}_SSL_REJECT_UNAUTHORIZED</code></td><td>boolean</td><td>true</td><td>Reject unauthorized certificates</td></tr>
                    </tbody>
                </table>

                <h4>Database-Specific Examples</h4>
                <pre><code># ===========================================
# SQL Server Configuration
# ===========================================
DB_CORPORATE_TYPE=sqlserver
DB_CORPORATE_HOST=sqlserver.example.com
DB_CORPORATE_PORT=1433
DB_CORPORATE_DATABASE=ProductionDB

# Option 1: SQL Authentication
DB_CORPORATE_USERNAME=sa
DB_CORPORATE_PASSWORD=StrongPassword123!
DB_CORPORATE_TRUSTED_CONNECTION=false

# Option 2: Windows Authentication (current user)
DB_CORPORATE_TRUSTED_CONNECTION=true
# No username/password needed

# Option 3: NTLM Authentication (specific domain user)
DB_CORPORATE_TRUSTED_CONNECTION=true
DB_CORPORATE_USERNAME=DOMAIN\\serviceaccount
DB_CORPORATE_PASSWORD=ServicePassword123!

# SSL/Security
DB_CORPORATE_ENCRYPT=true
DB_CORPORATE_TRUST_SERVER_CERTIFICATE=false

# ===========================================
# MySQL Configuration
# ===========================================
DB_MYSQL_TYPE=mysql
DB_MYSQL_HOST=mysql.example.com
DB_MYSQL_PORT=3306
DB_MYSQL_DATABASE=app_database
DB_MYSQL_USERNAME=app_user
DB_MYSQL_PASSWORD=SecurePassword!

# SSL for MySQL
DB_MYSQL_SSL=true
DB_MYSQL_SSL_CA=/path/to/ca-cert.pem

# ===========================================
# PostgreSQL Configuration
# ===========================================
DB_POSTGRES_TYPE=postgresql
DB_POSTGRES_HOST=postgres.example.com
DB_POSTGRES_PORT=5432
DB_POSTGRES_DATABASE=analytics
DB_POSTGRES_USERNAME=analytics_user
DB_POSTGRES_PASSWORD=PostgresPassword!

# SSL for PostgreSQL
DB_POSTGRES_SSL=true
DB_POSTGRES_SSL_REJECT_UNAUTHORIZED=true

# ===========================================
# Oracle Configuration
# ===========================================
DB_ORACLE_TYPE=oracle
DB_ORACLE_HOST=oracle.example.com
DB_ORACLE_PORT=1521
DB_ORACLE_DATABASE=ORCL  # SID or Service Name
DB_ORACLE_USERNAME=system
DB_ORACLE_PASSWORD=OraclePassword!

# ===========================================
# MongoDB Configuration
# ===========================================
DB_MONGO_TYPE=mongodb
DB_MONGO_HOST=mongo.example.com
DB_MONGO_PORT=27017
DB_MONGO_DATABASE=app_data
DB_MONGO_USERNAME=mongo_user
DB_MONGO_PASSWORD=MongoPassword!

# ===========================================
# Redis Configuration
# ===========================================
DB_REDIS_TYPE=redis
DB_REDIS_HOST=redis.example.com
DB_REDIS_PORT=6379
DB_REDIS_PASSWORD=RedisPassword!
DB_REDIS_DATABASE=0  # Redis database index (0-15)

# ===========================================
# Connection Pool (recommended for production)
# ===========================================
DB_CORPORATE_POOL_MIN=2
DB_CORPORATE_POOL_MAX=20
DB_CORPORATE_POOL_IDLE_TIMEOUT=60000
DB_CORPORATE_CONNECTION_TIMEOUT=30000
DB_CORPORATE_REQUEST_TIMEOUT=60000

# ===========================================
# Predefined queries (accessed via queryByName)
# ===========================================
DATABASE_QUERY_GET_USER=SELECT * FROM Users WHERE Id = ?
DATABASE_QUERY_GET_ORDERS=SELECT * FROM Orders WHERE UserId = ?
DATABASE_QUERY_GET_ACTIVE_USERS=SELECT * FROM Users WHERE Status = 'active'</code></pre>

                <h4>Programmatic Configuration</h4>
                <pre><code>import { CSDatabase, CSDatabaseManager } from '@mdakhan.mak/cs-playwright-test-framework/database';

// Method 1: Create with full config object
const db = await CSDatabase.create({
    type: 'sqlserver',
    host: 'localhost',
    port: 1433,
    database: 'TestDB',
    username: 'sa',
    password: 'password',
    connectionTimeout: 30000,
    queryTimeout: 60000,
    poolMin: 0,
    poolMax: 10,
    additionalOptions: {
        encrypt: true,
        trustServerCertificate: true,
        trustedConnection: false
    }
}, 'mydb');

// Method 2: Create with connection string
const dbFromString = await CSDatabase.connectWithConnectionString(
    'Server=localhost;Database=TestDB;User Id=sa;Password=password;Encrypt=true',
    'mydb-string'
);

// Method 3: Use manager with environment variables
const manager = CSDatabaseManager.getInstance();
const dbFromEnv = await manager.createConnection('corporate');  // Uses DB_CORPORATE_* env vars</code></pre>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test, beforeAll, afterAll } from '@mdakhan.mak/cs-playwright-test-framework/spec';
import { CSDatabase, CSDatabaseManager } from '@mdakhan.mak/cs-playwright-test-framework/database';

describe('Database Testing Examples', { tags: '@database' }, () => {
    let db: CSDatabase;
    let dbManager: CSDatabaseManager;

    beforeAll(async () => {
        dbManager = CSDatabaseManager.getInstance();
        db = await dbManager.createConnection('corporate');
    });

    afterAll(async () => {
        await dbManager.closeAllConnections();
    });

    test('Query users from database', { tags: '@query' }, async ({ reporter }) => {
        const result = await db.query('SELECT * FROM Users WHERE Status = ?', ['active']);

        reporter.info(`Found ${result.rowCount} active users`);
        expect(result.rowCount).toBeGreaterThan(0);

        // Access rows
        for (const user of result.rows) {
            reporter.info(`User: ${user.name}, Email: ${user.email}`);
        }
    });

    test('Query with execution plan', { tags: '@performance' }, async ({ reporter }) => {
        const result = await db.executeWithPlan(
            'SELECT u.*, o.OrderCount FROM Users u ' +
            'LEFT JOIN (SELECT UserId, COUNT(*) as OrderCount FROM Orders GROUP BY UserId) o ' +
            'ON u.Id = o.UserId WHERE u.Status = ?',
            ['active']
        );

        reporter.info('Query execution plan:');
        reporter.info(result.metadata?.executionPlan || 'Plan not available');
    });

    test('Execute stored procedure', { tags: '@sproc' }, async ({ reporter }) => {
        const result = await db.executeStoredProcedure('sp_GetUserReport', [2024, 'Q1']);

        reporter.info(`Report returned ${result.rowCount} rows`);
        expect(result.rows.length).toBeGreaterThan(0);
    });

    test('Execute database function', { tags: '@function' }, async ({ reporter }) => {
        const result = await db.executeFunction('fn_CalculateDiscount', ['PREMIUM', 100.00]);
        reporter.info(`Discount: ${result}`);
        expect(result).toBeGreaterThan(0);
    });

    test('Transaction with savepoints', { tags: '@transaction' }, async ({ reporter }) => {
        await db.beginTransaction({ isolationLevel: 'READ_COMMITTED' });

        try {
            // Step 1: Insert order
            await db.execute('INSERT INTO Orders (UserId, Total) VALUES (?, ?)', [1, 100.00]);
            await db.createSavepoint('order_created');
            reporter.info('Order created, savepoint set');

            // Step 2: Try to update inventory (might fail)
            try {
                await db.execute('UPDATE Inventory SET Quantity = Quantity - 1 WHERE ProductId = ?', [99999]);
            } catch (error) {
                // Rollback to savepoint, keep order
                await db.rollbackTransaction('order_created');
                reporter.warn('Inventory update failed, rolled back to savepoint');
            }

            await db.commitTransaction();
            reporter.pass('Transaction committed successfully');
        } catch (error) {
            await db.rollbackTransaction();
            reporter.fail('Transaction rolled back');
            throw error;
        }
    });

    test('Bulk insert with batching', { tags: '@bulk' }, async ({ reporter }) => {
        const users = Array.from({ length: 1000 }, (_, i) => ({
            name: `User ${i}`,
            email: `user${i}@example.com`,
            status: 'pending'
        }));

        const inserted = await db.bulkInsert('Users', users, { batchSize: 100 });
        reporter.pass(`Bulk inserted ${inserted} users in batches of 100`);
    });

    test('Execute batch operations', { tags: '@batch' }, async ({ reporter }) => {
        const results = await db.executeBatch([
            { sql: 'UPDATE Accounts SET Balance = Balance - 100 WHERE Id = ?', params: [1] },
            { sql: 'UPDATE Accounts SET Balance = Balance + 100 WHERE Id = ?', params: [2] },
            { sql: 'INSERT INTO Transfers (FromId, ToId, Amount) VALUES (?, ?, ?)', params: [1, 2, 100] }
        ]);

        reporter.pass(`Executed ${results.length} operations in batch`);
    });

    test('Export query results', { tags: '@export' }, async ({ reporter }) => {
        const result = await db.query('SELECT * FROM Users LIMIT 100');

        // Export to different formats
        await db.exportResult(result, 'csv', './reports/users.csv');
        await db.exportResult(result, 'json', './reports/users.json');
        await db.exportResult(result, 'excel', './reports/users.xlsx');

        reporter.pass('Results exported to CSV, JSON, and Excel');
    });

    test('Import data from file', { tags: '@import' }, async ({ reporter }) => {
        const imported = await db.importData('Users', './test/data/new-users.csv', 'csv');
        reporter.pass(`Imported ${imported} records from CSV`);
    });

    test('Get database metadata', { tags: '@metadata' }, async ({ reporter }) => {
        const metadata = await db.getMetadata();
        reporter.info(`Database: ${metadata.database}`);
        reporter.info(`Version: ${metadata.version}`);

        const tableInfo = await db.getTableInfo('Users');
        reporter.info('Users table columns:');
        for (const col of tableInfo.columns) {
            reporter.info(`  ${col.name}: ${col.type} ${col.nullable ? 'NULL' : 'NOT NULL'}`);
        }
    });

    test('Query from file and predefined', { tags: '@files' }, async ({ reporter }) => {
        // Execute SQL from file
        const result1 = await db.queryFromFile('./sql/complex-report.sql', [2024]);
        reporter.info(`File query returned ${result1.rowCount} rows`);

        // Execute predefined query (from DATABASE_QUERY_GET_USER env var)
        const result2 = await db.queryByName('GET_USER', [123]);
        reporter.info(`Predefined query returned ${result2.rowCount} rows`);
    });

    test('Connection string usage', { tags: '@connection' }, async ({ reporter }) => {
        // Connect using connection string
        const db2 = await CSDatabase.connectWithConnectionString(
            'Server=localhost;Database=TestDB;User Id=sa;Password=password;Encrypt=true',
            'alternate'
        );

        const result = await db2.query('SELECT @@VERSION as Version');
        reporter.info(`Connected to: ${result.rows[0].Version}`);

        await db2.disconnect();
    });

    test('Validate API response against database', { tags: '@validation' }, async ({ apiClient, reporter }) => {
        // Fetch from API
        const apiResponse = await apiClient.get('/api/users/123');
        const apiUser = apiResponse.body;

        // Query database
        const dbResult = await db.query('SELECT * FROM Users WHERE Id = ?', [123]);
        const dbUser = dbResult.rows[0];

        // Compare fields
        expect(apiUser.name).toBe(dbUser.name);
        expect(apiUser.email).toBe(dbUser.email);
        reporter.pass('API response matches database record');
    });
});

describe('Multiple Database Connections', { tags: '@multi-db' }, () => {

    test('Work with multiple databases', async ({ reporter }) => {
        const manager = CSDatabaseManager.getInstance();

        // Create connections to different databases
        const sqlServer = await manager.createConnection('sqlserver', {
            type: 'sqlserver',
            host: 'sql-server.local',
            database: 'MainDB'
        });

        const mysql = await manager.createConnection('mysql', {
            type: 'mysql',
            host: 'mysql.local',
            database: 'ReportDB'
        });

        // Query from SQL Server
        const users = await sqlServer.query('SELECT * FROM Users');
        reporter.info(`SQL Server: ${users.rowCount} users`);

        // Query from MySQL
        const reports = await mysql.query('SELECT * FROM DailyReports');
        reporter.info(`MySQL: ${reports.rowCount} reports`);

        await manager.closeAllConnections();
    });
});</code></pre>

                <h3>BDD Step Definitions Reference</h3>
                <table>
                    <thead><tr><th>Step</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td colspan="2"><strong>Connection Steps</strong></td></tr>
                        <tr><td><code>user connects to {string} database</code></td><td>Connect to named database</td></tr>
                        <tr><td><code>user connects with connection string {string}</code></td><td>Connect using connection string</td></tr>
                        <tr><td><code>user connects to database with options:</code></td><td>Connect with data table options</td></tr>
                        <tr><td><code>user switches to database {string}</code></td><td>Switch active database connection</td></tr>
                        <tr><td><code>user disconnects from database</code></td><td>Close current connection</td></tr>
                        <tr><td><code>user disconnects from all databases</code></td><td>Close all connections</td></tr>
                        <tr><td><code>user verifies database connection</code></td><td>Verify connection is active</td></tr>
                        <tr><td><code>user sets database timeout to {int} seconds</code></td><td>Set query timeout</td></tr>

                        <tr><td colspan="2"><strong>Query Execution Steps</strong></td></tr>
                        <tr><td><code>user executes query {string}</code></td><td>Execute SQL query</td></tr>
                        <tr><td><code>user executes query {string} and stores result as {string}</code></td><td>Execute and store result</td></tr>
                        <tr><td><code>user executes parameterized query {string} with parameters:</code></td><td>Execute with data table params</td></tr>
                        <tr><td><code>user executes query from file {string}</code></td><td>Execute SQL from file</td></tr>
                        <tr><td><code>user executes predefined query {string}</code></td><td>Execute configured query</td></tr>
                        <tr><td><code>user executes batch queries:</code></td><td>Execute multiple queries</td></tr>
                        <tr><td><code>user executes scalar query {string}</code></td><td>Execute and return single value</td></tr>
                        <tr><td><code>user executes count query {string}</code></td><td>Execute COUNT query</td></tr>
                        <tr><td><code>user executes query {string} with timeout {int} seconds</code></td><td>Execute with timeout</td></tr>

                        <tr><td colspan="2"><strong>Stored Procedure Steps</strong></td></tr>
                        <tr><td><code>user executes stored procedure {string}</code></td><td>Call procedure without params</td></tr>
                        <tr><td><code>user executes stored procedure {string} with parameters:</code></td><td>Call with data table params</td></tr>
                        <tr><td><code>user calls function {string} and stores result as {string}</code></td><td>Call function</td></tr>
                        <tr><td><code>the output parameter {string} should be {string}</code></td><td>Validate output param</td></tr>
                        <tr><td><code>the return value should be {string}</code></td><td>Validate return value</td></tr>

                        <tr><td colspan="2"><strong>Transaction Steps</strong></td></tr>
                        <tr><td><code>user begins database transaction</code></td><td>Start transaction</td></tr>
                        <tr><td><code>user begins database transaction with isolation level {string}</code></td><td>Start with isolation</td></tr>
                        <tr><td><code>user commits database transaction</code></td><td>Commit transaction</td></tr>
                        <tr><td><code>user rolls back database transaction</code></td><td>Rollback transaction</td></tr>
                        <tr><td><code>user creates savepoint {string}</code></td><td>Create savepoint</td></tr>
                        <tr><td><code>user rolls back to savepoint {string}</code></td><td>Rollback to savepoint</td></tr>
                        <tr><td><code>user releases savepoint {string}</code></td><td>Release savepoint</td></tr>
                        <tr><td><code>database should have active transaction</code></td><td>Verify transaction active</td></tr>

                        <tr><td colspan="2"><strong>Validation Steps</strong></td></tr>
                        <tr><td><code>the query result should have {int} rows</code></td><td>Exact row count</td></tr>
                        <tr><td><code>the query result should have at least {int} rows</code></td><td>Minimum row count</td></tr>
                        <tr><td><code>the query result should be empty</code></td><td>Zero rows</td></tr>
                        <tr><td><code>the value in row {int} column {string} should be {string}</code></td><td>Exact value match</td></tr>
                        <tr><td><code>the value in row {int} column {string} should contain {string}</code></td><td>Contains check</td></tr>
                        <tr><td><code>the value in row {int} column {string} should match pattern {string}</code></td><td>Regex match</td></tr>
                        <tr><td><code>the value in row {int} column {string} should be null</code></td><td>NULL check</td></tr>
                        <tr><td><code>all values in column {string} should be unique</code></td><td>Uniqueness check</td></tr>
                        <tr><td><code>the sum of column {string} should be {float}</code></td><td>Sum validation</td></tr>
                        <tr><td><code>the average of column {string} should be {float}</code></td><td>Average validation</td></tr>
                        <tr><td><code>column {string} should have data type {string}</code></td><td>Type check</td></tr>
                        <tr><td><code>the result should match:</code></td><td>Match data table</td></tr>

                        <tr><td colspan="2"><strong>API-Database Integration Steps</strong></td></tr>
                        <tr><td><code>I execute query {string} and store results as {string}</code></td><td>Store for API comparison</td></tr>
                        <tr><td><code>I validate response path {string} against query result {string}</code></td><td>Compare API to DB</td></tr>
                        <tr><td><code>I validate response path {string} against query result {string} with mapping:</code></td><td>Compare with field mapping</td></tr>
                        <tr><td><code>I use query result {string} row {int} as variables</code></td><td>Load DB row as variables</td></tr>
                        <tr><td><code>I check if data exists in table {string} where {string}</code></td><td>Existence check</td></tr>

                        <tr><td colspan="2"><strong>Utility Steps</strong></td></tr>
                        <tr><td><code>user exports query result to {string}</code></td><td>Export to file</td></tr>
                        <tr><td><code>user imports data from {string} into table {string}</code></td><td>Import from file</td></tr>
                        <tr><td><code>user truncates table {string}</code></td><td>Truncate table</td></tr>
                        <tr><td><code>user logs query execution plan</code></td><td>Log execution plan</td></tr>
                        <tr><td><code>user logs database statistics</code></td><td>Log DB stats</td></tr>
                    </tbody>
                </table>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: database-testing.feature
@database
Feature: Database Testing

  Background:
    Given user connects to "corporate" database

  @query
  Scenario: Query active users from database
    When user executes query "SELECT * FROM Users WHERE Status = 'active'"
    Then the query result should have at least 1 rows
    And the value in row 0 column "Status" should be "active"

  @stored-procedure
  Scenario: Execute stored procedure with parameters
    When user executes stored procedure "sp_GetUserOrders" with parameters:
      | userId | 12345 |
      | year   | 2024  |
    Then the query result should have at least 1 rows
    And user logs database query result

  @transaction
  Scenario: Transaction with savepoint rollback
    Given user begins database transaction with isolation level "READ_COMMITTED"
    When user executes query "INSERT INTO Orders (UserId, Total) VALUES (1, 100.00)"
    And user creates savepoint "after_insert"
    When user executes query "UPDATE Inventory SET Quantity = -1 WHERE ProductId = 1"
    Then user rolls back to savepoint "after_insert"
    And user commits database transaction

  @validation
  Scenario: Validate data integrity
    When user executes query "SELECT * FROM Orders WHERE UserId = 123"
    Then the query result should have at least 1 rows
    And all values in column "OrderId" should be unique
    And the value in row 0 column "Status" should not be null
    And the sum of column "Total" should be 500.00

  @data-driven @TC500
  Scenario Outline: Query users by role
    When user executes query "SELECT COUNT(*) as cnt FROM Users WHERE Role = '&lt;role&gt;'"
    Then the value in row 0 column "cnt" should be "&lt;expected_count&gt;"

    Examples:
      | role    | expected_count |
      | Admin   | 5              |
      | Manager | 10             |
      | User    | 100            |

  @api-validation
  Scenario: Validate API response matches database
    Given I execute query "SELECT * FROM Users WHERE Id = 123" and store results as "dbUser"
    When I send a GET request to "/api/users/123"
    Then I validate response path "data" against query result "dbUser" with mapping:
      | user_id    | id        |
      | first_name | firstName |
      | last_name  | lastName  |

  @export
  Scenario: Export query results
    When user executes query "SELECT * FROM MonthlyReport WHERE Year = 2024"
    Then user exports query result to "reports/monthly-2024.xlsx"

// Step definitions: database.steps.ts
import { Given, When, Then, StepClass, DataTable } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSDatabase, CSDatabaseManager } from '@mdakhan.mak/cs-playwright-test-framework/database';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

@StepClass()
export class DatabaseSteps {
    private dbManager: CSDatabaseManager;
    private db!: CSDatabase;
    private lastResult: any;

    constructor() {
        this.dbManager = CSDatabaseManager.getInstance();
    }

    @Given('user connects to {string} database')
    async connectToDatabase(alias: string) {
        this.db = await this.dbManager.createConnection(alias);
        CSReporter.info(`Connected to database: ${alias}`);
    }

    @When('user executes query {string}')
    async executeQuery(sql: string) {
        this.lastResult = await this.db.execute(sql);
        CSReporter.info(`Query executed: ${this.lastResult.rowCount} rows`);
    }

    @When('user executes stored procedure {string} with parameters:')
    async executeStoredProc(procedureName: string, table: DataTable) {
        const params = table.hashes()[0];
        const paramArray = Object.values(params);
        this.lastResult = await this.db.executeStoredProcedure(procedureName, paramArray);
        CSReporter.info(`Stored procedure executed: ${this.lastResult.rowCount} rows`);
    }

    @Then('the query result should have at least {int} rows')
    async verifyMinRows(minRows: number) {
        expect(this.lastResult.rowCount).toBeGreaterThanOrEqual(minRows);
        CSReporter.pass(`Query returned ${this.lastResult.rowCount} rows (min: ${minRows})`);
    }

    @Then('the value in row {int} column {string} should be {string}')
    async verifyColumnValue(rowIndex: number, column: string, expected: string) {
        const actual = String(this.lastResult.rows[rowIndex][column]);
        expect(actual).toBe(expected);
        CSReporter.pass(`Row ${rowIndex} column "${column}" = "${expected}"`);
    }

    @Then('all values in column {string} should be unique')
    async verifyUniqueValues(column: string) {
        const values = this.lastResult.rows.map((r: any) => r[column]);
        const unique = new Set(values);
        expect(unique.size).toBe(values.length);
        CSReporter.pass(`All ${values.length} values in "${column}" are unique`);
    }

    @When('user begins database transaction with isolation level {string}')
    async beginTransactionWithIsolation(isolation: string) {
        await this.db.beginTransaction({ isolationLevel: isolation });
        CSReporter.info(`Transaction started with isolation: ${isolation}`);
    }

    @When('user creates savepoint {string}')
    async createSavepoint(name: string) {
        await this.db.createSavepoint(name);
        CSReporter.info(`Savepoint created: ${name}`);
    }

    @When('user rolls back to savepoint {string}')
    async rollbackToSavepoint(name: string) {
        await this.db.rollbackTransaction(name);
        CSReporter.info(`Rolled back to savepoint: ${name}`);
    }

    @When('user commits database transaction')
    async commitTransaction() {
        await this.db.commitTransaction();
        CSReporter.pass('Transaction committed');
    }

    @Then('user exports query result to {string}')
    async exportResult(filePath: string) {
        const format = filePath.endsWith('.xlsx') ? 'excel' :
                       filePath.endsWith('.json') ? 'json' :
                       filePath.endsWith('.xml') ? 'xml' : 'csv';
        await this.db.exportResult(this.lastResult, format, filePath);
        CSReporter.pass(`Exported to ${filePath}`);
    }

    @Then('user logs database query result')
    async logResult() {
        CSReporter.info(`Query result: ${JSON.stringify(this.lastResult.rows, null, 2)}`);
    }
}</code></pre>

                <h3>Database Comparison Utility</h3>
                <pre><code>import { CSDatabaseComparisonUtility } from '@mdakhan.mak/cs-playwright-test-framework/database-utils';

// Compare query result with Excel file
const result = await db.query('SELECT * FROM Users');
const comparison = await CSDatabaseComparisonUtility.compareWithExcel(
    result.rows,
    'test/data/expected-users.xlsx'
);

if (!comparison.match) {
    console.log('Differences found:');
    for (const diff of comparison.differences) {
        console.log(`  Row ${diff.rowIndex}, Column ${diff.column}:`);
        console.log(`    Expected: ${diff.expected}`);
        console.log(`    Actual: ${diff.actual}`);
    }
}

// Compare with CSV
const csvComparison = await CSDatabaseComparisonUtility.compareWithCSV(
    result.rows,
    'test/data/expected-users.csv',
    { delimiter: ',', headers: true }
);

// Assert matches (throws on mismatch)
await CSDatabaseComparisonUtility.assertMatchesCSV(result.rows, 'expected.csv');
await CSDatabaseComparisonUtility.assertMatchesJSON(result.rows, 'expected.json');</code></pre>

                <h3 id="csdbutils">CSDBUtils - Static Database Utilities</h3>
                <p>CSDBUtils provides static utility methods for common database operations without needing to create a CSDatabase instance. Useful for quick queries, single-value lookups, and executing SQL from files.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>executeQuery(alias, sql, params?)</code></td><td>Execute query on named connection</td><td>Promise&lt;ResultSet&gt;</td></tr>
                        <tr><td><code>getSingleValue(alias, sql, params?)</code></td><td>Get single scalar value</td><td>Promise&lt;any&gt;</td></tr>
                        <tr><td><code>getSingleRow(alias, sql, params?)</code></td><td>Get single row as object</td><td>Promise&lt;any&gt;</td></tr>
                        <tr><td><code>executeFromFile(alias, filePath, params?)</code></td><td>Execute SQL from .sql file</td><td>Promise&lt;ResultSet&gt;</td></tr>
                        <tr><td><code>executeFromFileSingleValue(alias, filePath, params?)</code></td><td>Execute file, return single value</td><td>Promise&lt;any&gt;</td></tr>
                        <tr><td><code>executeFromFileSingleRow(alias, filePath, params?)</code></td><td>Execute file, return single row</td><td>Promise&lt;any&gt;</td></tr>
                        <tr><td><code>beginTransaction(alias)</code></td><td>Start transaction on connection</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>commitTransaction(alias)</code></td><td>Commit transaction</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>rollbackTransaction(alias)</code></td><td>Rollback transaction</td><td>Promise&lt;void&gt;</td></tr>
                    </tbody>
                </table>

                <h4>Basic Usage</h4>
                <pre><code>import { CSDBUtils } from '@mdakhan.mak/cs-playwright-test-framework/database-utils';

// Execute query and get all results
const users = await CSDBUtils.executeQuery('corporate', 'SELECT * FROM Users WHERE Status = ?', ['active']);
console.log(`Found ${users.rowCount} active users`);

// Get single scalar value
const count = await CSDBUtils.getSingleValue('corporate', 'SELECT COUNT(*) FROM Orders WHERE Year = ?', [2024]);
console.log(`Total orders: ${count}`);

// Get single row
const user = await CSDBUtils.getSingleRow('corporate', 'SELECT * FROM Users WHERE Id = ?', [123]);
console.log(`User: ${user.name}, Email: ${user.email}`);</code></pre>

                <h4>Execute SQL from File</h4>
                <p>Execute queries stored in external .sql files. Supports single statements, multi-statement files, and parameterized queries.</p>
                <pre><code>// Single statement SQL file (queries/get-active-users.sql):
// SELECT * FROM Users WHERE Status = ? AND Role = ?

const result = await CSDBUtils.executeFromFile('corporate', './queries/get-active-users.sql', ['active', 'Admin']);
console.log(`Found ${result.rowCount} active admins`);

// Without parameters
const allUsers = await CSDBUtils.executeFromFile('corporate', './queries/get-all-users.sql');

// Get single value from file
const count = await CSDBUtils.executeFromFileSingleValue('corporate', './queries/count-orders.sql', [2024]);

// Get single row from file
const config = await CSDBUtils.executeFromFileSingleRow('corporate', './queries/get-config.sql', ['MAX_RETRY']);</code></pre>

                <h4>Multi-Statement SQL Files</h4>
                <p>Execute files with multiple SQL statements (e.g., session settings followed by queries). Statements are executed sequentially.</p>
                <pre><code>// Multi-statement SQL file (queries/oracle-report.sql):
// ALTER SESSION SET TIME_ZONE='America/New_York';
// ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS';
// SELECT * FROM Reports WHERE Year = ?;

// All statements execute in order, parameters applied to SELECT
const report = await CSDBUtils.executeFromFile('oracle-db', './queries/oracle-report.sql', [2024]);
console.log(`Report returned ${report.rowCount} rows (with EST timezone)`);

// SQL Server example (queries/sales-summary.sql):
// SET NOCOUNT ON;
// SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
// SELECT Region, SUM(Amount) as Total FROM Sales WHERE Year = ? GROUP BY Region;

const sales = await CSDBUtils.executeFromFile('sqlserver-db', './queries/sales-summary.sql', [2024]);
for (const row of sales.rows) {
    console.log(`${row.Region}: $${row.Total}`);
}</code></pre>

                <h4>Transactions with CSDBUtils</h4>
                <pre><code>try {
    await CSDBUtils.beginTransaction('corporate');

    await CSDBUtils.executeQuery('corporate', 'UPDATE Accounts SET Balance = Balance - 100 WHERE Id = ?', [1]);
    await CSDBUtils.executeQuery('corporate', 'UPDATE Accounts SET Balance = Balance + 100 WHERE Id = ?', [2]);
    await CSDBUtils.executeQuery('corporate', 'INSERT INTO Transfers (FromId, ToId, Amount) VALUES (?, ?, ?)', [1, 2, 100]);

    await CSDBUtils.commitTransaction('corporate');
    console.log('Transfer completed');
} catch (error) {
    await CSDBUtils.rollbackTransaction('corporate');
    console.error('Transfer failed, rolled back');
}</code></pre>

                <div class="tip">
                    <strong>ðŸ’¡ Tip:</strong> Use environment-based database aliases (DB_CORPORATE_*, DB_REPORTING_*) to easily switch between development, staging, and production databases without code changes. Configure Windows Authentication (TRUSTED_CONNECTION=true) for enterprise environments.
                </div>
            </section>

            <!-- SOAP TESTING -->
            <section id="soap-testing">
                <h2>SOAP Testing - CSSoapClient</h2>

                <p>CSSoapClient provides comprehensive SOAP/WSDL web service testing with WS-Security support, XML validation, and response parsing.</p>

                <h3>CSSoapClient Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>constructor(wsdlUrl)</code></td><td>Create client with WSDL URL</td><td>CSSoapClient</td></tr>
                        <tr><td><code>call(operation, params, options?)</code></td><td>Call SOAP operation</td><td>Promise&lt;SoapResponse&gt;</td></tr>
                        <tr><td><code>callWithSecurity(operation, params, security)</code></td><td>Call with WS-Security headers</td><td>Promise&lt;SoapResponse&gt;</td></tr>
                        <tr><td><code>describe()</code></td><td>Get WSDL description/operations</td><td>WSDLDescription</td></tr>
                        <tr><td><code>getOperations()</code></td><td>List available operations</td><td>string[]</td></tr>
                        <tr><td><code>getOperationSchema(name)</code></td><td>Get operation input/output schema</td><td>OperationSchema</td></tr>
                        <tr><td><code>setEndpoint(url)</code></td><td>Override service endpoint</td><td>void</td></tr>
                        <tr><td><code>setHeaders(headers)</code></td><td>Set custom HTTP headers</td><td>void</td></tr>
                        <tr><td><code>setSoapHeaders(headers)</code></td><td>Set SOAP envelope headers</td><td>void</td></tr>
                        <tr><td><code>setTimeout(ms)</code></td><td>Set request timeout</td><td>void</td></tr>
                        <tr><td><code>getLastRequest()</code></td><td>Get last raw XML request</td><td>string</td></tr>
                        <tr><td><code>getLastResponse()</code></td><td>Get last raw XML response</td><td>string</td></tr>
                        <tr><td><code>validateResponse(schema)</code></td><td>Validate response against XSD</td><td>ValidationResult</td></tr>
                    </tbody>
                </table>

                <h3>WS-Security Options</h3>
                <table>
                    <thead><tr><th>Security Type</th><th>Description</th><th>Parameters</th></tr></thead>
                    <tbody>
                        <tr><td>UsernameToken</td><td>Username/password authentication</td><td>username, password, passwordType</td></tr>
                        <tr><td>BinarySecurityToken</td><td>Certificate-based authentication</td><td>certificate, privateKey</td></tr>
                        <tr><td>Timestamp</td><td>Add timestamp to prevent replay</td><td>ttl (seconds)</td></tr>
                        <tr><td>Signature</td><td>Sign SOAP body</td><td>privateKey, certificate</td></tr>
                        <tr><td>Encryption</td><td>Encrypt SOAP body</td><td>publicKey</td></tr>
                    </tbody>
                </table>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';
import { CSSoapClient } from '@mdakhan.mak/cs-playwright-test-framework/api';

describe('SOAP Web Service Tests', () => {

    test('Call basic SOAP operation', async ({ reporter }) => {
        const soap = new CSSoapClient('https://webservice.example.com/service?wsdl');

        // Get available operations
        const operations = soap.getOperations();
        reporter.info(`Available operations: ${operations.join(', ')}`);

        // Call operation
        const result = await soap.call('GetUser', {
            userId: '12345'
        });

        reporter.info(`User: ${result.name}, Email: ${result.email}`);
        expect(result.userId).toBe('12345');
    });

    test('SOAP with WS-Security UsernameToken', async ({ config, reporter }) => {
        const soap = new CSSoapClient(config.get('SOAP_WSDL_URL'));

        const result = await soap.callWithSecurity('CreateOrder', {
            customerId: 'C123',
            items: [
                { productId: 'P001', quantity: 2 },
                { productId: 'P002', quantity: 1 }
            ]
        }, {
            type: 'UsernameToken',
            username: config.get('SOAP_USERNAME'),
            password: config.get('SOAP_PASSWORD'),
            passwordType: 'PasswordDigest'  // or 'PasswordText'
        });

        reporter.info(`Order ID: ${result.orderId}`);
        expect(result.status).toBe('Created');
    });

    test('SOAP with certificate authentication', async ({ config }) => {
        const soap = new CSSoapClient(config.get('SECURE_WSDL_URL'));

        const result = await soap.callWithSecurity('GetSecureData', {
            query: 'sensitive-info'
        }, {
            type: 'BinarySecurityToken',
            certificate: fs.readFileSync('./certs/client.pem'),
            privateKey: fs.readFileSync('./certs/client-key.pem')
        });

        expect(result.data).toBeDefined();
    });

    test('Validate SOAP response against XSD schema', async ({ reporter }) => {
        const soap = new CSSoapClient('https://webservice.example.com/service?wsdl');

        const result = await soap.call('GetProduct', { productId: 'P001' });

        // Validate response structure
        const validation = await soap.validateResponse('./schemas/product-response.xsd');

        if (!validation.valid) {
            reporter.warn(`Validation errors: ${validation.errors.join(', ')}`);
        }

        expect(validation.valid).toBe(true);
    });

    test('Debug SOAP request/response', async ({ reporter }) => {
        const soap = new CSSoapClient('https://webservice.example.com/service?wsdl');
        soap.setTimeout(30000);

        try {
            await soap.call('GetUser', { userId: '999' });
        } catch (error) {
            // Log raw XML for debugging
            reporter.info('Request XML:');
            reporter.info(soap.getLastRequest());
            reporter.info('Response XML:');
            reporter.info(soap.getLastResponse());
            throw error;
        }
    });

    test('Call multiple SOAP operations in sequence', async ({ reporter }) => {
        const soap = new CSSoapClient('https://crm.example.com/service?wsdl');

        // Create customer
        const customer = await soap.call('CreateCustomer', {
            name: 'John Doe',
            email: 'john@example.com'
        });
        reporter.info(`Created customer: ${customer.customerId}`);

        // Create order for customer
        const order = await soap.call('CreateOrder', {
            customerId: customer.customerId,
            items: [{ productId: 'P001', quantity: 1 }]
        });
        reporter.info(`Created order: ${order.orderId}`);

        // Verify order
        const orderDetails = await soap.call('GetOrder', {
            orderId: order.orderId
        });

        expect(orderDetails.customerId).toBe(customer.customerId);
    });
});</code></pre>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: soap-testing.feature
@soap @webservice
Feature: SOAP Web Service Testing

  @create-user
  Scenario: Create user via SOAP web service
    Given I connect to the User Management WSDL
    When I call the "CreateUser" operation with:
      | firstName | lastName | email              |
      | John      | Doe      | john@example.com   |
    Then the response should contain a new user ID
    And the user status should be "Active"

  @ws-security
  Scenario: Call secured SOAP service
    Given I connect to the Secure Payment WSDL
    And I configure WS-Security with username token
    When I call the "ProcessPayment" operation
    Then the payment should be processed successfully

// Step definitions: soap.steps.ts
import { Given, When, Then, StepClass } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSSoapClient } from '@mdakhan.mak/cs-playwright-test-framework/api';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

@StepClass()
export class SoapSteps {
    private soapClient!: CSSoapClient;
    private lastResponse: any;

    @Given('I connect to the User Management WSDL')
    async connectToUserWsdl() {
        const wsdlUrl = this.config.get('USER_SERVICE_WSDL');
        this.soapClient = new CSSoapClient(wsdlUrl);
        CSReporter.info(`Connected to WSDL: ${wsdlUrl}`);
    }

    @Given('I connect to the Secure Payment WSDL')
    async connectToPaymentWsdl() {
        const wsdlUrl = this.config.get('PAYMENT_SERVICE_WSDL');
        this.soapClient = new CSSoapClient(wsdlUrl);
    }

    @Given('I configure WS-Security with username token')
    async configureWsSecurity() {
        this.ctx.set('security', {
            type: 'UsernameToken',
            username: this.config.get('SOAP_USERNAME'),
            password: this.config.get('SOAP_PASSWORD')
        });
    }

    @When('I call the {string} operation with:')
    async callOperationWithTable(operation: string, table: DataTable) {
        const params = table.hashes()[0];

        this.lastResponse = await this.soapClient.call(operation, params);
        CSReporter.info(`Called ${operation}, Response: ${JSON.stringify(this.lastResponse)}`);
    }

    @When('I call the {string} operation')
    async callOperation(operation: string) {
        const security = this.ctx.get('security');

        if (security) {
            this.lastResponse = await this.soapClient.callWithSecurity(
                operation,
                this.ctx.get('operationParams') || {},
                security
            );
        } else {
            this.lastResponse = await this.soapClient.call(operation, {});
        }
    }

    @Then('the response should contain a new user ID')
    async verifyUserId() {
        expect(this.lastResponse.userId).toBeDefined();
        expect(this.lastResponse.userId).not.toBe('');
        this.ctx.set('createdUserId', this.lastResponse.userId);
        CSReporter.pass(`User created with ID: ${this.lastResponse.userId}`);
    }

    @Then('the user status should be {string}')
    async verifyUserStatus(expectedStatus: string) {
        expect(this.lastResponse.status).toBe(expectedStatus);
        CSReporter.pass(`User status is ${expectedStatus}`);
    }

    @Then('the payment should be processed successfully')
    async verifyPayment() {
        expect(this.lastResponse.transactionId).toBeDefined();
        expect(this.lastResponse.status).toBe('Success');
        CSReporter.pass('Payment processed successfully');
    }
}</code></pre>
            </section>

            <!-- AI & SELF-HEALING -->
            <section id="ai-self-healing">
                <h2>AI & Self-Healing</h2>

                <p>The framework includes AI-powered self-healing capabilities that automatically recover from element location failures, analyze test failures, and use natural language to find elements.</p>

                <h3>CSSelfHealingManager Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSSelfHealingManager</td></tr>
                        <tr><td><code>enable()</code></td><td>Enable self-healing globally</td><td>void</td></tr>
                        <tr><td><code>disable()</code></td><td>Disable self-healing globally</td><td>void</td></tr>
                        <tr><td><code>healElement(element, error)</code></td><td>Attempt to heal failed element</td><td>HealingResult</td></tr>
                        <tr><td><code>addStrategy(strategy)</code></td><td>Add custom healing strategy</td><td>void</td></tr>
                        <tr><td><code>removeStrategy(name)</code></td><td>Remove healing strategy</td><td>void</td></tr>
                        <tr><td><code>setStrategyPriority(name, priority)</code></td><td>Set strategy execution priority</td><td>void</td></tr>
                        <tr><td><code>getHealingHistory()</code></td><td>Get all healing attempts</td><td>HealingEntry[]</td></tr>
                        <tr><td><code>getSuccessRate()</code></td><td>Get healing success rate</td><td>number (0-1)</td></tr>
                        <tr><td><code>exportHealingReport()</code></td><td>Export healing report</td><td>HealingReport</td></tr>
                    </tbody>
                </table>

                <h3>CSIntelligentAI Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSIntelligentAI</td></tr>
                        <tr><td><code>identifyElement(description, page)</code></td><td>Find element by natural language</td><td>AIElementResult</td></tr>
                        <tr><td><code>analyzeFailure(error, context)</code></td><td>Analyze test failure</td><td>FailureAnalysis</td></tr>
                        <tr><td><code>predictFailure(page, action)</code></td><td>Predict if action will fail</td><td>PredictionResult</td></tr>
                        <tr><td><code>suggestLocators(page, element)</code></td><td>Suggest robust locators</td><td>LocatorSuggestion[]</td></tr>
                        <tr><td><code>findSimilarElements(page, template)</code></td><td>Find visually similar elements</td><td>SimilarElement[]</td></tr>
                        <tr><td><code>generateSelector(page, description)</code></td><td>Generate selector from description</td><td>string</td></tr>
                        <tr><td><code>setConfidenceThreshold(threshold)</code></td><td>Set minimum confidence for matches</td><td>void</td></tr>
                    </tbody>
                </table>

                <h3>Healing Strategies</h3>
                <table>
                    <thead>
                        <tr><th>Strategy</th><th>Priority</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>Alternative Locators</td><td>10</td><td>Try text, ARIA, role, testId locators</td></tr>
                        <tr><td>Scroll Into View</td><td>9</td><td>Scroll element into viewport</td></tr>
                        <tr><td>Wait for Visible</td><td>8</td><td>Wait up to 10s for visibility</td></tr>
                        <tr><td>Remove Overlays</td><td>7</td><td>Close modals via ESC or click</td></tr>
                        <tr><td>Close Modal</td><td>7</td><td>Find and click close buttons</td></tr>
                        <tr><td>Pattern Matching</td><td>6</td><td>Find similar UI components</td></tr>
                        <tr><td>Visual Similarity</td><td>5</td><td>Match by visual properties</td></tr>
                        <tr><td>Force Click</td><td>1</td><td>Last resort - bypass checks</td></tr>
                    </tbody>
                </table>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';

describe('AI Self-Healing Tests', () => {

    test('Test with self-healing elements', async ({ loginPage, selfHealingManager }) => {
        // Enable self-healing globally (usually done in config)
        selfHealingManager.enable();

        await loginPage.navigate();

        // CSWebElement with selfHeal: true automatically uses healing
        // The element is defined in the page object with self-healing configuration
        try {
            await loginPage.submitButton.click();
        } catch (error) {
            // Self-healing automatically tries alternative strategies
            // You can also manually trigger healing for debugging
            const result = await selfHealingManager.healElement(loginPage.submitButton, error);

            if (result.success) {
                console.log(`Healed using: ${result.strategyUsed}`);
                console.log(`New locator: ${result.newLocator}`);
                await result.element.click();
            }
        }
    });

    test('Find element using natural language', async ({ loginPage, ai }) => {
        await loginPage.navigate();

        // AI can identify elements by natural language description
        const result = await ai.identifyElement(
            'the blue Login button at the bottom of the form',
            loginPage.page  // Access page from page object when needed
        );

        if (result && result.confidence > 0.8) {
            console.log(`Found with ${result.confidence * 100}% confidence`);
            console.log(`Suggested selector: ${result.suggestedSelector}`);
            await result.locator.click();
        }
    });

    test('Analyze and recover from failure', async ({ formPage, ai, reporter }) => {
        await formPage.navigate();

        try {
            // Using CSWebElement - healing happens automatically if enabled
            await formPage.nonExistentButton.click({ timeout: 5000 });
        } catch (error) {
            // Analyze the failure for debugging/reporting
            const analysis = await ai.analyzeFailure(error, {
                locator: formPage.nonExistentButton.getSelector(),
                stepName: 'Click submit button',
                page: formPage.page
            });

            reporter.info(`Failure type: ${analysis.failureType}`);
            reporter.info(`Root cause: ${analysis.rootCause}`);
            reporter.info(`Healable: ${analysis.healable}`);

            if (analysis.healable && analysis.suggestedStrategies.length > 0) {
                reporter.info(`Suggested fix: ${analysis.suggestedStrategies[0].description}`);

                // Create new element with healed locator
                const fixedElement = new CSWebElement({
                    css: analysis.suggestedStrategies[0].newLocator,
                    description: 'Healed submit button'
                });
                await fixedElement.click();
            }
        }
    });

    test('Predict failures before they happen', async ({ formPage, ai, reporter }) => {
        await formPage.navigate();

        // Predict if clicking will succeed using CSWebElement
        const prediction = await ai.predictFailure(formPage.page, {
            action: 'click',
            selector: formPage.submitButton.getSelector()
        });

        if (prediction.willFail) {
            reporter.info(`Predicted failure: ${prediction.reason}`);
            reporter.info(`Confidence: ${prediction.confidence}`);

            // Use suggested alternative if available
            if (prediction.alternative) {
                const altElement = new CSWebElement({ css: prediction.alternative.selector });
                await altElement.click();
            }
        } else {
            await formPage.submitButton.click();
        }
    });

    test('Get robust locator suggestions', async ({ formPage, ai, reporter }) => {
        await formPage.navigate();

        // Get suggestions for more robust locators for a fragile element
        const suggestions = await ai.suggestLocators(
            formPage.page,
            formPage.fragileElement.getLocator()
        );

        reporter.info('Locator suggestions:');
        for (const suggestion of suggestions) {
            reporter.info(`  ${suggestion.type}: ${suggestion.locator}`);
            reporter.info(`    Stability score: ${suggestion.stabilityScore}`);
            reporter.info(`    Reason: ${suggestion.reason}`);
        }

        // The best suggestion can be used to update the page object
        const bestLocator = suggestions[0].locator;
    });

    test('Get healing report', async ({ selfHealingManager, reporter }) => {
        const history = selfHealingManager.getHealingHistory();
        const successRate = selfHealingManager.getSuccessRate();

        reporter.info(`Total healing attempts: ${history.length}`);
        reporter.info(`Success rate: ${(successRate * 100).toFixed(1)}%`);

        // Export report for analysis
        const report = selfHealingManager.exportHealingReport();
        reporter.info(`Healed elements: ${JSON.stringify(report.healedElements)}`);
        reporter.info(`Most common failures: ${JSON.stringify(report.commonFailures)}`);
    });
});</code></pre>

                <h3>Page Object with Self-Healing</h3>
                <pre><code>import { CSBasePage, CSGetElement, CSWebElement } from '@mdakhan.mak/cs-playwright-test-framework';

export class LoginPage extends CSBasePage {
    // Element with self-healing enabled
    @CSGetElement({
        css: 'button.submit',
        selfHeal: true,              // Enable AI healing
        alternativeLocators: [       // Fallback locators (tried in order)
            'text:Submit',
            'role:button[name="Submit"]',
            '[data-testid="submit-btn"]',
            '#submit-button'
        ],
        healingStrategies: ['alternative-locators', 'scroll-into-view', 'wait-visible']
    })
    public submitButton!: CSWebElement;

    @CSGetElement({
        css: 'input#username',
        selfHeal: true,
        alternativeLocators: [
            '[name="username"]',
            '[placeholder="Username"]',
            'input[type="text"]:first-child'
        ]
    })
    public usernameInput!: CSWebElement;

    async login(username: string, password: string): Promise&lt;void&gt; {
        await this.usernameInput.fill(username);      // Self-healing on fill
        await this.passwordInput.fill(password);
        await this.submitButton.click();              // Self-healing on click
    }
}</code></pre>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: ai-healing.feature
@ai @self-healing
Feature: AI Self-Healing

  @healing
  Scenario: Test recovers from element changes
    Given self-healing is enabled
    And I navigate to the login page
    When the submit button locator changes
    Then the test should still click the submit button

  @natural-language
  Scenario: Find element using description
    Given I navigate to the homepage
    When I look for "the red Add to Cart button in the product card"
    Then I should find the element with high confidence

// Step definitions: ai.steps.ts
import { Given, When, Then, StepClass } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSSelfHealingManager } from '@mdakhan.mak/cs-playwright-test-framework/self-healing';
import { CSIntelligentAI } from '@mdakhan.mak/cs-playwright-test-framework/ai';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

@StepClass()
export class AISteps {
    private healingManager = CSSelfHealingManager.getInstance();
    private ai = CSIntelligentAI.getInstance();

    @Given('self-healing is enabled')
    async enableHealing() {
        this.healingManager.enable();
        CSReporter.info('Self-healing enabled');
    }

    @Given('I navigate to the login page')
    async navigateToLogin() {
        await this.page.goto(`${this.config.get('BASE_URL')}/login`);
    }

    @Given('I navigate to the homepage')
    async navigateHome() {
        await this.page.goto(this.config.get('BASE_URL'));
    }

    @When('the submit button locator changes')
    async simulateLocatorChange() {
        // In real scenarios, this represents when UI changes between builds
        CSReporter.info('Simulating locator change scenario');
    }

    @When('I look for {string}')
    async findByDescription(description: string) {
        const result = await this.ai.identifyElement(description, this.page);
        this.ctx.set('aiResult', result);

        if (result) {
            CSReporter.info(`Found element with ${result.confidence * 100}% confidence`);
        } else {
            CSReporter.warn('Element not found');
        }
    }

    @Then('the test should still click the submit button')
    async verifyHealedClick() {
        try {
            // Attempt click - self-healing will kick in if needed
            const button = this.page.locator('.submit, [data-testid="submit"]');
            await button.click({ timeout: 10000 });
            CSReporter.pass('Button clicked successfully (possibly healed)');
        } catch (error) {
            const analysis = await this.ai.analyzeFailure(error, {
                locator: '.submit',
                page: this.page
            });

            if (analysis.healable) {
                await this.page.click(analysis.suggestedStrategies[0].newLocator);
                CSReporter.pass('Click succeeded after healing');
            } else {
                throw error;
            }
        }
    }

    @Then('I should find the element with high confidence')
    async verifyHighConfidence() {
        const result = this.ctx.get('aiResult');
        expect(result).toBeDefined();
        expect(result.confidence).toBeGreaterThan(0.7);
        CSReporter.pass(`Element found with ${(result.confidence * 100).toFixed(0)}% confidence`);
    }
}</code></pre>

                <div class="info-box tip">
                    <strong>Self-Healing Best Practices</strong>
                    <ul>
                        <li>Always provide multiple alternative locators for critical elements</li>
                        <li>Use data-testid attributes as primary locators when possible</li>
                        <li>Review healing reports regularly to identify fragile selectors</li>
                        <li>Set appropriate confidence thresholds (0.7-0.9 recommended)</li>
                        <li>Log healing events for debugging and maintenance</li>
                    </ul>
                </div>
            </section>

            <!-- PARALLEL EXECUTION -->
            <section id="parallel-execution">
                <h2>Parallel Execution</h2>
                <p>The framework supports both sequential and parallel test execution modes for optimal performance and resource utilization.</p>

                <h3 id="parallel-config">Parallel Execution Configuration</h3>
                <table>
                    <thead>
                        <tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>PARALLEL</code></td><td>number|boolean</td><td>1</td><td>Enable parallel execution (number = worker count)</td></tr>
                        <tr><td><code>PARALLEL_WORKERS</code></td><td>number</td><td>4</td><td>Number of parallel workers when parallel is enabled</td></tr>
                        <tr><td><code>MAX_PARALLEL_WORKERS</code></td><td>number</td><td>4</td><td>Maximum workers limit (auto-scales based on CPU)</td></tr>
                        <tr><td><code>USE_WORKER_THREADS</code></td><td>boolean</td><td>true</td><td>Use worker threads (true) vs child processes (false)</td></tr>
                        <tr><td><code>REUSE_WORKERS</code></td><td>boolean</td><td>true</td><td>Reuse workers across test batches for efficiency</td></tr>
                        <tr><td><code>WORKER_HEAP_SIZE</code></td><td>number</td><td>1024</td><td>Worker heap memory size in MB</td></tr>
                        <tr><td><code>DEBUG_WORKERS</code></td><td>boolean</td><td>false</td><td>Enable verbose worker debugging output</td></tr>
                        <tr><td><code>WORKER_CONSOLE_CAPTURE</code></td><td>boolean</td><td>false</td><td>Capture console output from workers</td></tr>
                    </tbody>
                </table>

                <h3>Execution Modes</h3>
                <table>
                    <thead>
                        <tr><th>Mode</th><th>CLI Option</th><th>Description</th><th>Use Case</th></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Sequential</strong></td>
                            <td><code>--workers=1</code></td>
                            <td>Tests run one at a time in order</td>
                            <td>Tests with dependencies, debugging, limited resources</td>
                        </tr>
                        <tr>
                            <td><strong>Parallel</strong></td>
                            <td><code>--workers=4</code></td>
                            <td>Tests run concurrently across workers</td>
                            <td>Independent tests, CI/CD pipelines, faster execution</td>
                        </tr>
                        <tr>
                            <td><strong>Auto-Scale</strong></td>
                            <td><code>--parallel</code></td>
                            <td>Workers auto-scale based on CPU cores</td>
                            <td>Optimal performance without manual tuning</td>
                        </tr>
                    </tbody>
                </table>

                <h3>CLI Options</h3>
                <pre><code># Run sequentially (default)
npx cs-playwright-test --project=myproject --workers=1

# Run with specific number of workers
npx cs-playwright-test --project=myproject --workers=4

# Auto-scale based on CPU cores
npx cs-playwright-test --project=myproject --parallel

# Combination with tags for parallel smoke tests
npx cs-playwright-test --project=myproject --parallel --workers=4 --tags="@smoke"

# Sequential for database tests (shared state)
npx cs-playwright-test --project=myproject --workers=1 --tags="@database"</code></pre>

                <h3>Parallel vs Sequential Comparison</h3>
                <table>
                    <thead>
                        <tr><th>Aspect</th><th>Sequential (<code>--workers=1</code>)</th><th>Parallel (<code>--workers=N</code>)</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>Speed</td><td>Slower (tests run serially)</td><td>Faster (tests run concurrently)</td></tr>
                        <tr><td>Browser Instances</td><td>1 browser, reused across tests</td><td>N browsers (1 per worker)</td></tr>
                        <tr><td>Memory Usage</td><td>Lower (single process)</td><td>Higher (multiple processes)</td></tr>
                        <tr><td>Test Isolation</td><td>Sequential, can share state</td><td>Full isolation per worker</td></tr>
                        <tr><td>Debugging</td><td>Easier (single thread)</td><td>More complex (multiple threads)</td></tr>
                        <tr><td>CI/CD Suitability</td><td>Stable but slow</td><td>Fast, recommended for CI</td></tr>
                        <tr><td>Database Tests</td><td>Recommended (transaction safety)</td><td>Use with caution (isolation needed)</td></tr>
                        <tr><td>Test Dependencies</td><td>Supported</td><td>Not recommended</td></tr>
                    </tbody>
                </table>

                <h3>Spec Format: Controlling Execution Mode</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';

// Sequential execution (tests run in order)
describe('User Workflow', { mode: 'serial' }, () => {
    test('Step 1: Login', async () => { /* ... */ });
    test('Step 2: Create record', async () => { /* ... */ });  // Runs after Step 1
    test('Step 3: Verify record', async () => { /* ... */ });  // Runs after Step 2
});

// Parallel execution (tests run concurrently)
describe('Independent Tests', { mode: 'parallel' }, () => {
    test('Test A', async () => { /* ... */ });  // Runs in parallel
    test('Test B', async () => { /* ... */ });  // Runs in parallel
    test('Test C', async () => { /* ... */ });  // Runs in parallel
});

// Default mode (inherits from parent or global setting)
describe('Standard Tests', () => {
    test('Test 1', async () => { /* ... */ });
    test('Test 2', async () => { /* ... */ });
});

// describe.parallel() - shorthand for parallel mode
describe.parallel('Load Tests', () => {
    test('Concurrent request 1', async () => { /* ... */ });
    test('Concurrent request 2', async () => { /* ... */ });
});

// describe.workflow() - serial with cleanup
describe.workflow('Transaction Flow', () => {
    test('Begin transaction', async () => { /* ... */ });
    test('Execute operations', async () => { /* ... */ });
    test.cleanup('Rollback transaction', async () => { /* ... */ });  // Always runs
});</code></pre>

                <h3>Worker Resource Management</h3>
                <pre><code># Optimize for CI environments with limited resources
PARALLEL_WORKERS=2
WORKER_HEAP_SIZE=512
BROWSER_REUSE_ENABLED=true

# Optimize for powerful development machines
PARALLEL_WORKERS=8
WORKER_HEAP_SIZE=2048
USE_WORKER_THREADS=true

# Memory-constrained environment
PARALLEL_WORKERS=1
HEADLESS=true
BROWSER_VIDEO=off
TRACE_CAPTURE_MODE=never</code></pre>

                <h3>Sharding for CI/CD</h3>
                <p>Sharding distributes tests across multiple CI jobs for even faster execution.</p>

                <h4>Sharding Strategy</h4>
                <pre><code># CI Job 1 - First half of tests
npx cs-playwright-test --project=myproject --shard=1/2

# CI Job 2 - Second half of tests
npx cs-playwright-test --project=myproject --shard=2/2

# Split into 4 shards for 4 parallel CI jobs
npx cs-playwright-test --project=myproject --shard=1/4
npx cs-playwright-test --project=myproject --shard=2/4
npx cs-playwright-test --project=myproject --shard=3/4
npx cs-playwright-test --project=myproject --shard=4/4</code></pre>

                <h4>Azure DevOps Pipeline Example</h4>
                <pre><code>stages:
  - stage: Test
    jobs:
      - job: Shard1
        steps:
          - script: npx cs-playwright-test --shard=1/4
      - job: Shard2
        steps:
          - script: npx cs-playwright-test --shard=2/4
      - job: Shard3
        steps:
          - script: npx cs-playwright-test --shard=3/4
      - job: Shard4
        steps:
          - script: npx cs-playwright-test --shard=4/4</code></pre>

                <h4>GitHub Actions Example</h4>
                <pre><code>jobs:
  test:
    strategy:
      matrix:
        shard: [1, 2, 3, 4]
    steps:
      - name: Run tests
        run: npx cs-playwright-test --shard=${{ matrix.shard }}/4</code></pre>

                <h3>Parallel-Safe Best Practices</h3>
                <div class="info-box tip">
                    <strong>Best Practices for Parallel Tests</strong>
                    <ul>
                        <li><strong>Isolation:</strong> Each worker has its own browser instance and page context</li>
                        <li><strong>State:</strong> Don't share mutable state between tests - use test fixtures</li>
                        <li><strong>Data:</strong> Use unique test data per test (generated IDs, timestamps)</li>
                        <li><strong>Database:</strong> Use transactions and rollback to avoid data conflicts</li>
                        <li><strong>Page Objects:</strong> Automatically isolated per worker (singleton per thread)</li>
                        <li><strong>Dependencies:</strong> Avoid inter-test dependencies - use <code>mode: 'serial'</code> if needed</li>
                        <li><strong>Cleanup:</strong> Use <code>afterEach</code> hooks for proper cleanup</li>
                    </ul>
                </div>

                <h3>Worker-Specific Data</h3>
                <pre><code>// Access worker ID for unique data generation
test('Create unique record', async ({ config, reporter }) => {
    const workerId = process.env.WORKER_ID || '0';
    const uniqueEmail = `user_${workerId}_${Date.now()}@example.com`;

    reporter.info(`Worker ${workerId} creating user: ${uniqueEmail}`);
    // Create user with unique email...
});

// Use data provider with worker-safe filtering
describe('User Tests', {
    dataSource: {
        type: 'csv',
        path: 'test-data/users.csv',
        filter: 'workerId = ${WORKER_ID}'  // Filter data per worker
    }
}, () => {
    test('Process user {email}', async ({ data, reporter }) => {
        reporter.info(`Processing: ${data.email}`);
    });
});</code></pre>

                <div class="info-box warning">
                    <strong>Warning: Sequential Tests in Parallel Mode</strong>
                    <p>When using <code>describe({ mode: 'serial' })</code> within parallel execution:</p>
                    <ul>
                        <li>Tests within that describe block run sequentially</li>
                        <li>The entire describe block is assigned to a single worker</li>
                        <li>Other describe blocks may still run in parallel</li>
                        <li>Use <code>dependsOn</code> option for explicit test dependencies</li>
                    </ul>
                </div>
            </section>

            <!-- SUITE EXECUTION -->
            <section id="suite-execution">
                <h2>Multi-Project Suite Execution</h2>

                <p>Suite files (YAML format) allow you to orchestrate multiple projects in a single test run, similar to TestNG XML suites. Projects are executed sequentially with consolidated reporting.</p>

                <h3>Suite File Structure (test-suite.yaml)</h3>
                <pre><code># =============================================================================
# CS PLAYWRIGHT TEST FRAMEWORK - SUITE CONFIGURATION (YAML)
# =============================================================================
version: "1.0"
name: "My Multi-Project Test Suite"
description: "Comprehensive test suite for multiple projects"

# =============================================================================
# DEFAULT SETTINGS - Applied to all projects unless overridden
# =============================================================================
defaults:
  environment: dev                    # Environment file (dev.env, sit.env, etc.)
  headless: true                      # Run browser in headless mode
  timeout: 300000                     # Project timeout in ms (5 minutes)
  browser: chromium                   # Browser: chromium, firefox, webkit, edge
  parallel: 1                         # Parallel workers per project
  retry: 0                            # Retry attempts on failure
  logLevel: DEBUG                     # Log level: DEBUG, INFO, WARN, ERROR

  artifacts:
    video: off                        # Video: off, on-failure, always
    trace: off                        # Trace: off, on-failure, always
    screenshot: on-failure            # Screenshot: off, on-failure, always
    har: off                          # HAR files: off, on-failure, always

# =============================================================================
# EXECUTION SETTINGS
# =============================================================================
execution:
  mode: sequential                    # Currently only sequential supported
  stopOnFailure: false                # Stop suite on first project failure
  delayBetweenProjects: 2000          # Delay in ms between projects

# =============================================================================
# REPORTING SETTINGS
# =============================================================================
reporting:
  consolidated: true                  # Generate consolidated HTML report
  autoOpen: true                      # Auto-open report when complete
  formats:
    - html
    - json
  zipResults: false                   # Zip results folder (auto-true in CI)
  keepUnzipped: true                  # Keep unzipped folder when zipping

# =============================================================================
# PROJECTS TO EXECUTE
# =============================================================================
projects:
  # Project 1: UI Tests
  - name: WebApp-UI
    type: ui                          # Type: ui, api, hybrid
    project: myproject                # Config folder name
    features: test/myproject/features/login.feature
    enabled: true
    # Optional overrides:
    # tags: "@smoke"
    # environment: sit
    # headless: false
    # browser: firefox
    # parallel: 2
    # retry: 1
    # timeout: 600000
    # artifacts:
    #   video: on-failure

  # Project 2: Hybrid Tests (UI + Database)
  - name: WebApp-Hybrid
    type: hybrid
    project: myproject
    features: test/myproject/features/database-tests.feature
    enabled: true
    modules: database                 # Explicit module loading

  # Project 3: API Tests
  - name: API-Tests
    type: api
    project: api-project
    features: test/api-project/features/api-tests.feature
    enabled: true

  # Project 4: Spec Format Tests
  - name: Spec-Tests
    type: ui
    project: myproject
    specs: test/myproject/specs/**/*.spec.ts    # Spec files instead of features
    enabled: false                               # Disabled - won't run</code></pre>

                <h3>Suite-Level Options</h3>
                <table>
                    <thead><tr><th>Option</th><th>Type</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>version</code></td><td>string</td><td>Configuration format version (required: "1.0")</td></tr>
                        <tr><td><code>name</code></td><td>string</td><td>Suite display name (required)</td></tr>
                        <tr><td><code>description</code></td><td>string</td><td>Suite description (optional)</td></tr>
                    </tbody>
                </table>

                <h3>Defaults Section Options</h3>
                <table>
                    <thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>environment</code></td><td>string</td><td>SIT</td><td>Environment name</td></tr>
                        <tr><td><code>headless</code></td><td>boolean</td><td>false</td><td>Headless browser mode (enforced true in CI)</td></tr>
                        <tr><td><code>timeout</code></td><td>number</td><td>300000</td><td>Project timeout in milliseconds</td></tr>
                        <tr><td><code>browser</code></td><td>string</td><td>chromium</td><td>Browser: chromium, firefox, webkit, edge</td></tr>
                        <tr><td><code>parallel</code></td><td>number</td><td>1</td><td>Parallel workers per project</td></tr>
                        <tr><td><code>retry</code></td><td>number</td><td>0</td><td>Retry attempts on failure</td></tr>
                        <tr><td><code>logLevel</code></td><td>string</td><td>DEBUG</td><td>Log level (enforced INFO in CI)</td></tr>
                    </tbody>
                </table>

                <h3>Artifacts Options</h3>
                <table>
                    <thead><tr><th>Option</th><th>Values</th><th>CI Behavior</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>video</code></td><td>off, on-failure, always</td><td>Enforced: off</td><td>Video recording</td></tr>
                        <tr><td><code>trace</code></td><td>off, on-failure, always</td><td>Enforced: off</td><td>Playwright trace capture</td></tr>
                        <tr><td><code>screenshot</code></td><td>off, on-failure, always</td><td>Enforced: off</td><td>Screenshot capture</td></tr>
                        <tr><td><code>har</code></td><td>off, on-failure, always</td><td>Enforced: off</td><td>HAR file capture</td></tr>
                    </tbody>
                </table>

                <h3>Project Options</h3>
                <table>
                    <thead><tr><th>Option</th><th>Type</th><th>Required</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Display name (shown in reports)</td></tr>
                        <tr><td><code>type</code></td><td>string</td><td>Yes</td><td>Type: ui, api, hybrid</td></tr>
                        <tr><td><code>project</code></td><td>string</td><td>Yes</td><td>Config folder name (config/&lt;name&gt;/)</td></tr>
                        <tr><td><code>features</code></td><td>string|array</td><td>*</td><td>Feature file paths (BDD)</td></tr>
                        <tr><td><code>specs</code></td><td>string|array</td><td>*</td><td>Spec file paths (Spec format)</td></tr>
                        <tr><td><code>enabled</code></td><td>boolean</td><td>No</td><td>Enable/disable project (default: true)</td></tr>
                        <tr><td><code>tags</code></td><td>string</td><td>No</td><td>Tag filter for scenarios</td></tr>
                        <tr><td><code>modules</code></td><td>string|array</td><td>No</td><td>Explicit modules: database, api, soap</td></tr>
                        <tr><td colspan="4"><em>* Either features or specs required</em></td></tr>
                    </tbody>
                </table>

                <h3>Running Suites</h3>
                <pre><code># Run default test-suite.yaml
npx cs-playwright-test --suite=multi-project

# Run with custom suite file
npx cs-playwright-test --suite=multi-project --suite-config=test-suite-edge.yaml

# Run only API projects
npx cs-playwright-test --suite=multi-project --suite-mode=api-only

# Run only UI projects
npx cs-playwright-test --suite=multi-project --suite-mode=ui-only

# Stop on first project failure
npx cs-playwright-test --suite=multi-project --suite-stop-on-failure

# Override environment for all projects
npx cs-playwright-test --suite=multi-project --environment=uat

# Add tag filter to all projects
npx cs-playwright-test --suite=multi-project --tags="@smoke"

# Override parallel workers
npx cs-playwright-test --suite=multi-project --workers=4</code></pre>

                <h3>CI/CD Pipeline Detection</h3>
                <p>The framework automatically detects CI environments and enforces settings:</p>
                <table>
                    <thead><tr><th>CI Platform</th><th>Detection Variable</th></tr></thead>
                    <tbody>
                        <tr><td>Azure DevOps</td><td><code>TF_BUILD</code>, <code>BUILD_BUILDID</code></td></tr>
                        <tr><td>GitHub Actions</td><td><code>GITHUB_ACTIONS</code></td></tr>
                        <tr><td>Jenkins</td><td><code>JENKINS_URL</code></td></tr>
                        <tr><td>GitLab CI</td><td><code>GITLAB_CI</code></td></tr>
                        <tr><td>CircleCI</td><td><code>CIRCLECI</code></td></tr>
                        <tr><td>Travis CI</td><td><code>TRAVIS</code></td></tr>
                    </tbody>
                </table>

                <h4>Pipeline Enforced Settings (Cannot Override in CI)</h4>
                <ul>
                    <li><code>headless: true</code> - Always headless in pipeline</li>
                    <li><code>autoOpen: false</code> - Never auto-open reports</li>
                    <li><code>video: off</code> - No video recording</li>
                    <li><code>trace: off</code> - No trace capture</li>
                    <li><code>screenshot: off</code> - No screenshots</li>
                    <li><code>har: off</code> - No HAR files</li>
                    <li><code>zipResults: true</code> - Always zip for artifacts</li>
                    <li><code>logLevel: INFO</code> - Less verbose logging</li>
                </ul>

                <h3>Smart Execution Mode</h3>
                <p>The framework optimizes execution based on enabled projects:</p>
                <ul>
                    <li><strong>1 enabled project</strong>: NORMAL mode (no suite overhead)</li>
                    <li><strong>2+ enabled projects</strong>: SUITE mode (consolidated reports)</li>
                </ul>

                <h3>Example: Browser-Specific Suites</h3>
                <pre><code># test-suite-edge.yaml - Same tests in Edge browser
version: "1.0"
name: "Edge Browser Test Suite"

defaults:
  browser: edge
  headless: false
  artifacts:
    video: on-failure
    screenshot: on-failure

projects:
  - name: WebApp-Edge
    type: ui
    project: myproject
    features: test/myproject/features/login.feature
    enabled: true</code></pre>

                <h3>Example: Parallel Execution Suite</h3>
                <pre><code># test-suite-parallel.yaml - Parallel scenario execution
version: "1.0"
name: "Parallel Execution Suite"

defaults:
  parallel: 4                         # 4 parallel workers
  browser: chromium
  headless: true
  artifacts:
    video: off                        # Disable video for faster parallel
    screenshot: on-failure

execution:
  delayBetweenProjects: 1000          # Shorter delay

projects:
  - name: Smoke-Tests
    type: ui
    project: myproject
    features: test/myproject/features/*.feature
    tags: "@smoke"
    enabled: true</code></pre>

                <div class="tip">
                    <strong>ðŸ’¡ Tips:</strong>
                    <ul>
                        <li>Use <code>enabled: false</code> to temporarily disable a project without removing it</li>
                        <li>Project-level settings override defaults section settings</li>
                        <li>Same project can appear multiple times with different names (e.g., different browsers)</li>
                        <li>Use <code>--suite-mode=api-only</code> to quickly run only API tests in CI</li>
                        <li>Consolidated HTML report combines all project results for easy review</li>
                    </ul>
                </div>
            </section>

            <!-- PIPELINE EXECUTION -->
            <section id="pipeline-execution">
                <h2>Pipeline & CI/CD Execution</h2>

                <p>Run tests in CI/CD pipelines with full reporting and Azure DevOps integration.</p>

                <h3>Azure DevOps Pipeline (azure-pipelines.yml)</h3>
                <pre><code>trigger:
  branches:
    include: [main, develop]

pool:
  vmImage: 'ubuntu-latest'

steps:
  - task: NodeTool@0
    inputs:
      versionSpec: '20.x'

  - script: npm ci
    displayName: 'Install dependencies'

  - script: npx playwright install --with-deps chromium
    displayName: 'Install browsers'

  - script: |
      npx cs-playwright-test \
        --project=myproject \
        --tags="@smoke" \
        --parallel --workers=4 \
        --reporter=html,json,ado
    displayName: 'Run Tests'
    env:
      BASE_URL: $(BASE_URL)
      ADO_ENABLED: 'true'
      ADO_ORG_URL: $(System.CollectionUri)
      ADO_PROJECT: $(System.TeamProject)
      ADO_ACCESS_TOKEN: $(System.AccessToken)
      ADO_TEST_PLAN_ID: $(TEST_PLAN_ID)

  - task: PublishTestResults@2
    condition: always()
    inputs:
      testResultsFormat: 'JUnit'
      testResultsFiles: '**/test-results/*.xml'

  - task: PublishPipelineArtifact@1
    condition: always()
    inputs:
      targetPath: 'reports'
      artifact: 'test-reports'</code></pre>

                <h3>GitHub Actions (.github/workflows/test.yml)</h3>
                <pre><code>name: Automated Tests
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - run: npm ci
      - run: npx playwright install --with-deps chromium

      - run: npx cs-playwright-test --project=myproject --tags="@smoke"
        env:
          BASE_URL: ${{ secrets.BASE_URL }}

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: reports/</code></pre>

                <h3>CLI Options for Pipeline</h3>
                <table>
                    <thead><tr><th>Option</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>--project</code></td><td>Project to run</td></tr>
                        <tr><td><code>--suite</code></td><td>Suite file to execute</td></tr>
                        <tr><td><code>--specs</code></td><td>Spec file pattern</td></tr>
                        <tr><td><code>--features</code></td><td>Feature file pattern</td></tr>
                        <tr><td><code>--tags</code></td><td>Tag filter</td></tr>
                        <tr><td><code>--browser</code></td><td>Browser type</td></tr>
                        <tr><td><code>--headless</code></td><td>Headless mode</td></tr>
                        <tr><td><code>--parallel</code></td><td>Enable parallel</td></tr>
                        <tr><td><code>--workers</code></td><td>Worker count</td></tr>
                        <tr><td><code>--retries</code></td><td>Retry count</td></tr>
                        <tr><td><code>--reporter</code></td><td>Report formats (html,json,ado,junit)</td></tr>
                        <tr><td><code>--shard</code></td><td>Test sharding (1/4, 2/4, etc.)</td></tr>
                    </tbody>
                </table>

                <h3>Sharding for Large Suites</h3>
                <pre><code># Split tests across 4 machines
# Machine 1: npx cs-playwright-test --shard=1/4
# Machine 2: npx cs-playwright-test --shard=2/4
# Machine 3: npx cs-playwright-test --shard=3/4
# Machine 4: npx cs-playwright-test --shard=4/4</code></pre>
            </section>

            <!-- REPORTING -->
            <section id="reporting">
                <h2>Reporting & Evidence - CSReporter</h2>

                <p>CSReporter provides comprehensive logging, step tracking, and AI data recording for test reporting.</p>

                <h3>CSReporter Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>pass(message)</code></td><td>Log a passed step with green indicator</td></tr>
                        <tr><td><code>fail(message)</code></td><td>Log a failed step with red indicator</td></tr>
                        <tr><td><code>info(message)</code></td><td>Log informational message</td></tr>
                        <tr><td><code>warn(message)</code></td><td>Log warning message (yellow)</td></tr>
                        <tr><td><code>error(message)</code></td><td>Log error message (red)</td></tr>
                        <tr><td><code>debug(message)</code></td><td>Log debug message (shown when LOG_LEVEL=DEBUG)</td></tr>
                        <tr><td><code>startStep(name)</code></td><td>Start a named step for grouping</td></tr>
                        <tr><td><code>endStep()</code></td><td>End the current step</td></tr>
                        <tr><td><code>startTest(name)</code></td><td>Mark test start for reporting</td></tr>
                        <tr><td><code>endTest(status)</code></td><td>Mark test end with status</td></tr>
                        <tr><td><code>attachScreenshot(path, name?)</code></td><td>Attach screenshot to report</td></tr>
                        <tr><td><code>attachFile(path, name?)</code></td><td>Attach file to report</td></tr>
                        <tr><td><code>recordAIHealing(data)</code></td><td>Record AI self-healing action</td></tr>
                        <tr><td><code>recordAIIdentification(data)</code></td><td>Record AI element identification</td></tr>
                        <tr><td><code>recordAIPrediction(data)</code></td><td>Record AI failure prediction</td></tr>
                        <tr><td><code>setLogLevel(level)</code></td><td>Set logging level (DEBUG/INFO/WARN/ERROR)</td></tr>
                    </tbody>
                </table>

                <h3>Basic Logging Examples</h3>
                <pre><code>// Spec Format
test('Login workflow', async ({ loginPage, reporter }) => {
    reporter.info('Starting login test');

    reporter.startStep('Navigate to login page');
    await loginPage.navigate();
    reporter.pass('Navigation successful');
    reporter.endStep();

    reporter.startStep('Enter credentials');
    await loginPage.fill('Admin', 'admin123');
    reporter.info('Credentials entered');
    reporter.endStep();

    reporter.startStep('Submit login form');
    await loginPage.clickLogin();
    reporter.pass('Login form submitted');
    reporter.endStep();

    reporter.startStep('Verify dashboard');
    await loginPage.verifyLoginSuccess();
    reporter.pass('Successfully logged in to dashboard');
    reporter.endStep();
});

// BDD Format
@When('I login with valid credentials')
async loginWithValidCredentials() {
    CSReporter.startStep('Login with valid credentials');

    CSReporter.info('Entering username');
    await this.loginPage.enterUsername('Admin');

    CSReporter.info('Entering password');
    await this.loginPage.enterPassword('admin123');

    CSReporter.info('Clicking login button');
    await this.loginPage.clickLogin();

    CSReporter.pass('Login completed');
    CSReporter.endStep();
}</code></pre>

                <h3>Advanced Reporting</h3>
                <pre><code>// Spec Format - with screenshots and attachments
test('Visual verification', async ({ navigate, screenshotManager, reporter, browserManager }) => {
    await navigate('https://example.com');

    // Take and attach screenshot using screenshotManager
    const screenshotPath = await screenshotManager.capture('homepage');
    reporter.attachScreenshot(screenshotPath, 'Homepage Screenshot');

    // Attach log file
    reporter.attachFile('logs/test.log', 'Test Log');

    // Debug logging using CSPageDiagnostics
    const diagnostics = CSPageDiagnostics.getInstance();
    const domSummary = await diagnostics.getDOMSummary();
    reporter.debug('DOM state: ' + JSON.stringify(domSummary).slice(0, 200));

    // Warning for potential issues - use CSPerformanceMonitor
    const perfMonitor = CSPerformanceMonitor.getInstance();
    const metrics = await perfMonitor.getMetrics();
    if (metrics.loadTime > 3000) {
        reporter.warn(`Page load time exceeded 3s: ${metrics.loadTime}ms`);
    }

    reporter.pass('Visual verification complete');
});

// BDD Format
@Then('I should see the dashboard')
async verifyDashboard() {
    const isVisible = await this.dashboardPage.isVisible();

    if (isVisible) {
        CSReporter.pass('Dashboard is visible');
        await this.page.screenshot({ path: 'screenshots/dashboard.png' });
        CSReporter.attachScreenshot('screenshots/dashboard.png', 'Dashboard');
    } else {
        CSReporter.fail('Dashboard is not visible');
        CSReporter.error('Expected dashboard to be displayed after login');
        throw new Error('Dashboard not visible');
    }
}</code></pre>

                <h3>Log Levels</h3>
                <table>
                    <thead><tr><th>Level</th><th>Description</th><th>Config</th></tr></thead>
                    <tbody>
                        <tr><td>DEBUG</td><td>All messages including debug</td><td><code>LOG_LEVEL=DEBUG</code></td></tr>
                        <tr><td>INFO</td><td>Info, warn, error, pass, fail</td><td><code>LOG_LEVEL=INFO</code></td></tr>
                        <tr><td>WARN</td><td>Warnings and errors only</td><td><code>LOG_LEVEL=WARN</code></td></tr>
                        <tr><td>ERROR</td><td>Errors only</td><td><code>LOG_LEVEL=ERROR</code></td></tr>
                    </tbody>
                </table>

                <h3>Report Formats</h3>
                <ul>
                    <li><strong>HTML</strong> - Interactive report with tabs, filters, screenshots</li>
                    <li><strong>JSON</strong> - Machine-readable test results</li>
                    <li><strong>JUnit XML</strong> - CI/CD integration</li>
                    <li><strong>PDF</strong> - Printable reports</li>
                    <li><strong>Excel</strong> - Multi-sheet workbook with charts</li>
                </ul>

                <h3>Evidence Collection</h3>
                <pre><code>import { CSEvidenceCollector } from '@mdakhan.mak/cs-playwright-test-framework/evidence';

const evidence = CSEvidenceCollector.getInstance();

// Start collection for test
await evidence.startCollection('My Test');

// On failure, collect evidence
await evidence.collectOnFailure('My Test', error);

// Save all evidence to disk
await evidence.saveEvidence(evidenceId);

// Package as ZIP
const zipPath = await evidence.packageAllEvidence();</code></pre>

                <h3>Screenshot Options</h3>
                <pre><code>import { CSScreenshotManager } from '@mdakhan.mak/cs-playwright-test-framework/media';

const screenshots = CSScreenshotManager.getInstance();

// Full page screenshot
await screenshots.captureFullPage(page, { name: 'full-page' });

// Element screenshot
await screenshots.captureElement(element, { name: 'button' });

// With annotations
await screenshots.captureWithAnnotations(page, [
    { selector: '.error', text: 'Error here!', style: 'error' }
]);

// Compare with baseline
const result = await screenshots.compareWithBaseline(page, 'login-page');
if (!result.match) {
    console.log('Diff:', result.diffPercentage, '%');
}</code></pre>

                <h3>CSVideoRecorder - Video Recording</h3>
                <p>Record test execution videos for debugging and evidence collection.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSVideoRecorder</td></tr>
                        <tr><td><code>startRecording(page, options?)</code></td><td>Start video recording</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>stopRecording()</code></td><td>Stop recording and save video</td><td>Promise&lt;string&gt;</td></tr>
                        <tr><td><code>pauseRecording()</code></td><td>Pause current recording</td><td>void</td></tr>
                        <tr><td><code>resumeRecording()</code></td><td>Resume paused recording</td><td>void</td></tr>
                        <tr><td><code>isRecording()</code></td><td>Check if recording is active</td><td>boolean</td></tr>
                        <tr><td><code>getVideoPath()</code></td><td>Get path to recorded video</td><td>string | null</td></tr>
                        <tr><td><code>setOutputDir(path)</code></td><td>Set video output directory</td><td>void</td></tr>
                        <tr><td><code>setVideoSize(width, height)</code></td><td>Set video dimensions</td><td>void</td></tr>
                    </tbody>
                </table>

                <pre><code>// Spec Format - Video Recording
import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';

describe('Video Recording Tests', () => {

    test('Record test execution', async ({ loginPage, videoRecorder, reporter, browserManager }) => {
        // Start recording using page from browserManager
        await videoRecorder.startRecording(browserManager.getPage(), {
            outputDir: './videos',
            name: 'login-test'
        });

        // Use page object methods instead of direct page access
        await loginPage.navigate();
        await loginPage.usernameField.fill('Admin');
        await loginPage.passwordField.fill('admin123');
        await loginPage.loginButton.click();

        // Stop and get video path
        const videoPath = await videoRecorder.stopRecording();
        reporter.info(`Video saved to: ${videoPath}`);
        reporter.attachFile(videoPath, 'Test Recording');
    });
});

// BDD Format
@When('I record the login process')
async recordLogin() {
    await this.videoRecorder.startRecording(this.browserManager.getPage());
    // Perform login steps using page object...
    await this.loginPage.login('Admin', 'admin123');
    const video = await this.videoRecorder.stopRecording();
    CSReporter.attachFile(video, 'Login Video');
}</code></pre>

                <h3>CSEvidenceCollector - Evidence Collection</h3>
                <p>Automatically collect screenshots, logs, and artifacts on test failure.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSEvidenceCollector</td></tr>
                        <tr><td><code>startCollection(testName)</code></td><td>Start collecting evidence for test</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>collectOnFailure(testName, error)</code></td><td>Collect evidence when test fails</td><td>Promise&lt;EvidencePackage&gt;</td></tr>
                        <tr><td><code>addScreenshot(name, data)</code></td><td>Add screenshot to evidence</td><td>void</td></tr>
                        <tr><td><code>addLog(name, content)</code></td><td>Add log to evidence</td><td>void</td></tr>
                        <tr><td><code>addHtml(page)</code></td><td>Capture page HTML</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>addConsoleLog(page)</code></td><td>Capture browser console logs</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>addNetworkLog()</code></td><td>Capture network requests</td><td>void</td></tr>
                        <tr><td><code>saveEvidence(evidenceId)</code></td><td>Save evidence to disk</td><td>Promise&lt;string&gt;</td></tr>
                        <tr><td><code>packageAllEvidence()</code></td><td>Package evidence as ZIP</td><td>Promise&lt;string&gt;</td></tr>
                        <tr><td><code>getEvidence(testName)</code></td><td>Get evidence for test</td><td>EvidencePackage</td></tr>
                        <tr><td><code>clearEvidence()</code></td><td>Clear collected evidence</td><td>void</td></tr>
                    </tbody>
                </table>

                <pre><code>// Spec Format - Evidence Collection
import { describe, test, afterEach } from '@mdakhan.mak/cs-playwright-test-framework/spec';

describe('Evidence Collection', () => {

    afterEach(async ({ evidenceCollector, screenshotManager, reporter }, testInfo) => {
        if (testInfo.status === 'failed') {
            // Collect comprehensive evidence on failure using framework methods
            const screenshotPath = await screenshotManager.capture('failure');
            await evidenceCollector.addScreenshot('failure', screenshotPath);
            await evidenceCollector.addHtml();
            await evidenceCollector.addConsoleLog();
            await evidenceCollector.addNetworkLog();

            const zipPath = await evidenceCollector.packageAllEvidence();
            reporter.info(`Evidence package: ${zipPath}`);
        }
    });

    test('Test with automatic evidence collection', async ({ dashboardPage, evidenceCollector }) => {
        await evidenceCollector.startCollection('my-test');

        await dashboardPage.navigate();
        // Test steps using page object...
        await dashboardPage.verifyDashboardLoaded();
    });
});

// BDD Format
@AfterScenario()
async collectEvidence(scenario: IScenario) {
    if (scenario.result.status === 'FAILED') {
        const evidence = CSEvidenceCollector.getInstance();
        await evidence.collectOnFailure(scenario.name, scenario.result.error);
        const zip = await evidence.packageAllEvidence();
        CSReporter.attachFile(zip, 'Failure Evidence');
    }
}</code></pre>
            </section>

            <!-- VARIABLE INTERPOLATION -->
            <section id="variable-interpolation">
                <h2>Variable Interpolation</h2>
                <p>The framework provides powerful variable interpolation and template resolution capabilities across all file types: configuration files, data sources, feature files, and API templates.</p>

                <h3>Interpolation Quick Reference</h3>
                <table>
                    <thead><tr><th>Location</th><th>Pattern</th><th>Example</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td>.env files</td><td><code>${VAR_NAME}</code></td><td><code>URL=${BASE_URL}/api</code></td><td>Reference other config variables</td></tr>
                        <tr><td>.env files</td><td><code>ENCRYPTED:</code></td><td><code>ENCRYPTED:eyJlbm...</code></td><td>Encrypted value (auto-decrypted)</td></tr>
                        <tr><td>Data files</td><td><code>&lt;random&gt;</code></td><td><code>user_&lt;random&gt;</code></td><td>Random string (7 chars)</td></tr>
                        <tr><td>Data files</td><td><code>&lt;timestamp&gt;</code></td><td><code>test_&lt;timestamp&gt;</code></td><td>Unix timestamp (ms)</td></tr>
                        <tr><td>Data files</td><td><code>&lt;uuid&gt;</code></td><td><code>&lt;uuid&gt;</code></td><td>UUID v4</td></tr>
                        <tr><td>Data files</td><td><code>&lt;generate:type&gt;</code></td><td><code>&lt;generate:email&gt;</code></td><td>Generate email, username, password, phone</td></tr>
                        <tr><td>Data files</td><td><code>&lt;config:KEY&gt;</code></td><td><code>&lt;config:BASE_URL&gt;</code></td><td>Configuration value</td></tr>
                        <tr><td>Data files</td><td><code>&lt;env:KEY&gt;</code></td><td><code>&lt;env:HOME&gt;</code></td><td>Environment variable</td></tr>
                        <tr><td>Data files</td><td><code>&lt;date:FORMAT&gt;</code></td><td><code>&lt;date:YYYY-MM-DD&gt;</code></td><td>Formatted date</td></tr>
                        <tr><td>Feature files</td><td><code>&lt;column&gt;</code></td><td><code>&lt;username&gt;</code></td><td>Scenario Outline data</td></tr>
                        <tr><td>Feature files</td><td><code>{config:KEY}</code></td><td><code>{config:PASSWORD}</code></td><td>Configuration in steps</td></tr>
                        <tr><td>Feature files</td><td><code>{scenario:var}</code></td><td><code>{scenario:userId}</code></td><td>Scenario context variable</td></tr>
                        <tr><td>Spec tests</td><td><code>{{variable}}</code></td><td><code>{{username}}</code></td><td>Context variable</td></tr>
                        <tr><td>Spec tests</td><td><code>$variable</code></td><td><code>$username</code></td><td>Context variable (alt syntax)</td></tr>
                        <tr><td>API templates</td><td><code>{{obj.prop}}</code></td><td><code>{{user.email}}</code></td><td>Dot notation access</td></tr>
                        <tr><td>API templates</td><td><code>{{func(arg)}}</code></td><td><code>{{uuid()}}</code></td><td>Function call</td></tr>
                        <tr><td>API templates</td><td><code>{{val | transform}}</code></td><td><code>{{name | uppercase}}</code></td><td>Pipe transformation</td></tr>
                    </tbody>
                </table>

                <h3>CSValueResolver - Simple Variable Resolution</h3>
                <p>Core resolver for context variables, configuration values, and encrypted data. Automatically used by the framework when processing test data.</p>

                <h4>Supported Patterns</h4>
                <pre><code>// Pattern 1: Double curly braces - Context variables
const value = "Hello {{username}}";  // Replaced with context.getVariable('username')

// Pattern 2: Single curly brace with prefix - Feature file format
const stepValue = "{scenario:userId}";    // Scenario context variable
const configVal = "{config:BASE_URL}";    // Configuration value
const envVal = "{env:NODE_ENV}";          // Environment variable

// Pattern 3: Double curly brace with prefix
const config = "{{config:API_KEY}}";      // Configuration value
const env = "{{env:HOME}}";               // Environment variable

// Pattern 4: Dollar sign prefix
const dollar = "$username";               // Context variable (whole string only)

// Pattern 5: Encrypted values (auto-decrypted)
const password = "ENCRYPTED:eyJlbmNyeXB0ZWQiOiJiYXNlNjREYXRhLi4uIn0=";</code></pre>

                <h4>Usage in Tests</h4>
                <pre><code>import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utils';

// Create a context with variables
const context = {
    getVariable: (key: string) => {
        const vars: Record&lt;string, any&gt; = {
            username: 'testuser',
            userId: 12345,
            __config_BASE_URL: 'https://example.com',
            __env_NODE_ENV: 'test'
        };
        return vars[key];
    }
};

// Resolve single value
const resolved = CSValueResolver.resolve("Hello {{username}}", context);
// Result: "Hello testuser"

// Resolve object with multiple values
const data = {
    url: "{config:BASE_URL}/api/users",
    user: "{{username}}",
    id: "$userId"
};
const resolvedData = CSValueResolver.resolveObject(data, context);
// Result: { url: "https://example.com/api/users", user: "testuser", id: 12345 }

// Check if value needs resolution
const needsResolve = CSValueResolver.needsResolution("{{username}}");  // true
const noResolve = CSValueResolver.needsResolution("plain text");       // false</code></pre>

                <h3>Data File Dynamic Placeholders</h3>
                <p>When loading data from CSV, JSON, or Excel files, dynamic placeholders are automatically resolved.</p>

                <h4>Available Placeholders</h4>
                <table>
                    <thead><tr><th>Placeholder</th><th>Description</th><th>Example Output</th></tr></thead>
                    <tbody>
                        <tr><td><code>&lt;random&gt;</code></td><td>Random alphanumeric string (7 chars)</td><td><code>k2x9m4n</code></td></tr>
                        <tr><td><code>&lt;timestamp&gt;</code></td><td>Unix timestamp in milliseconds</td><td><code>1735689600000</code></td></tr>
                        <tr><td><code>&lt;uuid&gt;</code></td><td>UUID v4</td><td><code>550e8400-e29b-41d4-a716-446655440000</code></td></tr>
                        <tr><td><code>&lt;date&gt;</code></td><td>Current date (ISO format)</td><td><code>2025-12-31</code></td></tr>
                        <tr><td><code>&lt;time&gt;</code></td><td>Current time (ISO format)</td><td><code>14:30:45.123Z</code></td></tr>
                        <tr><td><code>&lt;generate:email&gt;</code></td><td>Generated test email</td><td><code>test_1735689600000@example.com</code></td></tr>
                        <tr><td><code>&lt;generate:username&gt;</code></td><td>Generated username</td><td><code>user_k2x9m4n</code></td></tr>
                        <tr><td><code>&lt;generate:password&gt;</code></td><td>Generated secure password (12 chars)</td><td><code>Xk9#mP2$vQ4@</code></td></tr>
                        <tr><td><code>&lt;generate:phone&gt;</code></td><td>Generated phone number</td><td><code>555-123-4567</code></td></tr>
                        <tr><td><code>&lt;config:KEY&gt;</code></td><td>Value from configuration</td><td>Value of KEY from .env</td></tr>
                        <tr><td><code>&lt;env:KEY&gt;</code></td><td>System environment variable</td><td>Value of process.env.KEY</td></tr>
                        <tr><td><code>&lt;date:FORMAT&gt;</code></td><td>Formatted current date</td><td>See format options below</td></tr>
                    </tbody>
                </table>

                <h4>Date Format Options</h4>
                <pre><code>// Date format placeholders
&lt;date:YYYY-MM-DD&gt;      // 2025-12-31
&lt;date:MM/DD/YYYY&gt;      // 12/31/2025
&lt;date:DD-MM-YYYY&gt;      // 31-12-2025
&lt;date:YYYY-MM-DD HH:mm:ss&gt;  // 2025-12-31 14:30:45
&lt;date:HH:mm:ss&gt;        // 14:30:45

// Format tokens:
// YYYY - 4-digit year
// MM   - 2-digit month (01-12)
// DD   - 2-digit day (01-31)
// HH   - 2-digit hour (00-23)
// mm   - 2-digit minute (00-59)
// ss   - 2-digit second (00-59)</code></pre>

                <h4>Example CSV Data File</h4>
                <pre><code>username,password,email,expected
admin_&lt;random&gt;,pass123,&lt;generate:email&gt;,success
user_&lt;timestamp&gt;,admin123,test@&lt;generate:email&gt;,success
&lt;generate:username&gt;,&lt;generate:password&gt;,&lt;generate:email&gt;,success
testuser,&lt;config:ADMIN_PASSWORD&gt;,admin@example.com,success
dynuser,&lt;env:TEST_PASSWORD&gt;,&lt;config:ADMIN_EMAIL&gt;,success
dated_&lt;date:YYYY-MM-DD&gt;,pass123,test@example.com,success</code></pre>

                <h4>Example JSON Data File</h4>
                <pre><code>{
    "testcases": [
        {
            "id": "TC001",
            "username": "user_&lt;random&gt;",
            "email": "&lt;generate:email&gt;",
            "password": "&lt;config:DEFAULT_PASSWORD&gt;",
            "createdAt": "&lt;date:YYYY-MM-DD HH:mm:ss&gt;"
        },
        {
            "id": "TC002",
            "username": "&lt;generate:username&gt;",
            "email": "test_&lt;timestamp&gt;@&lt;config:EMAIL_DOMAIN&gt;",
            "password": "&lt;generate:password&gt;",
            "uuid": "&lt;uuid&gt;"
        }
    ]
}</code></pre>

                <h3>Configuration File Interpolation (.env)</h3>
                <p>Environment configuration files support variable references and encrypted values.</p>

                <h4>Variable References</h4>
                <pre><code># config/myproject/common/common.env

# Base configuration
BASE_URL=https://example.com
API_VERSION=v2

# Variable references using ${VAR_NAME}
API_URL=${BASE_URL}/api/${API_VERSION}
LOGIN_URL=${BASE_URL}/auth/login
LOGOUT_URL=${BASE_URL}/auth/logout

# Complex compositions
FULL_TITLE=${APP_NAME} - ${ENVIRONMENT} Environment
REPORT_PATH=./reports/${ENVIRONMENT}/${APP_NAME}

# Encrypted credentials (automatically decrypted when accessed)
ADMIN_PASSWORD=ENCRYPTED:eyJlbmNyeXB0ZWQiOiJhZG1pbjEyMyIsImlkIjoxMjM0NX0=
API_KEY=ENCRYPTED:eyJlbmNyeXB0ZWQiOiJhYmNkLTEyMzQtZWZnaCIsImlkIjoxMjM0NX0=
DB_PASSWORD=ENCRYPTED:eyJlbmNyeXB0ZWQiOiJteXNlY3JldHBhc3MiLCJpZCI6MTIzNDV9</code></pre>

                <h4>Generating Encrypted Values</h4>
                <pre><code>import { CSEncryptionUtil } from '@mdakhan.mak/cs-playwright-test-framework/utils';

// Get singleton instance
const encryptor = CSEncryptionUtil.getInstance();

// Encrypt a value
const encrypted = encryptor.encrypt('mySecretPassword123');
// Returns: "ENCRYPTED:eyJlbmNyeXB0ZWQiOiJiYXNlNjRFbmNvZGVkRGF0YSJ9"

// Decrypt a value (done automatically by framework)
const decrypted = encryptor.decrypt(encrypted);
// Returns: "mySecretPassword123"

// Check if value is encrypted
const isEnc = encryptor.isEncrypted(encrypted);  // true</code></pre>

                <h3>Feature File Interpolation (BDD)</h3>
                <p>Gherkin feature files support several interpolation patterns for data-driven testing.</p>

                <h4>Scenario Outline Data</h4>
                <pre><code>Feature: User Login

  @data-driven
  Scenario Outline: Login with different credentials
    Given I am on the login page
    When I enter username "&lt;username&gt;" and password "&lt;password&gt;"
    And I click the login button
    Then I should see "&lt;expected_result&gt;"

    Examples:
      | username | password | expected_result |
      | admin    | admin123 | Dashboard       |
      | user1    | pass123  | Dashboard       |
      | invalid  | wrong    | Error message   |</code></pre>

                <h4>Configuration in Steps</h4>
                <pre><code>Feature: API Testing

  Scenario: Test API with config values
    # Using {config:KEY} pattern in steps
    Given I set the base URL to "{config:API_BASE_URL}"
    When I authenticate with password "{config:ADMIN_PASSWORD}"
    Then the response should contain "{config:EXPECTED_VALUE}"

  Scenario: Using scenario context
    Given I create a user and store the ID
    # Using {scenario:var} to reference stored values
    When I update user with ID "{scenario:userId}"
    Then user "{scenario:userName}" should be updated</code></pre>

                <h4>External Data Sources in Examples</h4>
                <pre><code>Feature: Data-Driven Login Tests

  @DataProvider(source="test/data/users.csv",type="csv")
  Scenario Outline: CSV data source
    When I login as "&lt;username&gt;" with password "&lt;password&gt;"
    Then login should be "&lt;result&gt;"

    Examples:
      | username | password | result |

  @data-driven
  Scenario Outline: JSON data source with JSONPath
    Given I am on the login page
    When I enter "&lt;username&gt;" and "&lt;password&gt;"
    Then I see "&lt;expected&gt;"

    # Inline JSON configuration
    Examples: {"type": "json", "source": "test/data/users.json", "path": "$.testcases[*]"}
      | username | password | expected |

  @data-driven
  Scenario Outline: Excel data source
    When I test with "&lt;input&gt;"
    Then result is "&lt;output&gt;"

    # Excel with specific sheet
    Examples: {"type": "excel", "source": "test/data/tests.xlsx", "sheet": "LoginTests"}
      | input | output |</code></pre>

                <h3>CSPlaceholderResolver - Advanced Template Engine</h3>
                <p>Powerful template resolution for API payloads with 50+ built-in functions, dot notation, and pipe transformations.</p>

                <h4>Basic Usage</h4>
                <pre><code>import { CSPlaceholderResolver } from '@mdakhan.mak/cs-playwright-test-framework/api';

// Create resolver instance
const resolver = new CSPlaceholderResolver();

// Set variables
resolver.setVariable('username', 'john_doe');
resolver.setVariable('user', { name: 'John', email: 'john@example.com', age: 30 });

// Resolve templates
const simple = resolver.resolve("Hello {{username}}!");
// Result: "Hello john_doe!"

const dotNotation = resolver.resolve("Email: {{user.email}}");
// Result: "Email: john@example.com"</code></pre>

                <h4>Built-in Functions</h4>
                <pre><code>// String Functions
{{uppercase(name)}}        // "JOHN"
{{lowercase(name)}}        // "john"
{{capitalize(name)}}       // "John"
{{trim(value)}}            // Remove whitespace
{{substring(str, 0, 5)}}   // First 5 chars
{{replace(str, "old", "new")}}
{{length(str)}}            // String length

// Number Functions
{{add(a, b)}}              // a + b
{{subtract(a, b)}}         // a - b
{{multiply(a, b)}}         // a * b
{{divide(a, b)}}           // a / b
{{round(num, 2)}}          // Round to 2 decimals
{{floor(num)}}             // Floor value
{{ceil(num)}}              // Ceiling value
{{random(1, 100)}}         // Random number 1-100
{{randomInt(1, 100)}}      // Random integer 1-100

// Date/Time Functions
{{now()}}                  // Current timestamp (ms)
{{timestamp()}}            // ISO timestamp
{{date()}}                 // Current date ISO
{{date("YYYY-MM-DD")}}     // Formatted date
{{dateAdd(date, 7, "day")}}  // Add 7 days
{{dateDiff(date1, date2, "day")}}  // Difference in days
{{formatDate(date, "MM/DD/YYYY")}}

// Encoding Functions
{{base64(str)}}            // Base64 encode
{{base64Decode(str)}}      // Base64 decode
{{urlEncode(str)}}         // URL encode
{{urlDecode(str)}}         // URL decode
{{jsonEncode(obj)}}        // JSON.stringify
{{jsonDecode(str)}}        // JSON.parse

// Hash Functions
{{md5(str)}}               // MD5 hash
{{sha1(str)}}              // SHA1 hash
{{sha256(str)}}            // SHA256 hash
{{sha512(str)}}            // SHA512 hash
{{hmac(str, key)}}         // HMAC-SHA256

// UUID/ID Functions
{{uuid()}}                 // UUID v4
{{guid()}}                 // Same as uuid()
{{shortId()}}              // Short random ID

// Array Functions
{{first(arr)}}             // First element
{{last(arr)}}              // Last element
{{slice(arr, 0, 5)}}       // Slice array
{{reverse(arr)}}           // Reverse array
{{sort(arr)}}              // Sort array
{{unique(arr)}}            // Remove duplicates
{{length(arr)}}            // Array length

// Object Functions
{{keys(obj)}}              // Object keys
{{values(obj)}}            // Object values
{{entries(obj)}}           // Key-value pairs
{{merge(obj1, obj2)}}      // Merge objects

// Conditional Functions
{{if(condition, trueVal, falseVal)}}
{{switch(value, case1, result1, case2, result2, default)}}
{{default(value, fallback)}}  // Use fallback if null/undefined
{{exists(value)}}             // true if defined

// Type Check Functions
{{type(value)}}            // "string", "number", etc.
{{isString(value)}}        // Boolean check
{{isNumber(value)}}
{{isBoolean(value)}}
{{isArray(value)}}
{{isObject(value)}}
{{isNull(value)}}
{{isUndefined(value)}}

// Faker Functions (Test Data)
{{faker.name()}}           // Random full name
{{faker.email()}}          // Random email
{{faker.phone()}}          // Random phone
{{faker.address()}}        // Random address
{{faker.company()}}        // Random company name
{{faker.lorem(20)}}        // 20 lorem ipsum words
{{faker.number(0, 100)}}   // Random number
{{faker.boolean()}}        // Random boolean</code></pre>

                <h4>Pipe Transformations</h4>
                <pre><code>// Chain transformations with pipes
resolver.resolve("{{name | uppercase}}");
// Result: "JOHN"

resolver.resolve("{{email | lowercase | trim}}");
// Result: "john@example.com"

resolver.resolve("{{text | replace('foo', 'bar') | uppercase}}");
// Result: transformed and uppercased</code></pre>

                <h4>API Template Example</h4>
                <pre><code>// Set up context
resolver.setVariable('orderId', 12345);
resolver.setVariable('customer', {
    name: 'John Doe',
    email: 'john@example.com',
    level: 'premium'
});

// API request template
const template = `{
    "orderId": "ORD-{{orderId}}",
    "timestamp": "{{timestamp()}}",
    "requestId": "{{uuid()}}",
    "customer": {
        "name": "{{customer.name | uppercase}}",
        "email": "{{customer.email | lowercase}}",
        "tier": "{{if(customer.level == 'premium', 'VIP', 'Standard')}}"
    },
    "signature": "{{hmac(orderId, 'secret-key')}}"
}`;

const payload = resolver.resolve(template);
// Returns fully resolved JSON payload</code></pre>

                <h4>Response Variable Storage</h4>
                <pre><code>// Store API response for later use
resolver.setResponse('login', {
    token: 'abc123',
    user: { id: 42, name: 'Test User' }
});

// Reference in subsequent requests
const template = `{
    "authorization": "Bearer {{response.login.token}}",
    "userId": {{response.login.user.id}}
}`;

resolver.resolve(template);
// Result: { "authorization": "Bearer abc123", "userId": 42 }</code></pre>

                <h3>Spec Format Data Interpolation</h3>
                <p>In spec format tests, data variables are automatically available in the <code>data</code> fixture.</p>

                <pre><code>describe('User Tests', {
    dataSource: {
        type: 'json',
        source: 'test/data/users.json',
        path: '$.users[*]'
    }
}, () => {
    test('Create user: {name}', async ({ data, reporter }) => {
        // data.name, data.email, etc. are automatically resolved
        // Dynamic placeholders like &lt;random&gt; are already processed

        reporter.info(`Creating user: ${data.name}`);
        reporter.info(`Email: ${data.email}`);
        reporter.info(`Generated ID: ${data.uuid}`);  // If &lt;uuid&gt; was in data

        // Use the resolved data
        await createUser({
            name: data.name,
            email: data.email,
            password: data.password  // Decrypted if ENCRYPTED:
        });
    });

    test('Test with context variables', async ({ ctx }) => {
        // Store variables in context
        ctx.set('userId', 12345);
        ctx.set('token', 'abc123');

        // Variables can be retrieved in subsequent tests/steps
        const userId = ctx.get('userId');
    });
});</code></pre>

                <h3>Complete Example: Multi-Layer Interpolation</h3>
                <pre><code>// 1. Configuration file: config/myproject/qa/qa.env
BASE_URL=https://qa.example.com
API_URL=${BASE_URL}/api/v2
ADMIN_PASSWORD=ENCRYPTED:eyJlbmNyeXB0ZWQiOiJhZG1pbjEyMyJ9

// 2. Data file: test/data/users.csv
username,password,email,token
admin,&lt;config:ADMIN_PASSWORD&gt;,admin@&lt;config:EMAIL_DOMAIN&gt;,&lt;uuid&gt;
user_&lt;random&gt;,&lt;generate:password&gt;,&lt;generate:email&gt;,&lt;uuid&gt;
test_&lt;timestamp&gt;,pass123,test@example.com,&lt;uuid&gt;

// 3. Feature file: test/features/login.feature
@DataProvider(source="test/data/users.csv",type="csv")
Scenario Outline: Login tests
    Given I navigate to "{config:BASE_URL}/login"
    When I login as "&lt;username&gt;" with password "&lt;password&gt;"
    Then I should be authenticated with token "&lt;token&gt;"
    And I store token in scenario as "authToken"

    Examples:
      | username | password | email | token |

Scenario: Use stored token
    When I make API call with token "{scenario:authToken}"
    Then the response is successful

// 4. Spec format test: test/specs/login.spec.ts
describe('Login Tests', {
    dataSource: { source: 'test/data/users.csv' }
}, () => {
    test('Login as {username}', async ({ data, config, ctx }) => {
        // data.username = "admin" or "user_k2x9m4n" (random resolved)
        // data.password = "admin123" (decrypted from ENCRYPTED:)
        // data.email = "admin@example.com" (config resolved)
        // data.token = "550e8400-..." (uuid generated)

        const baseUrl = config.get('BASE_URL');
        await login(data.username, data.password);

        ctx.set('authToken', data.token);
    });
});</code></pre>

                <div class="info-box tip">
                    <strong>Best Practices</strong>
                    <ul>
                        <li>Use <code>ENCRYPTED:</code> prefix for all sensitive values in config files</li>
                        <li>Use <code>&lt;generate:*&gt;</code> for unique test data to avoid conflicts</li>
                        <li>Use <code>&lt;config:KEY&gt;</code> to keep data files environment-agnostic</li>
                        <li>Store session data in context (<code>ctx</code>) for dependent tests</li>
                        <li>Use <code>{scenario:var}</code> in BDD for cross-step data sharing</li>
                    </ul>
                </div>
            </section>

            <!-- DATA MANAGEMENT -->
            <section id="data-management">
                <h2>Data Management</h2>

                <h3>CSDataProvider - Test Data Management</h3>
                <p>Load and manage test data from various sources (JSON, CSV, Excel, YAML, database).</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSDataProvider</td></tr>
                        <tr><td><code>loadFromJson(path)</code></td><td>Load data from JSON file</td><td>Promise&lt;any[]&gt;</td></tr>
                        <tr><td><code>loadFromCsv(path, options?)</code></td><td>Load data from CSV file</td><td>Promise&lt;any[]&gt;</td></tr>
                        <tr><td><code>loadFromExcel(path, sheet?)</code></td><td>Load data from Excel file</td><td>Promise&lt;any[]&gt;</td></tr>
                        <tr><td><code>loadFromYaml(path)</code></td><td>Load data from YAML file</td><td>Promise&lt;any[]&gt;</td></tr>
                        <tr><td><code>loadFromDatabase(query, conn)</code></td><td>Load data from database</td><td>Promise&lt;any[]&gt;</td></tr>
                        <tr><td><code>filterByTag(data, tag)</code></td><td>Filter data rows by tag</td><td>any[]</td></tr>
                        <tr><td><code>filterByEnvironment(data, env)</code></td><td>Filter by environment column</td><td>any[]</td></tr>
                        <tr><td><code>randomize(data)</code></td><td>Randomize data order</td><td>any[]</td></tr>
                        <tr><td><code>getRow(data, index)</code></td><td>Get specific row</td><td>any</td></tr>
                        <tr><td><code>cache(key, data)</code></td><td>Cache data for reuse</td><td>void</td></tr>
                        <tr><td><code>getCached(key)</code></td><td>Get cached data</td><td>any[]</td></tr>
                    </tbody>
                </table>

                <pre><code>// Spec Format - Data Provider
import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';
import { CSDataProvider } from '@mdakhan.mak/cs-playwright-test-framework/data';

describe('Data-Driven Tests with CSDataProvider', () => {

    test('Load data from multiple sources', async ({ reporter }) => {
        const dataProvider = CSDataProvider.getInstance();

        // Load from JSON
        const jsonData = await dataProvider.loadFromJson('./test-data/users.json');
        reporter.info(`Loaded ${jsonData.length} users from JSON`);

        // Load from CSV
        const csvData = await dataProvider.loadFromCsv('./test-data/products.csv', {
            headers: true,
            delimiter: ','
        });
        reporter.info(`Loaded ${csvData.length} products from CSV`);

        // Load from Excel
        const excelData = await dataProvider.loadFromExcel('./test-data/orders.xlsx', 'Sheet1');
        reporter.info(`Loaded ${excelData.length} orders from Excel`);

        // Filter by environment
        const qaData = dataProvider.filterByEnvironment(jsonData, 'qa');

        // Cache for reuse across tests
        dataProvider.cache('users', qaData);
    });

    test('Use cached data', async ({ reporter }) => {
        const dataProvider = CSDataProvider.getInstance();
        const users = dataProvider.getCached('users');

        for (const user of users) {
            reporter.info(`Testing with user: ${user.username}`);
        }
    });
});

// BDD Format with DataProvider
// Feature file
@data-driven
Feature: User Management
  Scenario Outline: Create user with different roles
    Given I login as admin
    When I create a user with role "&lt;role&gt;"
    Then the user should have "&lt;permissions&gt;" permissions

    @DataSource:test-data/roles.csv
    Examples:
      | role    | permissions |

// Step definition
@Given('I load test data from {string}')
async loadTestData(source: string) {
    const dataProvider = CSDataProvider.getInstance();
    const data = await dataProvider.loadFromCsv(source);
    this.ctx.set('testData', data);
}</code></pre>

                <h3>CSDataGenerator - Dynamic Test Data</h3>
                <p>Generate random, realistic test data using Faker.js integration.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Example Output</th></tr></thead>
                    <tbody>
                        <tr><td><code>person.firstName()</code></td><td>Generate first name</td><td>"John"</td></tr>
                        <tr><td><code>person.lastName()</code></td><td>Generate last name</td><td>"Smith"</td></tr>
                        <tr><td><code>person.fullName()</code></td><td>Generate full name</td><td>"John Smith"</td></tr>
                        <tr><td><code>internet.email()</code></td><td>Generate email address</td><td>"john.smith@gmail.com"</td></tr>
                        <tr><td><code>internet.userName()</code></td><td>Generate username</td><td>"john_smith123"</td></tr>
                        <tr><td><code>internet.password(len?)</code></td><td>Generate password</td><td>"xK9#mP2$"</td></tr>
                        <tr><td><code>phone.number(format?)</code></td><td>Generate phone number</td><td>"+1-555-123-4567"</td></tr>
                        <tr><td><code>address.streetAddress()</code></td><td>Generate street address</td><td>"123 Main St"</td></tr>
                        <tr><td><code>address.city()</code></td><td>Generate city name</td><td>"New York"</td></tr>
                        <tr><td><code>address.zipCode()</code></td><td>Generate ZIP code</td><td>"10001"</td></tr>
                        <tr><td><code>address.country()</code></td><td>Generate country</td><td>"United States"</td></tr>
                        <tr><td><code>company.name()</code></td><td>Generate company name</td><td>"Acme Corp"</td></tr>
                        <tr><td><code>finance.creditCardNumber()</code></td><td>Generate credit card</td><td>"4111111111111111"</td></tr>
                        <tr><td><code>date.past(years?)</code></td><td>Generate past date</td><td>Date object</td></tr>
                        <tr><td><code>date.future(years?)</code></td><td>Generate future date</td><td>Date object</td></tr>
                        <tr><td><code>string.uuid()</code></td><td>Generate UUID</td><td>"a1b2c3d4-..."</td></tr>
                        <tr><td><code>number.int(min, max)</code></td><td>Generate random integer</td><td>42</td></tr>
                        <tr><td><code>lorem.paragraph()</code></td><td>Generate paragraph text</td><td>"Lorem ipsum..."</td></tr>
                    </tbody>
                </table>

                <pre><code>// Spec Format - Data Generator
import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';
import { CSDataGenerator } from '@mdakhan.mak/cs-playwright-test-framework/data';

describe('Dynamic Data Generation', () => {

    test('Create user with generated data', async ({ registrationPage, reporter }) => {
        const gen = CSDataGenerator;

        // Generate realistic user data
        const userData = {
            firstName: gen.person.firstName(),
            lastName: gen.person.lastName(),
            email: gen.internet.email(),
            username: gen.internet.userName(),
            password: gen.internet.password(12),
            phone: gen.phone.number('+1-###-###-####'),
            address: {
                street: gen.address.streetAddress(),
                city: gen.address.city(),
                zip: gen.address.zipCode(),
                country: gen.address.country()
            }
        };

        reporter.info(`Creating user: ${userData.email}`);

        // Use page object methods instead of direct Playwright access
        await registrationPage.navigate();
        await registrationPage.firstNameField.fill(userData.firstName);
        await registrationPage.lastNameField.fill(userData.lastName);
        await registrationPage.emailField.fill(userData.email);
        await registrationPage.passwordField.fill(userData.password);
        await registrationPage.submitButton.click();
    });

    test('Generate financial test data', async ({ reporter }) => {
        const gen = CSDataGenerator;

        const orderData = {
            orderId: gen.string.uuid(),
            amount: gen.number.int(100, 10000) / 100,
            creditCard: gen.finance.creditCardNumber(),
            expiryDate: gen.date.future(2),
            cvv: gen.number.int(100, 999).toString()
        };

        reporter.info(`Order ID: ${orderData.orderId}`);
        reporter.info(`Amount: $${orderData.amount}`);
    });
});

// BDD Format
@When('I create a new employee with random data')
async createEmployeeWithRandomData() {
    const gen = CSDataGenerator;

    const employee = {
        name: gen.person.fullName(),
        email: gen.internet.email(),
        department: gen.helpers.arrayElement(['HR', 'IT', 'Sales', 'Marketing']),
        salary: gen.number.int(30000, 150000)
    };

    this.ctx.set('newEmployee', employee);
    CSReporter.info(`Generated employee: ${employee.name}`);
}</code></pre>
            </section>

            <!-- AUTHENTICATION -->
            <section id="authentication">
                <h2>Authentication - CSTokenManager</h2>

                <p>Manage authentication tokens, sessions, and credentials across tests.</p>

                <h3>CSTokenManager Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSTokenManager</td></tr>
                        <tr><td><code>setToken(name, token)</code></td><td>Store authentication token</td><td>void</td></tr>
                        <tr><td><code>getToken(name)</code></td><td>Retrieve stored token</td><td>string | null</td></tr>
                        <tr><td><code>removeToken(name)</code></td><td>Remove stored token</td><td>void</td></tr>
                        <tr><td><code>isTokenValid(name)</code></td><td>Check if token is valid/not expired</td><td>boolean</td></tr>
                        <tr><td><code>refreshToken(name, refreshFn)</code></td><td>Refresh expired token</td><td>Promise&lt;string&gt;</td></tr>
                        <tr><td><code>setTokenExpiry(name, expiry)</code></td><td>Set token expiration time</td><td>void</td></tr>
                        <tr><td><code>getAuthHeader(name)</code></td><td>Get Authorization header value</td><td>string</td></tr>
                        <tr><td><code>clearAllTokens()</code></td><td>Clear all stored tokens</td><td>void</td></tr>
                        <tr><td><code>saveToStorage()</code></td><td>Persist tokens to storage</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>loadFromStorage()</code></td><td>Load tokens from storage</td><td>Promise&lt;void&gt;</td></tr>
                    </tbody>
                </table>

                <pre><code>// Spec Format - Token Management
import { describe, test, beforeAll } from '@mdakhan.mak/cs-playwright-test-framework/spec';
import { CSTokenManager } from '@mdakhan.mak/cs-playwright-test-framework/auth';

describe('Authentication Tests', () => {
    let tokenManager: CSTokenManager;

    beforeAll(async ({ config }) => {
        tokenManager = CSTokenManager.getInstance();

        // Authenticate and store token
        const response = await fetch(`${config.get('API_URL')}/auth/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                username: config.get('API_USERNAME'),
                password: config.get('API_PASSWORD')
            })
        });

        const { accessToken, refreshToken, expiresIn } = await response.json();

        tokenManager.setToken('access', accessToken);
        tokenManager.setToken('refresh', refreshToken);
        tokenManager.setTokenExpiry('access', Date.now() + expiresIn * 1000);
    });

    test('Make authenticated API request', async ({ apiClient, reporter }) => {
        // Check if token is valid, refresh if needed
        if (!tokenManager.isTokenValid('access')) {
            await tokenManager.refreshToken('access', async () => {
                const refresh = tokenManager.getToken('refresh');
                const response = await fetch('/auth/refresh', {
                    method: 'POST',
                    body: JSON.stringify({ refreshToken: refresh })
                });
                return (await response.json()).accessToken;
            });
        }

        // Use token in request
        const response = await apiClient.get('/api/users', {
            headers: {
                'Authorization': tokenManager.getAuthHeader('access')
            }
        });

        reporter.pass('Authenticated request successful');
    });

    test('Store session across tests', async ({ browserManager }) => {
        // Save authentication state using browserManager
        const cookies = await browserManager.getCookies();
        tokenManager.setToken('cookies', JSON.stringify(cookies));

        // In another test, restore cookies
        const savedCookies = JSON.parse(tokenManager.getToken('cookies') || '[]');
        await browserManager.setCookies(savedCookies);
    });
});

// BDD Format
@Given('I am authenticated as {string}')
async authenticateAs(role: string) {
    const tokenManager = CSTokenManager.getInstance();
    const credentials = this.config.get(`${role.toUpperCase()}_CREDENTIALS`);

    const response = await this.apiClient.post('/auth/login', { body: credentials });
    tokenManager.setToken('access', response.data.token);

    CSReporter.info(`Authenticated as ${role}`);
}</code></pre>
            </section>

            <!-- PAGE DIAGNOSTICS -->
            <section id="diagnostics">
                <h2>Page Diagnostics - CSPageDiagnostics</h2>

                <p>Analyze page health, accessibility, performance, and detect common issues.</p>

                <h3>CSPageDiagnostics Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance(page)</code></td><td>Get instance for page</td><td>CSPageDiagnostics</td></tr>
                        <tr><td><code>runFullDiagnostics()</code></td><td>Run all diagnostic checks</td><td>DiagnosticsReport</td></tr>
                        <tr><td><code>checkAccessibility()</code></td><td>Run accessibility audit</td><td>AccessibilityResult[]</td></tr>
                        <tr><td><code>checkPerformance()</code></td><td>Check performance metrics</td><td>PerformanceMetrics</td></tr>
                        <tr><td><code>checkBrokenLinks()</code></td><td>Find broken links on page</td><td>BrokenLink[]</td></tr>
                        <tr><td><code>checkBrokenImages()</code></td><td>Find broken images</td><td>BrokenImage[]</td></tr>
                        <tr><td><code>checkConsoleErrors()</code></td><td>Check for console errors</td><td>ConsoleError[]</td></tr>
                        <tr><td><code>checkNetworkErrors()</code></td><td>Check for failed requests</td><td>NetworkError[]</td></tr>
                        <tr><td><code>getPageMetrics()</code></td><td>Get page size/load metrics</td><td>PageMetrics</td></tr>
                        <tr><td><code>analyzeDOM()</code></td><td>Analyze DOM structure</td><td>DOMAnalysis</td></tr>
                        <tr><td><code>generateReport()</code></td><td>Generate HTML report</td><td>string</td></tr>
                    </tbody>
                </table>

                <pre><code>// Spec Format - Page Diagnostics
import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';
import { CSPageDiagnostics } from '@mdakhan.mak/cs-playwright-test-framework/diagnostics';

describe('Page Health Checks', () => {

    test('Run full page diagnostics', async ({ dashboardPage, browserManager, reporter }) => {
        await dashboardPage.navigate();

        const diagnostics = CSPageDiagnostics.getInstance(browserManager.getPage());
        const report = await diagnostics.runFullDiagnostics();

        reporter.info(`Page score: ${report.overallScore}/100`);
        reporter.info(`Accessibility issues: ${report.accessibility.issues.length}`);
        reporter.info(`Performance score: ${report.performance.score}`);
        reporter.info(`Broken links: ${report.brokenLinks.length}`);
        reporter.info(`Console errors: ${report.consoleErrors.length}`);

        // Fail if critical issues found
        expect(report.accessibility.criticalIssues).toBe(0);
        expect(report.consoleErrors.filter(e => e.level === 'error')).toHaveLength(0);
    });

    test('Check accessibility compliance', async ({ dashboardPage, browserManager, reporter }) => {
        await dashboardPage.navigate();

        const diagnostics = CSPageDiagnostics.getInstance(browserManager.getPage());
        const issues = await diagnostics.checkAccessibility();

        const critical = issues.filter(i => i.impact === 'critical');
        const serious = issues.filter(i => i.impact === 'serious');

        reporter.info(`Critical: ${critical.length}, Serious: ${serious.length}`);

        for (const issue of critical) {
            reporter.warn(`[A11Y Critical] ${issue.description}`);
            reporter.warn(`  Selector: ${issue.selector}`);
            reporter.warn(`  Fix: ${issue.help}`);
        }

        expect(critical.length).toBe(0);
    });

    test('Check for broken resources', async ({ dashboardPage, browserManager, reporter }) => {
        await dashboardPage.navigate();

        const diagnostics = CSPageDiagnostics.getInstance(browserManager.getPage());

        const brokenLinks = await diagnostics.checkBrokenLinks();
        const brokenImages = await diagnostics.checkBrokenImages();

        for (const link of brokenLinks) {
            reporter.warn(`Broken link: ${link.url} (status: ${link.status})`);
        }

        for (const img of brokenImages) {
            reporter.warn(`Broken image: ${img.src}`);
        }

        expect(brokenLinks.length).toBe(0);
        expect(brokenImages.length).toBe(0);
    });
});

// BDD Format
@Then('the page should have no critical accessibility issues')
async checkAccessibility() {
    const diagnostics = CSPageDiagnostics.getInstance(this.browserManager.getPage());
    const issues = await diagnostics.checkAccessibility();

    const critical = issues.filter(i => i.impact === 'critical');

    if (critical.length > 0) {
        critical.forEach(i => CSReporter.warn(`A11Y: ${i.description}`));
        throw new Error(`Found ${critical.length} critical accessibility issues`);
    }

    CSReporter.pass('No critical accessibility issues found');
}</code></pre>
            </section>

            <!-- ADO INTEGRATION -->
            <section id="ado-integration">
                <h2>ADO Integration</h2>

                <p>The framework provides comprehensive Azure DevOps (ADO) Test Plans integration with automatic test result publishing, artifact uploads, and bug creation.</p>

                <h3>Complete Environment Variables</h3>

                <h4>Core Configuration (Required)</h4>
                <table>
                    <thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>ADO_INTEGRATION_ENABLED</code></td><td>boolean</td><td>Master switch - enables/disables all ADO integration</td></tr>
                        <tr><td><code>ADO_ORGANIZATION</code></td><td>string</td><td>ADO organization name (e.g., "myorg")</td></tr>
                        <tr><td><code>ADO_PROJECT</code></td><td>string</td><td>ADO project name</td></tr>
                        <tr><td><code>ADO_PAT</code></td><td>string</td><td>Personal Access Token for authentication</td></tr>
                    </tbody>
                </table>

                <h4>Test Configuration</h4>
                <table>
                    <thead><tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>ADO_TEST_PLAN_ID</code></td><td>number</td><td>-</td><td>Default test plan ID (fallback if not in tags)</td></tr>
                        <tr><td><code>ADO_TEST_SUITE_ID</code></td><td>number</td><td>-</td><td>Default test suite ID (fallback if not in tags)</td></tr>
                        <tr><td><code>ADO_BUILD_ID</code></td><td>string</td><td>-</td><td>Build ID for linking</td></tr>
                        <tr><td><code>ADO_RELEASE_ID</code></td><td>string</td><td>-</td><td>Release ID for linking</td></tr>
                        <tr><td><code>ADO_ENVIRONMENT</code></td><td>string</td><td>QA</td><td>Environment name (used in test run naming)</td></tr>
                        <tr><td><code>ADO_RUN_NAME</code></td><td>string</td><td>PTF Run - {date}</td><td>Test run name template</td></tr>
                        <tr><td><code>ADO_API_VERSION</code></td><td>string</td><td>7.0</td><td>ADO REST API version</td></tr>
                    </tbody>
                </table>

                <h4>Artifact Upload Settings</h4>
                <table>
                    <thead><tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>ADO_UPLOAD_ATTACHMENTS</code></td><td>boolean</td><td>true</td><td>Upload all attachment types</td></tr>
                        <tr><td><code>ADO_UPLOAD_SCREENSHOTS</code></td><td>boolean</td><td>true</td><td>Upload screenshots on failure</td></tr>
                        <tr><td><code>ADO_UPLOAD_VIDEOS</code></td><td>boolean</td><td>true</td><td>Upload video recordings</td></tr>
                        <tr><td><code>ADO_UPLOAD_LOGS</code></td><td>boolean</td><td>true</td><td>Upload test execution logs</td></tr>
                        <tr><td><code>ADO_UPLOAD_HAR</code></td><td>boolean</td><td>false</td><td>Upload HAR (HTTP Archive) files</td></tr>
                        <tr><td><code>ADO_UPLOAD_TRACES</code></td><td>boolean</td><td>false</td><td>Upload Playwright traces</td></tr>
                    </tbody>
                </table>

                <h4>Bug Creation Settings</h4>
                <table>
                    <thead><tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>ADO_CREATE_BUGS_ON_FAILURE</code></td><td>boolean</td><td>false</td><td>Auto-create bugs for failed tests</td></tr>
                        <tr><td><code>ADO_BUG_TITLE_TEMPLATE</code></td><td>string</td><td>Test Failed: {testName}</td><td>Bug title with {testName}, {date} placeholders</td></tr>
                        <tr><td><code>ADO_BUG_AREA_PATH</code></td><td>string</td><td>{project}</td><td>ADO bug area path</td></tr>
                        <tr><td><code>ADO_BUG_ITERATION_PATH</code></td><td>string</td><td>{project}</td><td>ADO bug iteration path</td></tr>
                        <tr><td><code>ADO_BUG_PRIORITY</code></td><td>number</td><td>2</td><td>Bug priority (1-4)</td></tr>
                        <tr><td><code>ADO_BUG_SEVERITY</code></td><td>string</td><td>3 - Medium</td><td>Bug severity</td></tr>
                    </tbody>
                </table>

                <h4>API and Retry Settings</h4>
                <table>
                    <thead><tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>ADO_API_TIMEOUT</code></td><td>number</td><td>30000</td><td>API request timeout (ms)</td></tr>
                        <tr><td><code>ADO_API_RETRY_COUNT</code></td><td>number</td><td>3</td><td>Number of retry attempts</td></tr>
                        <tr><td><code>ADO_API_RETRY_DELAY</code></td><td>number</td><td>2000</td><td>Delay between retries (ms)</td></tr>
                    </tbody>
                </table>

                <h4>Proxy Configuration</h4>
                <table>
                    <thead><tr><th>Variable</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>ADO_PROXY_ENABLED</code></td><td>boolean</td><td>false</td><td>Enable proxy for ADO API calls</td></tr>
                        <tr><td><code>ADO_PROXY_PROTOCOL</code></td><td>string</td><td>http</td><td>Proxy protocol: http, https, or socks5</td></tr>
                        <tr><td><code>ADO_PROXY_HOST</code></td><td>string</td><td>-</td><td>Proxy server hostname</td></tr>
                        <tr><td><code>ADO_PROXY_PORT</code></td><td>number</td><td>8080</td><td>Proxy server port</td></tr>
                        <tr><td><code>ADO_PROXY_AUTH_REQUIRED</code></td><td>boolean</td><td>false</td><td>Proxy requires authentication</td></tr>
                        <tr><td><code>ADO_PROXY_USERNAME</code></td><td>string</td><td>-</td><td>Proxy username</td></tr>
                        <tr><td><code>ADO_PROXY_PASSWORD</code></td><td>string</td><td>-</td><td>Proxy password</td></tr>
                    </tbody>
                </table>

                <pre><code># Complete ADO Configuration Example
ADO_INTEGRATION_ENABLED=true
ADO_ORGANIZATION=myorg
ADO_PROJECT=MyProject
ADO_PAT=your-personal-access-token

# Default test plan/suite (fallback if not in tags)
ADO_TEST_PLAN_ID=417
ADO_TEST_SUITE_ID=418

# Test run naming
ADO_ENVIRONMENT=QA
ADO_RUN_NAME=Automated Test Run - {date} {time}

# Artifact uploads
ADO_UPLOAD_SCREENSHOTS=true
ADO_UPLOAD_VIDEOS=true
ADO_UPLOAD_LOGS=true

# Bug creation
ADO_CREATE_BUGS_ON_FAILURE=true
ADO_BUG_TITLE_TEMPLATE=Test Failed: {testName}
ADO_BUG_PRIORITY=2

# Proxy (if required)
ADO_PROXY_ENABLED=true
ADO_PROXY_HOST=proxy.company.com
ADO_PROXY_PORT=8080</code></pre>

                <h3>ADO Tag Formats</h3>

                <p>The framework supports these ADO tag formats:</p>

                <table>
                    <thead><tr><th>Tag Type</th><th>Single Format</th><th>Multiple Format</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td>Test Plan</td><td><code>@TestPlanId:417</code></td><td>-</td><td>ADO Test Plan ID</td></tr>
                        <tr><td>Test Suite</td><td><code>@TestSuiteId:418</code></td><td>-</td><td>ADO Test Suite ID</td></tr>
                        <tr><td>Test Case</td><td><code>@TestCaseId:419</code></td><td><code>@TestCaseId:{419,420,421}</code></td><td>One or more Test Case IDs</td></tr>
                        <tr><td>Build</td><td><code>@BuildId:123</code></td><td>-</td><td>Build reference (optional)</td></tr>
                        <tr><td>Release</td><td><code>@ReleaseId:456</code></td><td>-</td><td>Release reference (optional)</td></tr>
                    </tbody>
                </table>

                <h3>Tag Priority Hierarchy</h3>

                <p>ADO tags are resolved with a <strong>three-level priority system</strong>:</p>

                <div class="info-box note">
                    <strong>Priority Order (Highest to Lowest):</strong>
                    <ol>
                        <li><strong>Test/Scenario Level</strong> - Tags on individual test() or Scenario</li>
                        <li><strong>Describe/Feature Level</strong> - Tags on describe() block or Feature (innermost first for nested describes)</li>
                        <li><strong>Environment Level</strong> - ADO_TEST_PLAN_ID, ADO_TEST_SUITE_ID config values</li>
                    </ol>
                    <p><em>Note: TestCaseId is ONLY valid at test/scenario level (not describe/feature level).</em></p>
                </div>

                <h4>Priority Resolution Examples</h4>

                <h5>Example 1: Spec Format - Test Level Override</h5>
                <pre><code>describe('Login Tests', {
    tags: '@TestPlanId:100 @TestSuiteId:200'  // Describe level
}, () => {
    test('user login', {
        tags: '@TestCaseId:301 @TestPlanId:999'  // Test level overrides
    }, async ({ page }) => {
        // RESOLVED:
        // - TestPlanId: 999     (from test, overrides describe's 100)
        // - TestSuiteId: 200    (from describe, no test override)
        // - TestCaseId: 301     (from test only - required here)
    });
});</code></pre>

                <h5>Example 2: Spec Format - Nested Describes (Innermost Wins)</h5>
                <pre><code>describe('E-Commerce', {
    tags: '@TestPlanId:300 @TestSuiteId:400'
}, () => {
    describe('Payment', {
        tags: '@TestSuiteId:401'  // Override suite
    }, () => {
        describe('Credit Card', {
            tags: '@TestSuiteId:402'  // Further override
        }, () => {
            test('Process payment', {
                tags: '@TestCaseId:500'
            }, async ({ page }) => {
                // RESOLVED:
                // - TestPlanId: 300     (from outermost describe)
                // - TestSuiteId: 402    (from INNERMOST describe)
                // - TestCaseId: 500     (from test)
            });
        });
    });
});</code></pre>

                <h5>Example 3: Spec Format - Environment Level Fallback</h5>
                <pre><code>// .env file
ADO_TEST_PLAN_ID=500
ADO_TEST_SUITE_ID=600

// spec file - no plan/suite tags
describe('Admin Panel', {
    tags: '@admin'  // Only custom tag
}, () => {
    test('Update settings', {
        tags: '@TestCaseId:700'  // Only test case
    }, async ({ page }) => {
        // RESOLVED:
        // - TestPlanId: 500     (from .env - fallback)
        // - TestSuiteId: 600    (from .env - fallback)
        // - TestCaseId: 700     (from test)
    });
});</code></pre>

                <h5>Example 4: BDD Format - Scenario Overrides Feature</h5>
                <pre><code>@TestPlanId:417 @TestSuiteId:418
Feature: Login Feature

  @TestCaseId:419
  Scenario: Valid login with default plan/suite
    Given I login with valid credentials
    # Uses: Plan 417, Suite 418, Case 419

  @TestPlanId:500 @TestSuiteId:501 @TestCaseId:420
  Scenario: Login with different plan/suite
    Given I login with credentials
    # Uses: Plan 500, Suite 501, Case 420 (all overridden)

  @TestCaseId:{421,422,423}
  Scenario: Login mapped to multiple test cases
    Given I login
    # Uses: Plan 417, Suite 418, Cases [421, 422, 423]</code></pre>

                <h3>Multiple Test Case IDs</h3>

                <p>Map a single test to multiple ADO Test Cases using curly brace syntax:</p>

                <pre><code>// Spec format - multiple test cases
test('Critical login flow', {
    tags: '@TestCaseId:{415,416,417}'  // Maps to 3 test cases
}, async ({ loginPage }) => {
    await loginPage.login('admin', 'password');
    await loginPage.verifySuccess();
});

// BDD format - multiple test cases
@TestCaseId:{415,416,417}
Scenario: Critical login flow
  Given I login with valid credentials
  Then I should see the dashboard</code></pre>

                <div class="info-box tip">
                    <strong>How Multiple Test Cases Work:</strong>
                    <ul>
                        <li>The test runs once, but results are published to ALL mapped test cases</li>
                        <li>All test cases receive the same pass/fail outcome</li>
                        <li>All test cases receive the same duration, error message, and attachments</li>
                        <li>Useful for mapping a single automation script to multiple manual test cases</li>
                    </ul>
                </div>

                <h3>Data-Driven Tests with ADO</h3>

                <p>For data-driven tests, each iteration is tracked separately but published as a single aggregated result:</p>

                <pre><code>describe('Login Tests', {
    tags: '@TestPlanId:100 @TestSuiteId:200',
    dataSource: {
        type: 'json',
        source: 'test/data/users.json'
    }
}, () => {
    test('Login with {username}', {
        tags: '@TestCaseId:301'
    }, async ({ loginPage, data }) => {
        await loginPage.login(data.username, data.password);
        await loginPage.verifySuccess();
    });
});

// Result in ADO:
// - Single test result with aggregated status
// - Comment shows all iteration outcomes:
//   "Data-Driven Test Results (3 iterations)
//    Overall Status: Passed
//
//    Iteration 1 [username:user1]: âœ… Passed
//    Iteration 2 [username:user2]: âœ… Passed
//    Iteration 3 [username:admin]: âœ… Passed"</code></pre>

                <h3>ADO Publishing Flow</h3>

                <pre><code>Test Execution Flow:
â”‚
â”œâ”€ initialize() â†’ Load ADO configuration, validate credentials
â”‚
â”œâ”€ collectScenarios() â†’ Extract ADO tags from all tests
â”‚  â””â”€ For each test: Extract TestPlanId, TestSuiteId, TestCaseId
â”‚
â”œâ”€ collectTestPoints() â†’ Fetch test points from ADO API
â”‚  â””â”€ Cache test points by plan/suite for performance
â”‚
â”œâ”€ beforeAllTests() â†’ Create test run(s) in ADO
â”‚  â””â”€ One test run per unique TestPlanId
â”‚
â”œâ”€ During Execution:
â”‚  â”œâ”€ Sequential Mode: Publish results immediately after each test
â”‚  â””â”€ Parallel Mode: Queue results, batch publish at end
â”‚
â””â”€ afterAllTests()
   â”œâ”€ Publish any remaining results
   â”œâ”€ Upload artifacts (screenshots, videos, logs)
   â”œâ”€ Create bugs for failures (if enabled)
   â””â”€ Complete test run(s) in ADO</code></pre>
            </section>

            <!-- PERFORMANCE TESTING -->
            <section id="performance-testing">
                <h2>Performance Testing</h2>

                <p>The framework provides comprehensive performance testing capabilities including load testing, Core Web Vitals monitoring, and performance metrics collection.</p>

                <h3>CSPerformanceTestRunner Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSPerformanceTestRunner</td></tr>
                        <tr><td><code>runScenario(scenario)</code></td><td>Run performance test scenario</td><td>PerformanceResult</td></tr>
                        <tr><td><code>runLoadTest(config)</code></td><td>Run load test with virtual users</td><td>LoadTestResult</td></tr>
                        <tr><td><code>runStressTest(config)</code></td><td>Run stress test to find limits</td><td>StressTestResult</td></tr>
                        <tr><td><code>runSpikeTest(config)</code></td><td>Test sudden traffic spikes</td><td>SpikeTestResult</td></tr>
                        <tr><td><code>runSoakTest(config)</code></td><td>Long-running endurance test</td><td>SoakTestResult</td></tr>
                        <tr><td><code>getMetrics()</code></td><td>Get collected metrics</td><td>PerformanceMetrics</td></tr>
                        <tr><td><code>getSummary()</code></td><td>Get test summary</td><td>PerformanceSummary</td></tr>
                        <tr><td><code>exportResults(format, path)</code></td><td>Export results to file</td><td>void</td></tr>
                    </tbody>
                </table>

                <h3>CSPerformanceMonitor Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSPerformanceMonitor</td></tr>
                        <tr><td><code>startMonitoring(testName)</code></td><td>Start performance monitoring</td><td>void</td></tr>
                        <tr><td><code>stopMonitoring()</code></td><td>Stop monitoring and get report</td><td>MonitoringReport</td></tr>
                        <tr><td><code>measurePageLoad(page, url)</code></td><td>Measure page load metrics</td><td>PageLoadMetrics</td></tr>
                        <tr><td><code>measureLCP(page)</code></td><td>Measure Largest Contentful Paint</td><td>number (ms)</td></tr>
                        <tr><td><code>measureFID(page)</code></td><td>Measure First Input Delay</td><td>number (ms)</td></tr>
                        <tr><td><code>measureCLS(page)</code></td><td>Measure Cumulative Layout Shift</td><td>number</td></tr>
                        <tr><td><code>measureTTFB(page)</code></td><td>Measure Time to First Byte</td><td>number (ms)</td></tr>
                        <tr><td><code>measureFCP(page)</code></td><td>Measure First Contentful Paint</td><td>number (ms)</td></tr>
                        <tr><td><code>measureTTI(page)</code></td><td>Measure Time to Interactive</td><td>number (ms)</td></tr>
                        <tr><td><code>setThresholds(thresholds)</code></td><td>Set performance thresholds</td><td>void</td></tr>
                        <tr><td><code>getViolations()</code></td><td>Get threshold violations</td><td>Violation[]</td></tr>
                        <tr><td><code>captureMemoryUsage()</code></td><td>Capture memory usage snapshot</td><td>MemoryInfo</td></tr>
                        <tr><td><code>captureNetworkTimings()</code></td><td>Get network timing data</td><td>NetworkTiming[]</td></tr>
                        <tr><td><code>generateReport()</code></td><td>Generate detailed report</td><td>PerformanceReport</td></tr>
                    </tbody>
                </table>

                <h4>Core Web Vitals Thresholds</h4>
                <table>
                    <thead><tr><th>Metric</th><th>Good</th><th>Needs Improvement</th><th>Poor</th></tr></thead>
                    <tbody>
                        <tr><td>LCP (Largest Contentful Paint)</td><td>&lt;2.5s</td><td>2.5s - 4s</td><td>&gt;4s</td></tr>
                        <tr><td>FID (First Input Delay)</td><td>&lt;100ms</td><td>100ms - 300ms</td><td>&gt;300ms</td></tr>
                        <tr><td>CLS (Cumulative Layout Shift)</td><td>&lt;0.1</td><td>0.1 - 0.25</td><td>&gt;0.25</td></tr>
                        <tr><td>TTFB (Time to First Byte)</td><td>&lt;200ms</td><td>200ms - 500ms</td><td>&gt;500ms</td></tr>
                        <tr><td>FCP (First Contentful Paint)</td><td>&lt;1.8s</td><td>1.8s - 3s</td><td>&gt;3s</td></tr>
                        <tr><td>TTI (Time to Interactive)</td><td>&lt;3.8s</td><td>3.8s - 7.3s</td><td>&gt;7.3s</td></tr>
                    </tbody>
                </table>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';

describe('Performance Testing', () => {

    test('Measure page load Core Web Vitals', async ({ page, performanceMonitor }) => {
        await performanceMonitor.startMonitoring('Homepage Performance');

        // Set thresholds for validation
        performanceMonitor.setThresholds({
            lcp: 2500,    // 2.5 seconds
            fid: 100,     // 100ms
            cls: 0.1,     // Layout shift score
            ttfb: 200,    // 200ms
            fcp: 1800     // 1.8 seconds
        });

        // Navigate and measure
        const metrics = await performanceMonitor.measurePageLoad(page, 'https://example.com');

        console.log('Core Web Vitals:');
        console.log(`  LCP: ${metrics.lcp}ms`);
        console.log(`  FID: ${metrics.fid}ms`);
        console.log(`  CLS: ${metrics.cls}`);
        console.log(`  TTFB: ${metrics.ttfb}ms`);
        console.log(`  FCP: ${metrics.fcp}ms`);
        console.log(`  TTI: ${metrics.tti}ms`);

        // Check for violations
        const violations = performanceMonitor.getViolations();
        if (violations.length > 0) {
            console.warn('Performance violations:');
            violations.forEach(v => {
                console.warn(`  ${v.metric}: ${v.actual} (threshold: ${v.threshold})`);
            });
        }

        const report = await performanceMonitor.stopMonitoring();
        expect(violations.length).toBe(0);
    });

    test('Run API load test', async ({ performanceRunner, reporter }) => {
        const result = await performanceRunner.runLoadTest({
            name: 'API Load Test',
            virtualUsers: 50,
            duration: 60000,       // 1 minute
            rampUpTime: 10000,     // 10 seconds ramp-up
            requests: [
                {
                    url: 'https://api.example.com/users',
                    method: 'GET',
                    headers: { 'Authorization': 'Bearer token' }
                },
                {
                    url: 'https://api.example.com/products',
                    method: 'GET'
                }
            ],
            thresholds: {
                avgResponseTime: 500,   // 500ms average
                p95ResponseTime: 1000,  // 1s for 95th percentile
                errorRate: 0.01,        // 1% max error rate
                throughput: 100         // 100 req/s minimum
            }
        });

        reporter.info(`Total Requests: ${result.summary.totalRequests}`);
        reporter.info(`Avg Response Time: ${result.summary.avgResponseTime}ms`);
        reporter.info(`P95 Response Time: ${result.summary.p95ResponseTime}ms`);
        reporter.info(`Error Rate: ${(result.summary.errorRate * 100).toFixed(2)}%`);
        reporter.info(`Throughput: ${result.summary.throughput} req/s`);

        expect(result.passed).toBe(true);
    });

    test('Stress test to find breaking point', async ({ performanceRunner }) => {
        const result = await performanceRunner.runStressTest({
            name: 'Find Breaking Point',
            startUsers: 10,
            maxUsers: 500,
            stepUsers: 20,
            stepDuration: 30000,    // 30 seconds per step
            request: {
                url: 'https://api.example.com/heavy-operation',
                method: 'POST',
                body: JSON.stringify({ data: 'test' })
            },
            breakingPointThreshold: {
                errorRate: 0.10,        // Stop at 10% errors
                responseTime: 5000      // Or 5s response time
            }
        });

        console.log(`Breaking point: ${result.breakingPoint.users} users`);
        console.log(`Max successful throughput: ${result.maxThroughput} req/s`);
    });

    test('Memory leak detection', async ({ navigate, performanceMonitor, reporter }) => {
        await performanceMonitor.startMonitoring('Memory Test');

        const initialMemory = await performanceMonitor.captureMemoryUsage();

        // Perform repeated actions using framework methods
        const loadMoreBtn = CSElementFactory.createByCSS('.load-more', 'Load more button');

        for (let i = 0; i < 10; i++) {
            await navigate('https://example.com');
            await loadMoreBtn.click();
            await CSSmartWait.waitForPageStable();  // Use smart wait instead of arbitrary timeout
        }

        const finalMemory = await performanceMonitor.captureMemoryUsage();
        const memoryGrowth = finalMemory.usedJSHeapSize - initialMemory.usedJSHeapSize;

        reporter.info(`Memory growth: ${(memoryGrowth / 1024 / 1024).toFixed(2)} MB`);

        // Alert if memory grew more than 50MB
        expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024);
    });
});</code></pre>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: performance.feature
@performance
Feature: Performance Testing

  @web-vitals
  Scenario: Homepage meets Core Web Vitals thresholds
    Given I have started performance monitoring
    When I navigate to the homepage
    Then LCP should be less than 2500ms
    And FID should be less than 100ms
    And CLS should be less than 0.1

  @load-test
  Scenario: API handles expected load
    Given I configure a load test with 50 virtual users
    When I run the load test for 60 seconds
    Then average response time should be under 500ms
    And error rate should be under 1%

// Step definitions: performance.steps.ts
import { Given, When, Then, StepClass } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSPerformanceMonitor } from '@mdakhan.mak/cs-playwright-test-framework/monitoring';
import { CSPerformanceTestRunner } from '@mdakhan.mak/cs-playwright-test-framework/performance';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

@StepClass()
export class PerformanceSteps {
    private monitor = CSPerformanceMonitor.getInstance();
    private runner = CSPerformanceTestRunner.getInstance();

    @Given('I have started performance monitoring')
    async startMonitoring() {
        await this.monitor.startMonitoring('Performance Test');
        CSReporter.info('Performance monitoring started');
    }

    @Given('I configure a load test with {int} virtual users')
    async configureLoadTest(users: number) {
        this.ctx.set('virtualUsers', users);
        CSReporter.info(`Load test configured with ${users} users`);
    }

    @When('I navigate to the homepage')
    async navigateHome() {
        const metrics = await this.monitor.measurePageLoad(this.page, this.config.get('BASE_URL'));
        this.ctx.set('pageMetrics', metrics);
        CSReporter.info(`Page loaded - LCP: ${metrics.lcp}ms, CLS: ${metrics.cls}`);
    }

    @When('I run the load test for {int} seconds')
    async runLoadTest(durationSeconds: number) {
        const users = this.ctx.get('virtualUsers');

        const result = await this.runner.runLoadTest({
            name: 'API Load Test',
            virtualUsers: users,
            duration: durationSeconds * 1000,
            requests: [{
                url: `${this.config.get('API_BASE_URL')}/users`,
                method: 'GET'
            }]
        });

        this.ctx.set('loadTestResult', result);
        CSReporter.info(`Load test complete: ${result.summary.totalRequests} requests`);
    }

    @Then('LCP should be less than {int}ms')
    async verifyLCP(threshold: number) {
        const metrics = this.ctx.get('pageMetrics');
        expect(metrics.lcp).toBeLessThan(threshold);
        CSReporter.pass(`LCP ${metrics.lcp}ms < ${threshold}ms threshold`);
    }

    @Then('FID should be less than {int}ms')
    async verifyFID(threshold: number) {
        const metrics = this.ctx.get('pageMetrics');
        expect(metrics.fid).toBeLessThan(threshold);
        CSReporter.pass(`FID ${metrics.fid}ms < ${threshold}ms threshold`);
    }

    @Then('CLS should be less than {float}')
    async verifyCLS(threshold: number) {
        const metrics = this.ctx.get('pageMetrics');
        expect(metrics.cls).toBeLessThan(threshold);
        CSReporter.pass(`CLS ${metrics.cls} < ${threshold} threshold`);
    }

    @Then('average response time should be under {int}ms')
    async verifyAvgResponseTime(threshold: number) {
        const result = this.ctx.get('loadTestResult');
        expect(result.summary.avgResponseTime).toBeLessThan(threshold);
        CSReporter.pass(`Avg response ${result.summary.avgResponseTime}ms < ${threshold}ms`);
    }

    @Then('error rate should be under {int}%')
    async verifyErrorRate(threshold: number) {
        const result = this.ctx.get('loadTestResult');
        const errorPercent = result.summary.errorRate * 100;
        expect(errorPercent).toBeLessThan(threshold);
        CSReporter.pass(`Error rate ${errorPercent.toFixed(2)}% < ${threshold}%`);
    }
}</code></pre>
            </section>

            <!-- VISUAL TESTING -->
            <section id="visual-testing">
                <h2>Visual Testing - CSVisualTesting</h2>

                <p>CSVisualTesting provides pixel-perfect visual regression testing with baseline management, diff generation, and customizable comparison thresholds.</p>

                <h3>CSVisualTesting Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSVisualTesting</td></tr>
                        <tr><td><code>captureScreenshot(page, options)</code></td><td>Capture screenshot</td><td>string (path)</td></tr>
                        <tr><td><code>captureFullPage(page, options)</code></td><td>Capture full page screenshot</td><td>string (path)</td></tr>
                        <tr><td><code>captureElement(element, options)</code></td><td>Capture element screenshot</td><td>string (path)</td></tr>
                        <tr><td><code>compareWithBaseline(name, options)</code></td><td>Compare with baseline image</td><td>ComparisonResult</td></tr>
                        <tr><td><code>updateBaseline(name)</code></td><td>Update baseline with current</td><td>void</td></tr>
                        <tr><td><code>addIgnoreRegion(name, region)</code></td><td>Add region to ignore in comparison</td><td>void</td></tr>
                        <tr><td><code>addIgnoreSelector(name, selector)</code></td><td>Ignore element by selector</td><td>void</td></tr>
                        <tr><td><code>clearIgnoreRegions(name)</code></td><td>Clear all ignore regions</td><td>void</td></tr>
                        <tr><td><code>setBaselineDir(path)</code></td><td>Set baseline directory</td><td>void</td></tr>
                        <tr><td><code>setDiffDir(path)</code></td><td>Set diff output directory</td><td>void</td></tr>
                        <tr><td><code>setThreshold(threshold)</code></td><td>Set default comparison threshold</td><td>void</td></tr>
                        <tr><td><code>listBaselines()</code></td><td>List all baseline images</td><td>string[]</td></tr>
                        <tr><td><code>deleteBaseline(name)</code></td><td>Delete a baseline image</td><td>void</td></tr>
                        <tr><td><code>generateReport()</code></td><td>Generate visual test report</td><td>VisualReport</td></tr>
                        <tr><td><code>getComparisonHistory()</code></td><td>Get comparison history</td><td>ComparisonEntry[]</td></tr>
                    </tbody>
                </table>

                <h4>Comparison Options</h4>
                <table>
                    <thead><tr><th>Option</th><th>Type</th><th>Description</th><th>Default</th></tr></thead>
                    <tbody>
                        <tr><td>threshold</td><td>number</td><td>Allowed diff percentage (0-1)</td><td>0.01 (1%)</td></tr>
                        <tr><td>maxDiffPixels</td><td>number</td><td>Max different pixels allowed</td><td>100</td></tr>
                        <tr><td>maxDiffPixelRatio</td><td>number</td><td>Max pixel diff ratio (0-1)</td><td>undefined</td></tr>
                        <tr><td>antialiasing</td><td>boolean</td><td>Ignore antialiasing differences</td><td>true</td></tr>
                        <tr><td>animations</td><td>'disabled'|'allow'</td><td>Handle CSS animations</td><td>'disabled'</td></tr>
                        <tr><td>scale</td><td>'css'|'device'</td><td>Screenshot scale mode</td><td>'css'</td></tr>
                    </tbody>
                </table>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';

describe('Visual Regression Tests', () => {

    test('Homepage visual snapshot', async ({ homePage, browserManager, visualTesting }) => {
        await homePage.navigate();
        await homePage.waitForPageLoad();

        // Capture and compare using browserManager to get page
        await visualTesting.captureScreenshot(browserManager.getPage(), { name: 'homepage' });
        const result = await visualTesting.compareWithBaseline('homepage', {
            threshold: 0.02,        // 2% tolerance
            maxDiffPixels: 500
        });

        if (!result.passed) {
            console.log(`Diff: ${result.diffPercentage.toFixed(2)}%`);
            console.log(`Diff image: ${result.diffImage}`);
        }

        expect(result.passed).toBe(true);
    });

    test('Login page with ignored regions', async ({ loginPage, browserManager, visualTesting }) => {
        await loginPage.navigate();

        // Ignore dynamic elements
        visualTesting.addIgnoreRegion('login-page', {
            x: 10, y: 10, width: 100, height: 30  // Ignore timestamp area
        });
        visualTesting.addIgnoreSelector('login-page', '.dynamic-ad');
        visualTesting.addIgnoreSelector('login-page', '.user-avatar');

        await visualTesting.captureScreenshot(browserManager.getPage(), { name: 'login-page' });
        const result = await visualTesting.compareWithBaseline('login-page');

        expect(result.passed).toBe(true);
    });

    test('Full page comparison', async ({ productsPage, browserManager, visualTesting }) => {
        await productsPage.navigate();

        // Capture full scrollable page
        await visualTesting.captureFullPage(browserManager.getPage(), {
            name: 'products-full-page',
            animations: 'disabled'  // Disable CSS animations for stable capture
        });

        const result = await visualTesting.compareWithBaseline('products-full-page', {
            threshold: 0.05  // 5% tolerance for full page
        });

        expect(result.passed).toBe(true);
    });

    test('Component-level visual testing', async ({ homePage, visualTesting }) => {
        await homePage.navigate();

        // Test individual components using CSWebElement
        await visualTesting.captureElement(homePage.headerElement, { name: 'header-component' });
        await visualTesting.captureElement(homePage.footerElement, { name: 'footer-component' });
        await visualTesting.captureElement(homePage.sidebarElement, { name: 'sidebar-component' });

        const headerResult = await visualTesting.compareWithBaseline('header-component');
        const footerResult = await visualTesting.compareWithBaseline('footer-component');
        const sidebarResult = await visualTesting.compareWithBaseline('sidebar-component');

        expect(headerResult.passed).toBe(true);
        expect(footerResult.passed).toBe(true);
        expect(sidebarResult.passed).toBe(true);
    });

    test('Responsive visual testing', async ({ homePage, browserManager, visualTesting }) => {
        const viewports = [
            { width: 1920, height: 1080, name: 'desktop' },
            { width: 768, height: 1024, name: 'tablet' },
            { width: 375, height: 667, name: 'mobile' }
        ];

        for (const viewport of viewports) {
            // Use CSBasePage methods for viewport and navigation
            await homePage.setViewportSize(viewport.width, viewport.height);
            await homePage.navigate();
            await homePage.waitForPageLoad();

            await visualTesting.captureScreenshot(browserManager.getPage(), {
                name: `homepage-${viewport.name}`
            });

            const result = await visualTesting.compareWithBaseline(`homepage-${viewport.name}`);
            expect(result.passed).toBe(true);
        }
    });

    test('Update baseline when design changes', async ({ newDesignPage, browserManager, visualTesting }) => {
        await newDesignPage.navigate();

        await visualTesting.captureScreenshot(browserManager.getPage(), { name: 'new-homepage' });

        // Update baseline after design approval
        await visualTesting.updateBaseline('new-homepage');

        // Future comparisons will use new baseline
        const result = await visualTesting.compareWithBaseline('new-homepage');
        expect(result.passed).toBe(true);
    });
});</code></pre>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: visual-testing.feature
@visual
Feature: Visual Regression Testing

  @homepage
  Scenario: Homepage matches visual baseline
    Given I navigate to the homepage
    When I capture a screenshot
    Then the screenshot should match the baseline

  @responsive
  Scenario Outline: Page renders correctly on different devices
    Given I set viewport to &lt;device&gt;
    When I navigate to the homepage
    And I capture a screenshot as "&lt;device&gt;-homepage"
    Then the screenshot should match the baseline

    Examples:
      | device  |
      | desktop |
      | tablet  |
      | mobile  |

  @components
  Scenario: All UI components match visual baseline
    Given I navigate to the homepage
    When I capture the header component
    And I capture the footer component
    Then all component screenshots should match their baselines

// Step definitions: visual.steps.ts
import { Given, When, Then, StepClass } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSVisualTesting } from '@mdakhan.mak/cs-playwright-test-framework/visual';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { HomePage } from '../pages/HomePage';

@StepClass()
export class VisualSteps {
    private visual = CSVisualTesting.getInstance();
    private homePage!: HomePage;

    @Given('I navigate to the homepage')
    async navigateHome() {
        this.homePage = new HomePage(this.page);
        await this.homePage.navigate();
        await this.homePage.waitForPageLoad();
        CSReporter.info('Navigated to homepage');
    }

    @Given('I set viewport to {string}')
    async setViewport(device: string) {
        const viewports = {
            'desktop': { width: 1920, height: 1080 },
            'tablet': { width: 768, height: 1024 },
            'mobile': { width: 375, height: 667 }
        };
        await this.page.setViewportSize(viewports[device]);
        CSReporter.info(`Viewport set to ${device}`);
    }

    @When('I capture a screenshot')
    async captureScreenshot() {
        await this.visual.captureScreenshot(this.page, { name: 'homepage' });
        CSReporter.info('Screenshot captured');
    }

    @When('I capture a screenshot as {string}')
    async captureNamedScreenshot(name: string) {
        await this.visual.captureScreenshot(this.page, { name });
        this.ctx.set('lastScreenshotName', name);
        CSReporter.info(`Screenshot captured as ${name}`);
    }

    @When('I capture the header component')
    async captureHeader() {
        const header = this.page.locator('header');
        await this.visual.captureElement(header, { name: 'header' });
        CSReporter.info('Header component captured');
    }

    @When('I capture the footer component')
    async captureFooter() {
        const footer = this.page.locator('footer');
        await this.visual.captureElement(footer, { name: 'footer' });
        CSReporter.info('Footer component captured');
    }

    @Then('the screenshot should match the baseline')
    async verifyBaseline() {
        const name = this.ctx.get('lastScreenshotName') || 'homepage';
        const result = await this.visual.compareWithBaseline(name, {
            threshold: 0.02
        });

        if (!result.passed) {
            CSReporter.fail(`Visual diff: ${result.diffPercentage.toFixed(2)}%`);
            throw new Error(`Visual regression detected: ${result.diffPercentage}% diff`);
        }

        CSReporter.pass('Screenshot matches baseline');
    }

    @Then('all component screenshots should match their baselines')
    async verifyAllComponents() {
        const components = ['header', 'footer'];
        const failures = [];

        for (const component of components) {
            const result = await this.visual.compareWithBaseline(component);
            if (!result.passed) {
                failures.push(`${component}: ${result.diffPercentage.toFixed(2)}% diff`);
            }
        }

        if (failures.length > 0) {
            CSReporter.fail('Component visual regressions: ' + failures.join(', '));
            throw new Error(failures.join('; '));
        }

        CSReporter.pass('All components match baselines');
    }
}</code></pre>

                <div class="info-box tip">
                    <strong>Visual Testing Best Practices</strong>
                    <ul>
                        <li>Disable CSS animations before capturing screenshots</li>
                        <li>Wait for network idle to ensure all images are loaded</li>
                        <li>Use ignore regions for dynamic content (timestamps, ads)</li>
                        <li>Test responsive layouts at consistent viewport sizes</li>
                        <li>Review and approve baseline updates in version control</li>
                    </ul>
                </div>
            </section>

            <!-- MOBILE TESTING -->
            <section id="mobile-testing">
                <h2>Mobile Testing - CSMobileTesting</h2>

                <p>CSMobileTesting provides mobile device emulation and touch gesture support for testing responsive web applications and PWAs.</p>

                <h3>CSMobileTesting Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Parameters</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>-</td></tr>
                        <tr><td><code>launchDevice(device)</code></td><td>Launch browser with device emulation</td><td>device: string | DeviceConfig</td></tr>
                        <tr><td><code>getAvailableDevices()</code></td><td>List all available device presets</td><td>Returns: string[]</td></tr>
                        <tr><td><code>setDevice(device)</code></td><td>Change device after launch</td><td>device: string</td></tr>
                        <tr><td><code>tap(x, y)</code></td><td>Tap at coordinates</td><td>x: number, y: number</td></tr>
                        <tr><td><code>doubleTap(x, y)</code></td><td>Double tap at coordinates</td><td>x: number, y: number</td></tr>
                        <tr><td><code>longPress(x, y, duration)</code></td><td>Long press at coordinates</td><td>x, y: number, duration: ms</td></tr>
                        <tr><td><code>swipe(from, to)</code></td><td>Swipe between two points</td><td>from: Point, to: Point</td></tr>
                        <tr><td><code>swipeUp(distance)</code></td><td>Swipe up from center</td><td>distance: number (pixels)</td></tr>
                        <tr><td><code>swipeDown(distance)</code></td><td>Swipe down from center</td><td>distance: number (pixels)</td></tr>
                        <tr><td><code>swipeLeft(distance)</code></td><td>Swipe left from center</td><td>distance: number (pixels)</td></tr>
                        <tr><td><code>swipeRight(distance)</code></td><td>Swipe right from center</td><td>distance: number (pixels)</td></tr>
                        <tr><td><code>pinch(scale)</code></td><td>Pinch gesture (zoom in/out)</td><td>scale: number (0-1 zoom out)</td></tr>
                        <tr><td><code>rotateDevice(orientation)</code></td><td>Rotate device</td><td>'portrait' | 'landscape'</td></tr>
                        <tr><td><code>setGeolocation(lat, lon)</code></td><td>Set device geolocation</td><td>lat, lon: number</td></tr>
                        <tr><td><code>setOffline(offline)</code></td><td>Set offline mode</td><td>offline: boolean</td></tr>
                        <tr><td><code>setTimezone(timezone)</code></td><td>Set device timezone</td><td>timezone: string</td></tr>
                        <tr><td><code>setLocale(locale)</code></td><td>Set device locale</td><td>locale: string</td></tr>
                        <tr><td><code>grantPermissions(perms)</code></td><td>Grant device permissions</td><td>perms: string[]</td></tr>
                        <tr><td><code>revokePermissions(perms)</code></td><td>Revoke permissions</td><td>perms: string[]</td></tr>
                        <tr><td><code>getViewportSize()</code></td><td>Get current viewport</td><td>Returns: {width, height}</td></tr>
                    </tbody>
                </table>

                <h4>Popular Device Presets</h4>
                <table>
                    <thead><tr><th>Device</th><th>Width</th><th>Height</th><th>Scale</th><th>UA</th></tr></thead>
                    <tbody>
                        <tr><td>iPhone 13</td><td>390</td><td>844</td><td>3</td><td>Mobile Safari</td></tr>
                        <tr><td>iPhone 14 Pro</td><td>393</td><td>852</td><td>3</td><td>Mobile Safari</td></tr>
                        <tr><td>iPhone 15 Pro Max</td><td>430</td><td>932</td><td>3</td><td>Mobile Safari</td></tr>
                        <tr><td>iPad Pro 11</td><td>834</td><td>1194</td><td>2</td><td>Mobile Safari</td></tr>
                        <tr><td>Pixel 7</td><td>412</td><td>915</td><td>2.625</td><td>Chrome Mobile</td></tr>
                        <tr><td>Samsung Galaxy S23</td><td>360</td><td>780</td><td>3</td><td>Chrome Mobile</td></tr>
                        <tr><td>Galaxy Tab S8</td><td>753</td><td>1205</td><td>2.25</td><td>Chrome Mobile</td></tr>
                    </tbody>
                </table>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';

describe('Mobile Testing', () => {

    test('Test on iPhone 13', async ({ homePage, mobileTesting }) => {
        await mobileTesting.launchDevice('iPhone 13');
        await homePage.navigate();

        // Verify mobile viewport
        const viewport = mobileTesting.getViewportSize();
        expect(viewport.width).toBe(390);
        expect(viewport.height).toBe(844);

        // Test mobile menu using CSWebElement
        await mobileTesting.tap(350, 50);  // Hamburger menu
        await homePage.mobileMenu.waitForVisible();
    });

    test('Test touch gestures', async ({ galleryPage, mobileTesting }) => {
        await mobileTesting.launchDevice('iPhone 14 Pro');
        await galleryPage.navigate();

        // Swipe through carousel
        await mobileTesting.swipeLeft(200);
        await galleryPage.wait(300);
        await mobileTesting.swipeLeft(200);

        // Verify slide changed using CSWebElement
        const currentSlide = await galleryPage.activeCarouselIndicator.getAttribute('data-slide');
        expect(currentSlide).toBe('2');

        // Swipe back
        await mobileTesting.swipeRight(200);
    });

    test('Test pull-to-refresh', async ({ feedPage, mobileTesting }) => {
        await mobileTesting.launchDevice('Pixel 7');
        await feedPage.navigate();

        const initialContent = await feedPage.firstFeedItem.textContent();

        // Pull to refresh gesture
        await mobileTesting.swipeDown(400);
        await feedPage.waitForPageLoad();

        // Content should be refreshed
        const refreshedContent = await feedPage.firstFeedItem.textContent();
        // In real tests, content might differ after refresh
    });

    test('Test pinch zoom on map', async ({ mapPage, mobileTesting }) => {
        await mobileTesting.launchDevice('iPad Pro 11');
        await mapPage.navigate();

        // Zoom in
        await mobileTesting.pinch(2.0);  // Scale > 1 = zoom in
        await mapPage.wait(500);

        // Zoom out
        await mobileTesting.pinch(0.5);  // Scale < 1 = zoom out
    });

    test('Test landscape mode', async ({ videoPage, mobileTesting }) => {
        await mobileTesting.launchDevice('iPhone 13');
        await videoPage.navigate();

        // Rotate to landscape
        await mobileTesting.rotateDevice('landscape');

        const viewport = mobileTesting.getViewportSize();
        expect(viewport.width).toBeGreaterThan(viewport.height);

        // Video player should expand using CSWebElement
        const videoWidth = await videoPage.videoPlayer.evaluate(el => el.offsetWidth);
        expect(videoWidth).toBeGreaterThan(700);

        // Rotate back
        await mobileTesting.rotateDevice('portrait');
    });

    test('Test geolocation features', async ({ storesPage, mobileTesting }) => {
        await mobileTesting.launchDevice('iPhone 13');
        await mobileTesting.grantPermissions(['geolocation']);

        // Set location to San Francisco
        await mobileTesting.setGeolocation(37.7749, -122.4194);

        await storesPage.navigate();
        await storesPage.findNearbyButton.click();

        // Should show San Francisco stores using CSWebElement
        const storeListText = await storesPage.storeList.textContent();
        expect(storeListText).toContain('San Francisco');
    });

    test('Test offline mode', async ({ homePage, mobileTesting }) => {
        await mobileTesting.launchDevice('Pixel 7');
        await homePage.navigate();

        // Simulate going offline
        await mobileTesting.setOffline(true);

        // Try to navigate using CSWebElement
        await homePage.productsLink.click();

        // Should show offline message or cached content
        const hasOfflineContent = await homePage.offlineIndicator.isVisible();
        expect(hasOfflineContent).toBe(true);

        // Come back online
        await mobileTesting.setOffline(false);
        await homePage.refresh();
    });

    test('Cross-device testing', async ({ mobileTesting }) => {
        const devices = ['iPhone 13', 'Pixel 7', 'Samsung Galaxy S23'];

        for (const device of devices) {
            await mobileTesting.launchDevice(device);
            // Use page object for navigation
            const homePage = new HomePage(mobileTesting.getPage());
            await homePage.navigate();

            // Test responsive elements using CSWebElement
            const hamburgerVisible = await homePage.hamburgerMenu.isVisible();
            expect(hamburgerVisible).toBe(true);

            const desktopNavVisible = await homePage.desktopNav.isVisible();
            expect(desktopNavVisible).toBe(false);

            await mobileTesting.closePage();
        }
    });
});</code></pre>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: mobile-testing.feature
@mobile
Feature: Mobile Application Testing

  @iphone
  Scenario: Test mobile navigation on iPhone
    Given I am using an "iPhone 13" device
    When I navigate to the homepage
    Then I should see the mobile hamburger menu
    And the desktop navigation should be hidden

  @gestures
  Scenario: Test swipe gestures on image gallery
    Given I am using a "Pixel 7" device
    And I navigate to the gallery page
    When I swipe left to view next image
    Then I should see the second image

  @offline
  Scenario: Test offline functionality
    Given I am using a mobile device
    And I have cached the homepage
    When I go offline
    Then I should still see the cached content

// Step definitions: mobile.steps.ts
import { Given, When, Then, StepClass } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSMobileTesting } from '@mdakhan.mak/cs-playwright-test-framework/mobile';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

@StepClass()
export class MobileSteps {
    private mobile = CSMobileTesting.getInstance();

    @Given('I am using an {string} device')
    async useDevice(device: string) {
        this.page = await this.mobile.launchDevice(device);
        CSReporter.info(`Launched ${device} emulator`);
    }

    @Given('I am using a mobile device')
    async useDefaultDevice() {
        this.page = await this.mobile.launchDevice('iPhone 13');
        CSReporter.info('Launched default mobile device');
    }

    @Given('I navigate to the gallery page')
    async navigateToGallery() {
        await this.page.goto(`${this.config.get('BASE_URL')}/gallery`);
        await this.page.waitForLoadState('networkidle');
    }

    @Given('I have cached the homepage')
    async cacheHomepage() {
        await this.page.goto(this.config.get('BASE_URL'));
        await this.page.waitForLoadState('networkidle');
        CSReporter.info('Homepage cached');
    }

    @When('I navigate to the homepage')
    async navigateHome() {
        await this.page.goto(this.config.get('BASE_URL'));
        await this.page.waitForLoadState('domcontentloaded');
    }

    @When('I swipe left to view next image')
    async swipeLeft() {
        await this.mobile.swipeLeft(200);
        await this.page.waitForTimeout(500);
        CSReporter.info('Swiped left');
    }

    @When('I go offline')
    async goOffline() {
        await this.mobile.setOffline(true);
        CSReporter.info('Device set to offline mode');
    }

    @Then('I should see the mobile hamburger menu')
    async verifyHamburgerMenu() {
        const isVisible = await this.page.locator('.hamburger-menu, .mobile-menu-toggle').isVisible();
        expect(isVisible).toBe(true);
        CSReporter.pass('Hamburger menu is visible');
    }

    @Then('the desktop navigation should be hidden')
    async verifyDesktopNavHidden() {
        const isVisible = await this.page.locator('.desktop-nav, .desktop-navigation').isVisible();
        expect(isVisible).toBe(false);
        CSReporter.pass('Desktop navigation is hidden on mobile');
    }

    @Then('I should see the second image')
    async verifySecondImage() {
        const activeSlide = await this.page.locator('.gallery-slide.active, .carousel-item.active')
            .getAttribute('data-index');
        expect(activeSlide).toBe('1');  // 0-indexed
        CSReporter.pass('Second image is displayed');
    }

    @Then('I should still see the cached content')
    async verifyCachedContent() {
        // Page content should still be visible
        const hasContent = await this.page.locator('body').textContent();
        expect(hasContent.length).toBeGreaterThan(0);
        CSReporter.pass('Cached content is visible offline');
    }
}</code></pre>

                <div class="info-box note">
                    <strong>Mobile Testing Tips</strong>
                    <ul>
                        <li>Use Playwright's built-in device descriptors for accurate emulation</li>
                        <li>Test both portrait and landscape orientations</li>
                        <li>Test touch gestures for carousels, maps, and pull-to-refresh</li>
                        <li>Verify PWA offline functionality with service workers</li>
                        <li>Test geolocation-dependent features with mock coordinates</li>
                    </ul>
                </div>
            </section>

            <!-- UTILITIES -->
            <section id="utilities">
                <h2>Utility Classes</h2>

                <p>The framework provides comprehensive utility classes for string manipulation, date/time operations, file handling, encryption, and random data generation.</p>

                <h3>CSStringUtility - Complete Reference</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Example</th></tr></thead>
                    <tbody>
                        <tr><td><code>toCamelCase(str)</code></td><td>Convert to camelCase</td><td>'hello world' â†’ 'helloWorld'</td></tr>
                        <tr><td><code>toPascalCase(str)</code></td><td>Convert to PascalCase</td><td>'hello world' â†’ 'HelloWorld'</td></tr>
                        <tr><td><code>toSnakeCase(str)</code></td><td>Convert to snake_case</td><td>'helloWorld' â†’ 'hello_world'</td></tr>
                        <tr><td><code>toKebabCase(str)</code></td><td>Convert to kebab-case</td><td>'helloWorld' â†’ 'hello-world'</td></tr>
                        <tr><td><code>toTitleCase(str)</code></td><td>Convert to Title Case</td><td>'hello world' â†’ 'Hello World'</td></tr>
                        <tr><td><code>capitalize(str)</code></td><td>Capitalize first letter</td><td>'hello' â†’ 'Hello'</td></tr>
                        <tr><td><code>reverse(str)</code></td><td>Reverse string</td><td>'hello' â†’ 'olleh'</td></tr>
                        <tr><td><code>truncate(str, len)</code></td><td>Truncate with ellipsis</td><td>'Long text', 7 â†’ 'Long...'</td></tr>
                        <tr><td><code>mask(str, visible)</code></td><td>Mask characters</td><td>'1234567890', 4 â†’ '******7890'</td></tr>
                        <tr><td><code>slugify(str)</code></td><td>Create URL-safe slug</td><td>'Hello World!' â†’ 'hello-world'</td></tr>
                        <tr><td><code>removeWhitespace(str)</code></td><td>Remove all whitespace</td><td>'hello world' â†’ 'helloworld'</td></tr>
                        <tr><td><code>normalizeWhitespace(str)</code></td><td>Collapse multiple spaces</td><td>'hello   world' â†’ 'hello world'</td></tr>
                        <tr><td><code>isEmail(str)</code></td><td>Validate email format</td><td>'user@example.com' â†’ true</td></tr>
                        <tr><td><code>isUrl(str)</code></td><td>Validate URL format</td><td>'https://example.com' â†’ true</td></tr>
                        <tr><td><code>isJSON(str)</code></td><td>Validate JSON string</td><td>'{"key":"value"}' â†’ true</td></tr>
                        <tr><td><code>isNumeric(str)</code></td><td>Check if numeric</td><td>'12345' â†’ true</td></tr>
                        <tr><td><code>isAlphanumeric(str)</code></td><td>Check alphanumeric</td><td>'abc123' â†’ true</td></tr>
                        <tr><td><code>toBase64(str)</code></td><td>Encode to Base64</td><td>'hello' â†’ 'aGVsbG8='</td></tr>
                        <tr><td><code>fromBase64(str)</code></td><td>Decode from Base64</td><td>'aGVsbG8=' â†’ 'hello'</td></tr>
                        <tr><td><code>md5(str)</code></td><td>Generate MD5 hash</td><td>'password' â†’ '5f4dcc3b...'</td></tr>
                        <tr><td><code>sha256(str)</code></td><td>Generate SHA256 hash</td><td>'password' â†’ '5e884898...'</td></tr>
                        <tr><td><code>extractNumbers(str)</code></td><td>Extract all numbers</td><td>'Price: $99.99' â†’ ['99', '99']</td></tr>
                        <tr><td><code>extractEmails(str)</code></td><td>Extract email addresses</td><td>Returns array of emails</td></tr>
                        <tr><td><code>extractUrls(str)</code></td><td>Extract URLs</td><td>Returns array of URLs</td></tr>
                        <tr><td><code>padLeft(str, len, char)</code></td><td>Pad string left</td><td>'5', 3, '0' â†’ '005'</td></tr>
                        <tr><td><code>padRight(str, len, char)</code></td><td>Pad string right</td><td>'5', 3, '0' â†’ '500'</td></tr>
                    </tbody>
                </table>

                <h4>CSStringUtility Examples</h4>
                <pre><code>// Spec Format
test('String operations', async ({ reporter }) => {
    // Case conversions
    const apiName = CSStringUtility.toCamelCase('user profile api');  // 'userProfileApi'
    const className = CSStringUtility.toPascalCase('login page');     // 'LoginPage'
    const envVar = CSStringUtility.toSnakeCase('baseUrl');            // 'base_url'

    // Validation
    const isValidEmail = CSStringUtility.isEmail('user@example.com');
    const isValidUrl = CSStringUtility.isUrl('https://api.example.com');

    // Masking sensitive data for logs
    const maskedCard = CSStringUtility.mask('4111111111111111', 4);  // '************1111'
    reporter.info(`Card: ${maskedCard}`);

    // Generate slug for URLs
    const slug = CSStringUtility.slugify('My Test Article Title!');  // 'my-test-article-title'

    // Extract data
    const priceText = 'Total: $299.99 USD';
    const numbers = CSStringUtility.extractNumbers(priceText);  // ['299', '99']
});

// BDD Format
@When('I format the username as {string}')
async formatUsername(format: string) {
    const username = 'john_doe';
    let formatted;
    switch(format) {
        case 'camelCase':
            formatted = CSStringUtility.toCamelCase(username.replace('_', ' '));
            break;
        case 'title':
            formatted = CSStringUtility.toTitleCase(username.replace('_', ' '));
            break;
    }
    CSReporter.info(`Formatted username: ${formatted}`);
}</code></pre>

                <h3>CSDateTimeUtility - Complete Reference</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>now()</code></td><td>Get current Date object</td></tr>
                        <tr><td><code>timestamp()</code></td><td>Get Unix timestamp (seconds)</td></tr>
                        <tr><td><code>timestampMs()</code></td><td>Get Unix timestamp (milliseconds)</td></tr>
                        <tr><td><code>format(date, pattern)</code></td><td>Format date using pattern</td></tr>
                        <tr><td><code>parse(str, pattern)</code></td><td>Parse string to Date</td></tr>
                        <tr><td><code>toISO(date)</code></td><td>Convert to ISO string</td></tr>
                        <tr><td><code>toUSDateString(date)</code></td><td>Format as MM/DD/YYYY</td></tr>
                        <tr><td><code>toEUDateString(date)</code></td><td>Format as DD/MM/YYYY</td></tr>
                        <tr><td><code>toRelative(date)</code></td><td>Get relative time (2 hours ago)</td></tr>
                        <tr><td><code>addDays(date, days)</code></td><td>Add days to date</td></tr>
                        <tr><td><code>subtractDays(date, days)</code></td><td>Subtract days from date</td></tr>
                        <tr><td><code>addMonths(date, months)</code></td><td>Add months to date</td></tr>
                        <tr><td><code>subtractMonths(date, months)</code></td><td>Subtract months from date</td></tr>
                        <tr><td><code>addYears(date, years)</code></td><td>Add years to date</td></tr>
                        <tr><td><code>addHours(date, hours)</code></td><td>Add hours to date</td></tr>
                        <tr><td><code>addMinutes(date, mins)</code></td><td>Add minutes to date</td></tr>
                        <tr><td><code>startOfDay(date)</code></td><td>Get start of day (00:00:00)</td></tr>
                        <tr><td><code>endOfDay(date)</code></td><td>Get end of day (23:59:59)</td></tr>
                        <tr><td><code>startOfWeek(date)</code></td><td>Get start of week (Sunday)</td></tr>
                        <tr><td><code>endOfWeek(date)</code></td><td>Get end of week (Saturday)</td></tr>
                        <tr><td><code>startOfMonth(date)</code></td><td>Get first day of month</td></tr>
                        <tr><td><code>endOfMonth(date)</code></td><td>Get last day of month</td></tr>
                        <tr><td><code>isBefore(date1, date2)</code></td><td>Check if date1 is before date2</td></tr>
                        <tr><td><code>isAfter(date1, date2)</code></td><td>Check if date1 is after date2</td></tr>
                        <tr><td><code>isBetween(date, start, end)</code></td><td>Check if date is in range</td></tr>
                        <tr><td><code>isToday(date)</code></td><td>Check if date is today</td></tr>
                        <tr><td><code>isWeekend(date)</code></td><td>Check if date is weekend</td></tr>
                        <tr><td><code>isLeapYear(year)</code></td><td>Check if leap year</td></tr>
                        <tr><td><code>getDayOfWeek(date)</code></td><td>Get day name (Monday, etc.)</td></tr>
                        <tr><td><code>getMonthName(date)</code></td><td>Get month name (January, etc.)</td></tr>
                        <tr><td><code>diffInDays(date1, date2)</code></td><td>Difference in days</td></tr>
                        <tr><td><code>diffInHours(date1, date2)</code></td><td>Difference in hours</td></tr>
                        <tr><td><code>diffInMinutes(date1, date2)</code></td><td>Difference in minutes</td></tr>
                        <tr><td><code>addBusinessDays(date, days)</code></td><td>Add business days (skip weekends)</td></tr>
                        <tr><td><code>countBusinessDays(start, end)</code></td><td>Count business days in range</td></tr>
                        <tr><td><code>setDefaultTimezone(tz)</code></td><td>Set default timezone</td></tr>
                        <tr><td><code>formatInTimezone(date, pattern, tz)</code></td><td>Format in specific timezone</td></tr>
                    </tbody>
                </table>

                <h4>CSDateTimeUtility Examples</h4>
                <pre><code>// Spec Format
test('Date operations', async ({ reporter }) => {
    const dt = CSDateTimeUtility;

    // Current date/time
    const now = dt.now();
    const timestamp = dt.timestamp();
    reporter.info(`Current time: ${dt.format(now, 'YYYY-MM-DD HH:mm:ss')}`);

    // Date manipulation
    const nextWeek = dt.addDays(now, 7);
    const lastMonth = dt.subtractMonths(now, 1);
    const nextBusinessDay = dt.addBusinessDays(now, 1);

    // Date formatting
    const usFormat = dt.toUSDateString(now);        // '12/30/2025'
    const euFormat = dt.toEUDateString(now);        // '30/12/2025'
    const isoFormat = dt.toISO(now);                // '2025-12-30T...'
    const relative = dt.toRelative(dt.subtractDays(now, 2));  // '2 days ago'

    // Date comparisons
    const deadline = dt.addDays(now, 30);
    const isBeforeDeadline = dt.isBefore(now, deadline);
    const isWeekend = dt.isWeekend(now);

    // Business day calculations
    const startDate = dt.parse('2025-01-01', 'YYYY-MM-DD');
    const endDate = dt.parse('2025-01-31', 'YYYY-MM-DD');
    const workDays = dt.countBusinessDays(startDate, endDate);
    reporter.info(`Business days in January: ${workDays}`);

    // Timezone handling
    dt.setDefaultTimezone('America/New_York');
    const tokyoTime = dt.formatInTimezone(now, 'HH:mm', 'Asia/Tokyo');
    reporter.info(`Time in Tokyo: ${tokyoTime}`);
});

// BDD Format
@When('I schedule the appointment for {int} business days from now')
async scheduleAppointment(days: number) {
    const appointmentDate = CSDateTimeUtility.addBusinessDays(
        CSDateTimeUtility.now(),
        days
    );
    const formatted = CSDateTimeUtility.format(appointmentDate, 'YYYY-MM-DD');
    await this.formPage.dateField.fill(formatted);
    CSReporter.info(`Appointment scheduled for: ${formatted}`);
}</code></pre>

                <h3>CSExcelUtility - Complete Reference</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>readWorkbook(path)</code></td><td>Load Excel workbook</td></tr>
                        <tr><td><code>readSheetAsJSON(path, sheet)</code></td><td>Read sheet as array of objects</td></tr>
                        <tr><td><code>readSheetAsArray(path, sheet)</code></td><td>Read sheet as 2D array</td></tr>
                        <tr><td><code>readCellValue(path, sheet, cell)</code></td><td>Read specific cell value</td></tr>
                        <tr><td><code>readRange(path, sheet, range)</code></td><td>Read cell range (A1:C10)</td></tr>
                        <tr><td><code>getSheetNames(path)</code></td><td>Get all sheet names</td></tr>
                        <tr><td><code>getRowCount(path, sheet)</code></td><td>Get row count in sheet</td></tr>
                        <tr><td><code>getColumnCount(path, sheet)</code></td><td>Get column count in sheet</td></tr>
                        <tr><td><code>writeJSONToExcel(data, path, sheet)</code></td><td>Write JSON array to Excel</td></tr>
                        <tr><td><code>writeArrayToExcel(data, path, sheet)</code></td><td>Write 2D array to Excel</td></tr>
                        <tr><td><code>writeCellValue(path, sheet, cell, val)</code></td><td>Write to specific cell</td></tr>
                        <tr><td><code>appendRow(path, sheet, row)</code></td><td>Append row to sheet</td></tr>
                        <tr><td><code>createWorkbook()</code></td><td>Create new workbook</td></tr>
                        <tr><td><code>addSheet(workbook, name)</code></td><td>Add sheet to workbook</td></tr>
                        <tr><td><code>saveWorkbook(workbook, path)</code></td><td>Save workbook to file</td></tr>
                        <tr><td><code>excelToCSV(excelPath, csvPath)</code></td><td>Convert Excel to CSV</td></tr>
                        <tr><td><code>csvToExcel(csvPath, excelPath)</code></td><td>Convert CSV to Excel</td></tr>
                        <tr><td><code>compareExcelFiles(path1, path2)</code></td><td>Compare two Excel files</td></tr>
                    </tbody>
                </table>

                <h4>CSExcelUtility Examples</h4>
                <pre><code>// Spec Format
test('Excel operations', async ({ reporter }) => {
    const excel = CSExcelUtility;

    // Read test data
    const users = await excel.readSheetAsJSON('test/data/users.xlsx', 'Users');
    reporter.info(`Loaded ${users.length} users from Excel`);

    // Read specific cell
    const headerText = await excel.readCellValue('test/data/config.xlsx', 'Settings', 'B1');

    // Get sheet info
    const sheets = await excel.getSheetNames('test/data/workbook.xlsx');
    const rowCount = await excel.getRowCount('test/data/users.xlsx', 'Users');

    // Write test results
    const results = [
        { testName: 'Login', status: 'Pass', duration: 1500 },
        { testName: 'Search', status: 'Pass', duration: 2300 }
    ];
    await excel.writeJSONToExcel(results, 'reports/results.xlsx', 'TestResults');

    // Compare files
    const comparison = await excel.compareExcelFiles(
        'expected/baseline.xlsx',
        'actual/current.xlsx'
    );
    if (!comparison.match) {
        reporter.warn(`Excel differences found: ${comparison.differences.length}`);
    }
});

// BDD Format
@Given('I load user data from Excel')
async loadUserData() {
    const users = await CSExcelUtility.readSheetAsJSON(
        'test/data/users.xlsx',
        'TestUsers'
    );
    this.ctx.set('users', users);
    CSReporter.info(`Loaded ${users.length} test users`);
}</code></pre>

                <h3>CSEncryptionUtil - Complete Reference</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td></tr>
                        <tr><td><code>encrypt(data)</code></td><td>Encrypt string using AES-256</td></tr>
                        <tr><td><code>decrypt(encrypted)</code></td><td>Decrypt encrypted string</td></tr>
                        <tr><td><code>isEncrypted(value)</code></td><td>Check if value is encrypted</td></tr>
                        <tr><td><code>hashPassword(password)</code></td><td>Hash password with bcrypt</td></tr>
                        <tr><td><code>verifyPassword(password, hash)</code></td><td>Verify password against hash</td></tr>
                        <tr><td><code>generateSecurePassword(len?)</code></td><td>Generate secure random password</td></tr>
                        <tr><td><code>generateKey()</code></td><td>Generate encryption key</td></tr>
                        <tr><td><code>setKey(key)</code></td><td>Set encryption key</td></tr>
                    </tbody>
                </table>

                <h4>CSEncryptionUtil Examples</h4>
                <pre><code>// Spec Format
test('Encryption operations', async ({ config, reporter }) => {
    const crypto = CSEncryptionUtil.getInstance();

    // Auto-decrypt config values
    const password = config.get('DB_PASSWORD');  // Auto-decrypts ENCRYPTED:... values

    // Manual encryption/decryption
    const sensitive = 'secret-api-key-123';
    const encrypted = crypto.encrypt(sensitive);
    reporter.debug(`Encrypted: ${encrypted}`);

    const decrypted = crypto.decrypt(encrypted);
    expect(decrypted).toBe(sensitive);

    // Check if encrypted
    const isEnc = crypto.isEncrypted(encrypted);  // true

    // Generate secure password
    const newPassword = crypto.generateSecurePassword(16);
    reporter.info(`Generated password length: ${newPassword.length}`);

    // Password hashing
    const hash = crypto.hashPassword('user-password');
    const isValid = crypto.verifyPassword('user-password', hash);
    expect(isValid).toBe(true);
});

// BDD Format
@Given('I encrypt the password {string}')
async encryptPassword(password: string) {
    const crypto = CSEncryptionUtil.getInstance();
    const encrypted = crypto.encrypt(password);
    this.ctx.set('encryptedPassword', encrypted);
    CSReporter.info('Password encrypted successfully');
}</code></pre>

                <h3>CSRandomDataGenerator</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>randomString(length)</code></td><td>Generate random alphanumeric string</td></tr>
                        <tr><td><code>randomNumber(min, max)</code></td><td>Generate random number in range</td></tr>
                        <tr><td><code>randomBoolean()</code></td><td>Generate random true/false</td></tr>
                        <tr><td><code>randomEmail()</code></td><td>Generate random email address</td></tr>
                        <tr><td><code>randomPhone()</code></td><td>Generate random phone number</td></tr>
                        <tr><td><code>randomName()</code></td><td>Generate random full name</td></tr>
                        <tr><td><code>randomFirstName()</code></td><td>Generate random first name</td></tr>
                        <tr><td><code>randomLastName()</code></td><td>Generate random last name</td></tr>
                        <tr><td><code>randomAddress()</code></td><td>Generate random address</td></tr>
                        <tr><td><code>randomCity()</code></td><td>Generate random city name</td></tr>
                        <tr><td><code>randomCountry()</code></td><td>Generate random country</td></tr>
                        <tr><td><code>randomZipCode()</code></td><td>Generate random ZIP code</td></tr>
                        <tr><td><code>randomUUID()</code></td><td>Generate UUID v4</td></tr>
                        <tr><td><code>randomDate(start, end)</code></td><td>Generate random date in range</td></tr>
                        <tr><td><code>randomFromArray(array)</code></td><td>Pick random item from array</td></tr>
                        <tr><td><code>shuffleArray(array)</code></td><td>Randomly shuffle array</td></tr>
                    </tbody>
                </table>

                <h4>CSRandomDataGenerator Examples</h4>
                <pre><code>// Spec Format
test('Generate random test data', async ({ formPage, reporter }) => {
    const rand = CSRandomDataGenerator;

    // Generate unique user
    const user = {
        email: rand.randomEmail(),           // 'user_xyz123@test.com'
        firstName: rand.randomFirstName(),   // 'John'
        lastName: rand.randomLastName(),     // 'Smith'
        phone: rand.randomPhone(),           // '+1-555-123-4567'
        address: rand.randomAddress(),       // '123 Main St'
        city: rand.randomCity(),             // 'New York'
        zipCode: rand.randomZipCode()        // '10001'
    };

    reporter.info(`Creating user: ${user.email}`);

    await formPage.fillRegistrationForm(user);

    // Random selections
    const status = rand.randomFromArray(['Active', 'Pending', 'Inactive']);
    const priority = rand.randomNumber(1, 5);
    const isEnabled = rand.randomBoolean();

    // Generate unique ID
    const orderId = rand.randomUUID();  // 'a1b2c3d4-e5f6-...'

    // Random date in range
    const birthDate = rand.randomDate(
        new Date('1980-01-01'),
        new Date('2000-12-31')
    );
});

// BDD Format
@When('I register with random user data')
async registerRandomUser() {
    const rand = CSRandomDataGenerator;
    const email = rand.randomEmail();
    const name = rand.randomName();

    await this.registrationPage.emailField.fill(email);
    await this.registrationPage.nameField.fill(name);

    this.ctx.set('registeredEmail', email);
    CSReporter.info(`Registered user: ${email}`);
}</code></pre>

                <h3>CSFileUtility</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>readFile(path)</code></td><td>Read file contents as string</td></tr>
                        <tr><td><code>readFileAsBuffer(path)</code></td><td>Read file as Buffer</td></tr>
                        <tr><td><code>readJSON(path)</code></td><td>Read and parse JSON file</td></tr>
                        <tr><td><code>readCSV(path)</code></td><td>Read and parse CSV file</td></tr>
                        <tr><td><code>writeFile(path, content)</code></td><td>Write string to file</td></tr>
                        <tr><td><code>writeJSON(path, data)</code></td><td>Write object as JSON file</td></tr>
                        <tr><td><code>appendFile(path, content)</code></td><td>Append to file</td></tr>
                        <tr><td><code>copyFile(src, dest)</code></td><td>Copy file</td></tr>
                        <tr><td><code>moveFile(src, dest)</code></td><td>Move/rename file</td></tr>
                        <tr><td><code>deleteFile(path)</code></td><td>Delete file</td></tr>
                        <tr><td><code>exists(path)</code></td><td>Check if file exists</td></tr>
                        <tr><td><code>isFile(path)</code></td><td>Check if path is file</td></tr>
                        <tr><td><code>isDirectory(path)</code></td><td>Check if path is directory</td></tr>
                        <tr><td><code>createDirectory(path)</code></td><td>Create directory (recursive)</td></tr>
                        <tr><td><code>listFiles(dir, pattern?)</code></td><td>List files in directory</td></tr>
                        <tr><td><code>getFileSize(path)</code></td><td>Get file size in bytes</td></tr>
                        <tr><td><code>getFileMimeType(path)</code></td><td>Get MIME type</td></tr>
                        <tr><td><code>calculateChecksum(path)</code></td><td>Calculate MD5 checksum</td></tr>
                    </tbody>
                </table>

                <h4>CSFileUtility Examples</h4>
                <pre><code>// Spec Format
test('File operations', async ({ reporter }) => {
    const file = CSFileUtility;

    // Read configuration
    const config = await file.readJSON('config/test-config.json');
    reporter.info(`Config loaded: ${config.environment}`);

    // Read CSV data
    const testData = await file.readCSV('data/test-cases.csv');
    reporter.info(`Loaded ${testData.length} test cases`);

    // Write test results
    const results = { passed: 10, failed: 2, skipped: 1 };
    await file.writeJSON('reports/summary.json', results);

    // File management
    const downloadPath = 'downloads/report.pdf';
    if (await file.exists(downloadPath)) {
        const size = await file.getFileSize(downloadPath);
        reporter.info(`Downloaded file size: ${size} bytes`);

        const checksum = await file.calculateChecksum(downloadPath);
        reporter.info(`File checksum: ${checksum}`);

        // Archive the file
        await file.copyFile(downloadPath, `archive/report_${Date.now()}.pdf`);
    }

    // List test files
    const specFiles = await file.listFiles('test/specs', '*.spec.ts');
    reporter.info(`Found ${specFiles.length} spec files`);
});

// BDD Format
@Then('the downloaded file should exist')
async verifyDownload() {
    const downloadPath = this.ctx.get('downloadPath');
    const exists = await CSFileUtility.exists(downloadPath);
    if (!exists) {
        throw new Error(`File not found: ${downloadPath}`);
    }
    CSReporter.pass('Downloaded file exists');
}</code></pre>
            </section>

            <!-- ASSERTIONS -->
            <section id="assertions">
                <h2>Assertions - CSExpect & CSAssert</h2>

                <p>The framework provides two assertion systems: CSExpect (async with screenshots) and CSAssert (direct).</p>

                <h3>CSExpect Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>toEqual(actual, expected, msg?)</code></td><td>Assert values are equal</td></tr>
                        <tr><td><code>toNotEqual(actual, expected, msg?)</code></td><td>Assert values are not equal</td></tr>
                        <tr><td><code>toBeTruthy(value, msg?)</code></td><td>Assert value is truthy</td></tr>
                        <tr><td><code>toBeFalsy(value, msg?)</code></td><td>Assert value is falsy</td></tr>
                        <tr><td><code>toBeNull(value, msg?)</code></td><td>Assert value is null</td></tr>
                        <tr><td><code>toBeUndefined(value, msg?)</code></td><td>Assert value is undefined</td></tr>
                        <tr><td><code>toBeDefined(value, msg?)</code></td><td>Assert value is defined</td></tr>
                        <tr><td><code>toContain(arr, item, msg?)</code></td><td>Assert array/string contains item</td></tr>
                        <tr><td><code>toMatch(str, pattern, msg?)</code></td><td>Assert string matches regex</td></tr>
                        <tr><td><code>toBeGreaterThan(a, b, msg?)</code></td><td>Assert a > b</td></tr>
                        <tr><td><code>toBeLessThan(a, b, msg?)</code></td><td>Assert a < b</td></tr>
                        <tr><td><code>toHaveLength(arr, len, msg?)</code></td><td>Assert array/string has length</td></tr>
                        <tr><td><code>toBeVisible(locator, opts?)</code></td><td>Assert element is visible</td></tr>
                        <tr><td><code>toBeHidden(locator, opts?)</code></td><td>Assert element is hidden</td></tr>
                        <tr><td><code>toBeEnabled(locator, opts?)</code></td><td>Assert element is enabled</td></tr>
                        <tr><td><code>toBeDisabled(locator, opts?)</code></td><td>Assert element is disabled</td></tr>
                        <tr><td><code>toHaveText(locator, text, opts?)</code></td><td>Assert element has text</td></tr>
                        <tr><td><code>toContainText(locator, text, opts?)</code></td><td>Assert element contains text</td></tr>
                        <tr><td><code>toHaveValue(locator, value, opts?)</code></td><td>Assert input has value</td></tr>
                        <tr><td><code>toHaveAttribute(loc, attr, val, opts?)</code></td><td>Assert element has attribute</td></tr>
                        <tr><td><code>toHaveClass(locator, class, opts?)</code></td><td>Assert element has CSS class</td></tr>
                        <tr><td><code>toHaveCount(locator, count, opts?)</code></td><td>Assert element count</td></tr>
                        <tr><td><code>toHaveURL(page, url, opts?)</code></td><td>Assert page URL</td></tr>
                        <tr><td><code>toHaveTitle(page, title, opts?)</code></td><td>Assert page title</td></tr>
                        <tr><td><code>enableSoftMode()</code></td><td>Enable soft assertions</td></tr>
                        <tr><td><code>disableSoftMode()</code></td><td>Disable soft assertions</td></tr>
                        <tr><td><code>assertAll()</code></td><td>Check all soft assertions</td></tr>
                        <tr><td><code>poll(fn, opts)</code></td><td>Polling assertion with retry</td></tr>
                    </tbody>
                </table>

                <h4>CSExpect Examples</h4>
                <pre><code>// Spec Format
test('Assertions', async ({ loginPage, expect, page }) => {
    // Value assertions
    expect.toEqual(2 + 2, 4);
    expect.toBeTruthy(true);
    expect.toContain([1, 2, 3], 2);
    expect.toMatch('hello world', /world/);
    expect.toHaveLength([1, 2, 3], 3);

    // Element assertions (async - capture screenshot on failure)
    await expect.toBeVisible(loginPage.submitButton);
    await expect.toBeEnabled(loginPage.submitButton);
    await expect.toHaveText(loginPage.heading, 'Login');
    await expect.toContainText(loginPage.message, 'Welcome');
    await expect.toHaveValue(loginPage.usernameField, 'admin');
    await expect.toHaveClass(loginPage.errorBox, 'error');
    await expect.toHaveAttribute(loginPage.link, 'href', '/help');
    await expect.toHaveCount(page.locator('.item'), 5);

    // Page assertions
    await expect.toHaveURL(page, /dashboard/);
    await expect.toHaveTitle(page, 'Dashboard');

    // Soft assertions - continue on failure
    expect.enableSoftMode();
    await expect.toBeVisible(loginPage.logo);
    await expect.toHaveText(loginPage.footer, 'Copyright');
    expect.assertAll();  // Throws if any soft assertion failed

    // Polling assertion - retry until success or timeout
    const statusElement = CSElementFactory.createByCSS('.status', 'Status element');
    await expect.poll(async () => {
        return await statusElement.getText();
    }, { timeout: 10000 }).toBe('Complete');
});

// BDD Format
@Then('the error message should be displayed')
async verifyError() {
    const expect = CSExpect.getInstance();
    await expect.toBeVisible(this.loginPage.errorMessage);
    await expect.toContainText(this.loginPage.errorMessage, 'Invalid');
}</code></pre>

                <h3>CSAssert Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>assertTrue(cond, msg?)</code></td><td>Assert condition is true</td></tr>
                        <tr><td><code>assertFalse(cond, msg?)</code></td><td>Assert condition is false</td></tr>
                        <tr><td><code>assertEqual(actual, expected, msg?)</code></td><td>Assert values are equal</td></tr>
                        <tr><td><code>assertNotEqual(actual, expected, msg?)</code></td><td>Assert values differ</td></tr>
                        <tr><td><code>assertContains(str, substr, msg?)</code></td><td>Assert string contains</td></tr>
                        <tr><td><code>assertNotContains(str, substr, msg?)</code></td><td>Assert string doesn't contain</td></tr>
                        <tr><td><code>assertNull(value, msg?)</code></td><td>Assert value is null</td></tr>
                        <tr><td><code>assertNotNull(value, msg?)</code></td><td>Assert value is not null</td></tr>
                        <tr><td><code>assertVisible(locator, msg?)</code></td><td>Assert element visible</td></tr>
                        <tr><td><code>assertHidden(locator, msg?)</code></td><td>Assert element hidden</td></tr>
                        <tr><td><code>assertEnabled(locator, msg?)</code></td><td>Assert element enabled</td></tr>
                        <tr><td><code>assertDisabled(locator, msg?)</code></td><td>Assert element disabled</td></tr>
                        <tr><td><code>assertUrl(pattern, msg?)</code></td><td>Assert current URL matches</td></tr>
                        <tr><td><code>assertTitle(title, msg?)</code></td><td>Assert page title</td></tr>
                        <tr><td><code>softAssert(cond, msg?)</code></td><td>Soft assertion (no throw)</td></tr>
                        <tr><td><code>assertAllSoft()</code></td><td>Check all soft assertions</td></tr>
                    </tbody>
                </table>

                <h4>CSAssert Examples</h4>
                <pre><code>// Spec Format
import { CSAssert } from '@mdakhan.mak/cs-playwright-test-framework/assertions';

test('Direct assertions', async ({ loginPage }) => {
    const assert = CSAssert.getInstance();

    // Value assertions
    await assert.assertTrue(1 === 1, 'Basic equality');
    await assert.assertEqual('hello', 'hello');
    await assert.assertContains('hello world', 'world');
    await assert.assertNotNull(result, 'Result should exist');

    // Element assertions
    await assert.assertVisible(loginPage.submitButton);
    await assert.assertEnabled(loginPage.submitButton);

    // Page assertions
    await assert.assertUrl(/login/, 'Should be on login page');
    await assert.assertTitle('Login Page');

    // Soft assertions - collect failures
    await assert.softAssert(value > 0, 'Value should be positive');
    await assert.softAssert(status === 'active', 'Should be active');
    await assert.assertAllSoft();  // Throws if any failed
});

// BDD Format
@Then('the user should be on the dashboard')
async verifyDashboard() {
    const assert = CSAssert.getInstance();
    await assert.assertUrl(/dashboard/);
    await assert.assertVisible(this.dashboardPage.welcomeMessage);
}</code></pre>
            </section>

            <!-- CONTEXT -->
            <section id="context">
                <h2>Test Context - CSContext (ctx)</h2>

                <p>CSContext provides a way to share data between tests, steps, and page objects within a test execution.</p>

                <h3>CSContext Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>set(key, value)</code></td><td>Store a value in context</td></tr>
                        <tr><td><code>get(key, default?)</code></td><td>Retrieve a value from context</td></tr>
                        <tr><td><code>has(key)</code></td><td>Check if key exists in context</td></tr>
                        <tr><td><code>delete(key)</code></td><td>Remove a key from context</td></tr>
                        <tr><td><code>clear()</code></td><td>Clear all context data</td></tr>
                        <tr><td><code>getAll()</code></td><td>Get all context data as object</td></tr>
                        <tr><td><code>keys()</code></td><td>Get all context keys</td></tr>
                        <tr><td><code>size()</code></td><td>Get number of items in context</td></tr>
                        <tr><td><code>merge(data)</code></td><td>Merge object into context</td></tr>
                        <tr><td><code>setObject(key, obj)</code></td><td>Store object (deep clone)</td></tr>
                        <tr><td><code>getObject(key)</code></td><td>Get object (deep clone)</td></tr>
                        <tr><td><code>increment(key, amount?)</code></td><td>Increment numeric value</td></tr>
                        <tr><td><code>decrement(key, amount?)</code></td><td>Decrement numeric value</td></tr>
                        <tr><td><code>push(key, value)</code></td><td>Push to array in context</td></tr>
                        <tr><td><code>pop(key)</code></td><td>Pop from array in context</td></tr>
                    </tbody>
                </table>

                <h4>CSContext Usage Examples</h4>
                <pre><code>// Spec Format - ctx is available as fixture
test('Share data between steps', async ({ loginPage, ctx, reporter }) => {
    // Store data
    ctx.set('username', 'admin');
    ctx.set('userId', 12345);
    ctx.setObject('user', { name: 'Admin', role: 'superuser' });

    // Retrieve data
    const username = ctx.get('username');
    const userId = ctx.get('userId');
    const user = ctx.getObject('user');

    reporter.info(`Logged in as: ${username} (ID: ${userId})`);

    // Check existence
    if (ctx.has('authToken')) {
        const token = ctx.get('authToken');
    }

    // Default value if not found
    const timeout = ctx.get('customTimeout', 30000);

    // Numeric operations
    ctx.set('counter', 0);
    ctx.increment('counter');  // counter = 1
    ctx.increment('counter', 5);  // counter = 6
    ctx.decrement('counter', 2);  // counter = 4

    // Array operations
    ctx.set('visitedPages', []);
    ctx.push('visitedPages', 'dashboard');
    ctx.push('visitedPages', 'profile');
    const pages = ctx.get('visitedPages');  // ['dashboard', 'profile']

    // Merge multiple values
    ctx.merge({
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com'
    });

    // Get all data
    const allData = ctx.getAll();
    reporter.debug(`Context: ${JSON.stringify(allData)}`);
});

// Share data between tests in serial mode
describe('User workflow', { mode: 'serial' }, () => {
    test('Login and store user', async ({ loginPage, ctx }) => {
        await loginPage.login('Admin', 'admin123');
        ctx.set('isLoggedIn', true);
        ctx.set('currentUser', 'Admin');
    });

    test('Use stored data', async ({ dashboardPage, ctx }) => {
        // Data from previous test is available
        const user = ctx.get('currentUser');
        reporter.info(`Current user: ${user}`);
        await dashboardPage.verifyUserName(user);
    });
});

// BDD Format - access via this.ctx
@Given('I login as {string}')
async loginAs(username: string) {
    await this.loginPage.login(username, 'password');
    this.ctx.set('currentUser', username);
    this.ctx.set('loginTime', new Date());
}

@Then('I should see the welcome message for the logged in user')
async verifyWelcome() {
    const user = this.ctx.get('currentUser');
    await this.dashboardPage.verifyWelcomeMessage(`Welcome, ${user}`);
}

@When('I create a new order')
async createOrder() {
    const orderId = await this.orderPage.createOrder();
    this.ctx.set('orderId', orderId);
    this.ctx.push('createdOrders', orderId);  // Track multiple orders
}

@Then('the order should be in the list')
async verifyOrder() {
    const orderId = this.ctx.get('orderId');
    await this.orderPage.verifyOrderExists(orderId);
}</code></pre>

                <h4>Context Scope</h4>
                <div class="note">
                    <strong>Context Scope Rules:</strong>
                    <ul>
                        <li><strong>Single test:</strong> Context is isolated per test</li>
                        <li><strong>Serial describe:</strong> Context is shared between tests in <code>mode: 'serial'</code></li>
                        <li><strong>Workflow:</strong> Context is shared across all workflow steps</li>
                        <li><strong>Parallel tests:</strong> Each parallel worker has its own isolated context</li>
                    </ul>
                </div>
            </section>

            <!-- NETWORK -->
            <section id="network">
                <h2>Network Interception - CSNetworkInterceptor</h2>

                <p>CSNetworkInterceptor provides comprehensive network traffic control including mocking, blocking, recording, throttling, and HAR generation.</p>

                <h3>CSNetworkInterceptor Methods</h3>
                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Parameters</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>-</td></tr>
                        <tr><td><code>initialize(page)</code></td><td>Initialize interceptor for page</td><td>page: Page</td></tr>
                        <tr><td><code>addMockRule(rule)</code></td><td>Add URL mock response rule</td><td>rule: MockRule</td></tr>
                        <tr><td><code>removeMockRule(url)</code></td><td>Remove mock rule by URL</td><td>url: string</td></tr>
                        <tr><td><code>clearMockRules()</code></td><td>Clear all mock rules</td><td>-</td></tr>
                        <tr><td><code>blockUrl(pattern)</code></td><td>Block URLs matching pattern</td><td>pattern: string (glob)</td></tr>
                        <tr><td><code>blockDomains(domains)</code></td><td>Block specific domains</td><td>domains: string[]</td></tr>
                        <tr><td><code>blockResourceTypes(types)</code></td><td>Block resource types</td><td>types: ResourceType[]</td></tr>
                        <tr><td><code>unblockUrl(pattern)</code></td><td>Remove URL block rule</td><td>pattern: string</td></tr>
                        <tr><td><code>startRecording()</code></td><td>Start recording network traffic</td><td>-</td></tr>
                        <tr><td><code>stopRecording()</code></td><td>Stop recording and get traffic</td><td>Returns: NetworkEntry[]</td></tr>
                        <tr><td><code>saveRecording(path)</code></td><td>Save recorded traffic to file</td><td>path: string</td></tr>
                        <tr><td><code>loadRecording(path)</code></td><td>Load and replay recorded traffic</td><td>path: string</td></tr>
                        <tr><td><code>setThrottleProfile(profile)</code></td><td>Set network throttling</td><td>profile: ThrottleProfile</td></tr>
                        <tr><td><code>clearThrottle()</code></td><td>Remove network throttling</td><td>-</td></tr>
                        <tr><td><code>modifyResponse(url, fn)</code></td><td>Modify response before return</td><td>url: string, fn: ModifierFn</td></tr>
                        <tr><td><code>modifyRequest(url, fn)</code></td><td>Modify request before send</td><td>url: string, fn: ModifierFn</td></tr>
                        <tr><td><code>generateHAR()</code></td><td>Generate HAR file from traffic</td><td>Returns: HARObject</td></tr>
                        <tr><td><code>saveHAR(path)</code></td><td>Save HAR to file</td><td>path: string</td></tr>
                        <tr><td><code>getRequestCount()</code></td><td>Get total request count</td><td>Returns: number</td></tr>
                        <tr><td><code>getRequestsByUrl(pattern)</code></td><td>Get requests matching URL</td><td>pattern: string</td></tr>
                        <tr><td><code>waitForRequest(url)</code></td><td>Wait for specific request</td><td>url: string | RegExp</td></tr>
                        <tr><td><code>waitForResponse(url)</code></td><td>Wait for specific response</td><td>url: string | RegExp</td></tr>
                        <tr><td><code>cleanup()</code></td><td>Clean up all handlers</td><td>-</td></tr>
                    </tbody>
                </table>

                <h4>Throttle Profiles</h4>
                <table>
                    <thead><tr><th>Profile</th><th>Download</th><th>Upload</th><th>Latency</th></tr></thead>
                    <tbody>
                        <tr><td>offline</td><td>0 Kbps</td><td>0 Kbps</td><td>0ms</td></tr>
                        <tr><td>slow-2g</td><td>50 Kbps</td><td>50 Kbps</td><td>2000ms</td></tr>
                        <tr><td>fast-2g</td><td>250 Kbps</td><td>50 Kbps</td><td>1000ms</td></tr>
                        <tr><td>slow-3g</td><td>780 Kbps</td><td>330 Kbps</td><td>400ms</td></tr>
                        <tr><td>fast-3g</td><td>1.6 Mbps</td><td>750 Kbps</td><td>150ms</td></tr>
                        <tr><td>slow-4g</td><td>4 Mbps</td><td>3 Mbps</td><td>100ms</td></tr>
                        <tr><td>fast-4g</td><td>20 Mbps</td><td>10 Mbps</td><td>50ms</td></tr>
                        <tr><td>wifi</td><td>50 Mbps</td><td>20 Mbps</td><td>20ms</td></tr>
                    </tbody>
                </table>

                <h3>Spec Format Examples</h3>
                <pre><code>import { describe, test } from '@mdakhan.mak/cs-playwright-test-framework/spec';
import { CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';

describe('Network Interception Tests', () => {

    test('Mock API response', async ({ navigate, networkInterceptor, browserManager }) => {
        await networkInterceptor.initialize(browserManager.getPage());

        // Mock user API to return test data
        networkInterceptor.addMockRule({
            url: '**/api/users',
            method: 'GET',
            response: {
                status: 200,
                contentType: 'application/json',
                body: JSON.stringify([
                    { id: 1, name: 'Test User 1' },
                    { id: 2, name: 'Test User 2' }
                ])
            }
        });

        await navigate('https://example.com/users');
        // Page will receive mocked data
    });

    test('Block analytics and ads', async ({ navigate, networkInterceptor, browserManager }) => {
        await networkInterceptor.initialize(browserManager.getPage());

        // Block tracking domains
        networkInterceptor.blockDomains([
            'google-analytics.com',
            'facebook.com',
            'doubleclick.net'
        ]);

        // Block ad URLs
        networkInterceptor.blockUrl('**/ads/**');
        networkInterceptor.blockUrl('**/tracking/**');

        // Block heavy resources for faster testing
        networkInterceptor.blockResourceTypes(['image', 'font', 'media']);

        await navigate('https://example.com');
    });

    test('Record and replay network traffic', async ({ navigate, networkInterceptor, browserManager, reporter }) => {
        await networkInterceptor.initialize(browserManager.getPage());

        // Start recording
        networkInterceptor.startRecording();

        await navigate('https://example.com');

        // Use CSWebElement for interactions
        const loginBtn = CSElementFactory.createById('login', 'Login button');
        const usernameField = CSElementFactory.createById('username', 'Username field');

        await loginBtn.click();
        await usernameField.fill('testuser');

        // Stop and save
        const traffic = networkInterceptor.stopRecording();
        networkInterceptor.saveRecording('./test-traffic.json');

        reporter.info(`Recorded ${traffic.length} network requests`);
    });

    test('Test under slow network conditions', async ({ navigate, networkInterceptor, browserManager, reporter }) => {
        await networkInterceptor.initialize(browserManager.getPage());

        // Simulate slow 3G
        await networkInterceptor.setThrottleProfile('slow-3g');

        const startTime = Date.now();
        await navigate('https://example.com');
        const loadTime = Date.now() - startTime;

        reporter.info(`Page loaded in ${loadTime}ms under slow-3g`);

        // Clear throttling
        networkInterceptor.clearThrottle();
    });

    test('Modify API responses dynamically', async ({ navigate, networkInterceptor, browserManager }) => {
        await networkInterceptor.initialize(browserManager.getPage());

        // Modify response to inject test data
        networkInterceptor.modifyResponse('**/api/products', (response) => {
            // Add test flag to all products
            response.products = response.products.map(p => ({
                ...p,
                isTestData: true
            }));
            return response;
        });

        await navigate('https://example.com/products');
    });

    test('Generate HAR file for debugging', async ({ navigate, networkInterceptor, browserManager, reporter }) => {
        await networkInterceptor.initialize(browserManager.getPage());
        networkInterceptor.startRecording();

        await navigate('https://example.com');

        // Use CSWebElement for navigation clicks
        const navLink = CSElementFactory.createByCSS('nav a', 'Navigation link');
        await navLink.click();

        // Generate HAR
        const har = await networkInterceptor.generateHAR();
        networkInterceptor.saveHAR('./network-debug.har');

        reporter.info(`HAR contains ${har.log.entries.length} entries`);
    });
});</code></pre>

                <h3>BDD Format Examples</h3>
                <pre><code>// Feature file: network-testing.feature
@network
Feature: Network Interception Tests

  @mock
  Scenario: Test with mocked API response
    Given I have mocked the users API
    When I navigate to the users page
    Then I should see the mocked user data

  @throttle
  Scenario: Test under slow network conditions
    Given I am on a slow-3g network connection
    When I navigate to the homepage
    Then the page should load within acceptable time

// Step definitions: network.steps.ts
import { Given, When, Then, StepClass } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSNetworkInterceptor } from '@mdakhan.mak/cs-playwright-test-framework/network';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

@StepClass()
export class NetworkSteps {
    private interceptor = CSNetworkInterceptor.getInstance();

    @Given('I have mocked the users API')
    async mockUsersApi() {
        await this.interceptor.initialize(this.page);

        this.interceptor.addMockRule({
            url: '**/api/users',
            method: 'GET',
            response: {
                status: 200,
                body: JSON.stringify([
                    { id: 1, name: 'Mock User' }
                ])
            }
        });

        CSReporter.info('Users API mocked');
    }

    @Given('I am on a slow-3g network connection')
    async setSlowNetwork() {
        await this.interceptor.initialize(this.page);
        await this.interceptor.setThrottleProfile('slow-3g');
        CSReporter.info('Network throttled to slow-3g');
    }

    @Given('I have blocked analytics tracking')
    async blockAnalytics() {
        await this.interceptor.initialize(this.page);
        this.interceptor.blockDomains(['google-analytics.com', 'facebook.com']);
        CSReporter.info('Analytics domains blocked');
    }

    @When('I navigate to the users page')
    async navigateToUsers() {
        await this.page.goto('https://example.com/users');
    }

    @When('I navigate to the homepage')
    async navigateToHome() {
        const startTime = Date.now();
        await this.page.goto('https://example.com');
        const loadTime = Date.now() - startTime;
        this.ctx.set('pageLoadTime', loadTime);
    }

    @Then('I should see the mocked user data')
    async verifyMockedData() {
        const text = await this.page.textContent('body');
        expect(text).toContain('Mock User');
        CSReporter.pass('Mocked data displayed correctly');
    }

    @Then('the page should load within acceptable time')
    async verifyLoadTime() {
        const loadTime = this.ctx.get('pageLoadTime');
        CSReporter.info(`Page loaded in ${loadTime}ms`);
        // Even on slow-3g, page should load within 30 seconds
        expect(loadTime).toBeLessThan(30000);
    }
}</code></pre>
            </section>

            <!-- CLI COMMANDS -->
            <section id="cli-commands">
                <h2>CLI Commands</h2>

                <h3>Basic Execution</h3>
                <pre><code># Run all tests in project
npx cs-playwright-test --project=myproject

# Run specific spec file
npx cs-playwright-test --project=myproject --specs="test/specs/login.spec.ts"

# Run BDD features
npx cs-playwright-test --project=myproject --features="test/features/*.feature"

# Run with tag filter
npx cs-playwright-test --project=myproject --tags="@smoke"
npx cs-playwright-test --project=myproject --tags="@smoke and @critical"
npx cs-playwright-test --project=myproject --tags="@smoke or @regression"
npx cs-playwright-test --project=myproject --tags="not @slow"</code></pre>

                <h3>Browser Options</h3>
                <pre><code># Run headed (show browser)
npx cs-playwright-test --project=myproject --headed

# Specific browser
npx cs-playwright-test --project=myproject --browser=firefox

# Multiple browsers
npx cs-playwright-test --project=myproject --browser=chromium,firefox,webkit</code></pre>

                <h3>Parallel & Retry</h3>
                <pre><code># Parallel workers
npx cs-playwright-test --project=myproject --workers=4

# Serial execution
npx cs-playwright-test --project=myproject --workers=1

# Retry on failure
npx cs-playwright-test --project=myproject --retries=2

# Timeout
npx cs-playwright-test --project=myproject --timeout=60000</code></pre>

                <h3>Reporting</h3>
                <pre><code># Specify report types
npx cs-playwright-test --project=myproject --reporters=html,json,junit

# Custom report directory
npx cs-playwright-test --project=myproject --output-dir=./my-reports</code></pre>

                <h3>Environment</h3>
                <pre><code># Specific environment
npx cs-playwright-test --project=myproject --env=qa

# Override config
npx cs-playwright-test --project=myproject --base-url=https://staging.example.com</code></pre>
            </section>

            <!-- API REFERENCE -->
            <section id="api-reference">
                <h2>API Reference</h2>

                <h3>Module Exports</h3>
                <table>
                    <thead>
                        <tr><th>Import Path</th><th>Key Exports</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>@.../spec</code></td><td>describe, test, beforeAll, beforeEach, afterAll, afterEach</td></tr>
                        <tr><td><code>@.../bdd</code></td><td>CSBDDStepDef, Page, StepDefinitions, Given, When, Then</td></tr>
                        <tr><td><code>@.../core</code></td><td>CSBasePage, CSPage, CSGetElement, CSGetElements, CSConfigurationManager</td></tr>
                        <tr><td><code>@.../element</code></td><td>CSWebElement, CSElementResolver</td></tr>
                        <tr><td><code>@.../browser</code></td><td>CSBrowserManager, CSBrowserPool</td></tr>
                        <tr><td><code>@.../api</code></td><td>CSAPIClient, CSAPIRunner, CSAPIValidator, CSRequestBuilder</td></tr>
                        <tr><td><code>@.../database</code></td><td>CSDatabase, CSDatabaseManager</td></tr>
                        <tr><td><code>@.../reporting</code></td><td>CSReporter, CSHTMLReporter</td></tr>
                        <tr><td><code>@.../evidence</code></td><td>CSEvidenceCollector</td></tr>
                        <tr><td><code>@.../ai</code></td><td>CSIntelligentAI, CSAIEngine</td></tr>
                        <tr><td><code>@.../self-healing</code></td><td>CSSelfHealingEngine</td></tr>
                        <tr><td><code>@.../assertions</code></td><td>CSAssert, CSExpect</td></tr>
                        <tr><td><code>@.../utils</code></td><td>CSStringUtility, CSDateTimeUtility, CSExcelUtility, etc.</td></tr>
                        <tr><td><code>@.../network</code></td><td>CSNetworkInterceptor</td></tr>
                        <tr><td><code>@.../performance</code></td><td>CSPerformanceTestRunner, CSPerformanceReporter</td></tr>
                        <tr><td><code>@.../visual</code></td><td>CSVisualTesting</td></tr>
                        <tr><td><code>@.../mobile</code></td><td>CSMobileTesting</td></tr>
                        <tr><td><code>@.../media</code></td><td>CSVideoRecorder, CSScreenshotManager</td></tr>
                        <tr><td><code>@.../monitoring</code></td><td>CSPerformanceMonitor</td></tr>
                        <tr><td><code>@.../ado</code></td><td>CSADOIntegration, CSADOPublisher</td></tr>
                    </tbody>
                </table>
            </section>

            <!-- BEST PRACTICES -->
            <section id="best-practices">
                <h2>Best Practices</h2>

                <h3>Page Object Design</h3>
                <div class="info-box tip">
                    <ul>
                        <li>Use <code>@CSPage</code> decorator with unique identifiers</li>
                        <li>Expose business methods, not raw element interactions</li>
                        <li>Enable <code>selfHeal</code> for critical elements</li>
                        <li>Provide <code>alternativeLocators</code> for fragile elements</li>
                        <li>Use meaningful <code>description</code> for debugging</li>
                    </ul>
                </div>

                <h3>Test Organization</h3>
                <div class="info-box tip">
                    <ul>
                        <li>Group related tests in describe blocks</li>
                        <li>Use serial mode for dependent tests</li>
                        <li>Keep tests independent when using parallel mode</li>
                        <li>Use beforeEach for common setup</li>
                        <li>Clean up resources in afterEach/afterAll</li>
                    </ul>
                </div>

                <h3>Data-Driven Tests</h3>
                <div class="info-box tip">
                    <ul>
                        <li>Use external data sources for large datasets</li>
                        <li>Apply filters to run specific data rows</li>
                        <li>Use <code>{variable}</code> in test names for clarity</li>
                        <li>Set <code>useData: false</code> for setup/cleanup tests</li>
                    </ul>
                </div>

                <h3>Error Handling</h3>
                <div class="info-box warning">
                    <ul>
                        <li>Let the framework handle expected failures</li>
                        <li>Use try/catch only for recovery scenarios</li>
                        <li>Always use CSReporter for logging, not console.log</li>
                        <li>Capture evidence before throwing errors</li>
                    </ul>
                </div>

                <h3>Performance</h3>
                <div class="info-box note">
                    <ul>
                        <li>Use <code>SMART_WAIT_LEVEL=minimal</code> for stable apps</li>
                        <li>Enable browser reuse in parallel mode</li>
                        <li>Avoid unnecessary screenshots in passing tests</li>
                        <li>Use video recording only on failure</li>
                    </ul>
                </div>

                <h3>CI/CD Integration</h3>
                <div class="info-box note">
                    <ul>
                        <li>Set <code>HEADLESS=true</code> for CI environments</li>
                        <li>Configure ADO integration for test result tracking</li>
                        <li>Use JUnit reporter for CI result parsing</li>
                        <li>Archive HTML reports and screenshots</li>
                    </ul>
                </div>
            </section>

            <!-- CORE/REGISTRY CLASSES -->
            <section id="core-registry">
                <h2>Core & Registry Classes</h2>
                <p>Advanced framework classes for page management, step loading, and module detection.</p>

                <h3>CSPageFactory</h3>
                <p>Factory for managing page object instances with decorator support for page class registration and element initialization.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Parameters</th></tr></thead>
                    <tbody>
                        <tr><td><code>registerPage(pageClass)</code></td><td>Register a page class (called by @CSPage decorator)</td><td>pageClass: any</td></tr>
                        <tr><td><code>getPage&lt;T&gt;(pageClass)</code></td><td>Get or create singleton instance of a page class</td><td>pageClass: new() => T</td></tr>
                        <tr><td><code>createPage&lt;T&gt;(pageClass)</code></td><td>Create a new instance of a page class</td><td>pageClass: new() => T</td></tr>
                        <tr><td><code>register(token, instance)</code></td><td>Register a dependency for injection</td><td>token: string, instance: any</td></tr>
                        <tr><td><code>resolve(token)</code></td><td>Resolve a registered dependency</td><td>token: string</td></tr>
                        <tr><td><code>clearAll()</code></td><td>Clear all cached page instances</td><td>-</td></tr>
                        <tr><td><code>getAllPages()</code></td><td>Get all registered page classes</td><td>Returns: Map&lt;string, any&gt;</td></tr>
                    </tbody>
                </table>

                <pre><code>import { CSPageFactory, CSPage, CSGetElement, CSInject } from '@mdakhan.mak/cs-playwright-test-framework/core';

// Register and get page instances
@CSPage('/dashboard')
class DashboardPage extends CSBasePage {
    @CSGetElement({ css: '.welcome-message' })
    welcomeMessage: CSWebElement;

    @CSGetElement({ css: 'button.logout', waitFor: 'visible' })
    logoutButton: CSWebElement;
}

// Get singleton instance
const dashboardPage = CSPageFactory.getPage(DashboardPage);

// Create new instance
const freshPage = CSPageFactory.createPage(DashboardPage);

// Dependency injection
CSPageFactory.register('apiClient', myApiClient);
const client = CSPageFactory.resolve('apiClient');</code></pre>

                <h3>CSPageRegistry</h3>
                <p>Lazy page loader for performance optimization. Scans page directories and registers pages without loading them upfront.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Parameters</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>Returns: CSPageRegistry</td></tr>
                        <tr><td><code>setPageDirectories(dirs)</code></td><td>Set custom page directories to scan</td><td>dirs: string[]</td></tr>
                        <tr><td><code>scanPages()</code></td><td>Scan directories and register pages</td><td>Returns: Promise&lt;void&gt;</td></tr>
                        <tr><td><code>getPageClass(name)</code></td><td>Get page class by name (lazy loads)</td><td>name: string</td></tr>
                        <tr><td><code>hasPage(name)</code></td><td>Check if page is registered</td><td>name: string</td></tr>
                        <tr><td><code>getPageNames()</code></td><td>Get all registered page names</td><td>Returns: string[]</td></tr>
                    </tbody>
                </table>

                <pre><code>import { CSPageRegistry } from '@mdakhan.mak/cs-playwright-test-framework/core';

const registry = CSPageRegistry.getInstance();

// Set custom page directories
registry.setPageDirectories([
    'test/myproject/pages',
    'test/common/pages'
]);

// Scan pages (doesn't load them yet)
await registry.scanPages();

// Check if page exists
if (registry.hasPage('LoginPage')) {
    const LoginPage = await registry.getPageClass('LoginPage');
    const loginPage = new LoginPage();
}

// Get all registered page names
const pageNames = registry.getPageNames();
console.log('Available pages:', pageNames);</code></pre>

                <h3>CSStepLoader</h3>
                <p>Selective step definition loader for performance. Loads only required step definitions based on module requirements.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Parameters</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get worker-aware singleton instance</td><td>Returns: CSStepLoader</td></tr>
                        <tr><td><code>loadRequiredSteps(requirements)</code></td><td>Load framework steps based on modules</td><td>requirements: ModuleRequirements</td></tr>
                        <tr><td><code>loadProjectSteps(project)</code></td><td>Load all project steps</td><td>project: string</td></tr>
                        <tr><td><code>loadSelectiveProjectSteps(project, featureFiles)</code></td><td>Load only required project steps</td><td>project: string, featureFiles?: string[]</td></tr>
                        <tr><td><code>isGroupLoaded(group)</code></td><td>Check if a step group is loaded</td><td>group: 'common' | 'api' | 'database' | 'soap'</td></tr>
                        <tr><td><code>getLoadedGroups()</code></td><td>Get all loaded step groups</td><td>Returns: StepGroup[]</td></tr>
                    </tbody>
                </table>

                <pre><code>import { CSStepLoader } from '@mdakhan.mak/cs-playwright-test-framework/core';

const stepLoader = CSStepLoader.getInstance();

// Load required framework steps
await stepLoader.loadRequiredSteps({
    browser: true,
    api: true,
    database: false,
    soap: false
});

// Load project-specific steps
await stepLoader.loadProjectSteps('myproject');

// Check if step group is loaded
if (stepLoader.isGroupLoaded('api')) {
    console.log('API steps are available');
}</code></pre>

                <h3>CSModuleDetector</h3>
                <p>Intelligent module detection system. Detects which modules (Browser, API, Database, SOAP) are required based on tags and step patterns.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Parameters</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get worker-aware singleton instance</td><td>Returns: CSModuleDetector</td></tr>
                        <tr><td><code>detectRequirements(scenario, feature)</code></td><td>Detect module requirements for a scenario</td><td>scenario: ParsedScenario, feature: ParsedFeature</td></tr>
                        <tr><td><code>getRequirementsSummary(requirements)</code></td><td>Get summary string of detected modules</td><td>requirements: ModuleRequirements</td></tr>
                        <tr><td><code>isBrowserRequired(requirements)</code></td><td>Check if browser is required</td><td>requirements: ModuleRequirements</td></tr>
                    </tbody>
                </table>

                <h4>Module Detection Tags</h4>
                <table>
                    <thead><tr><th>Module</th><th>Tags</th></tr></thead>
                    <tbody>
                        <tr><td>Browser/UI</td><td><code>@ui</code>, <code>@browser</code>, <code>@web</code></td></tr>
                        <tr><td>API</td><td><code>@api</code>, <code>@rest</code>, <code>@http</code></td></tr>
                        <tr><td>Database</td><td><code>@database</code>, <code>@db</code>, <code>@sql</code></td></tr>
                        <tr><td>SOAP</td><td><code>@soap</code></td></tr>
                    </tbody>
                </table>

                <h4>Configuration Options</h4>
                <table>
                    <thead><tr><th>Variable</th><th>Description</th><th>Default</th></tr></thead>
                    <tbody>
                        <tr><td><code>MODULE_DETECTION_ENABLED</code></td><td>Enable auto-detection</td><td>true</td></tr>
                        <tr><td><code>MODULE_DETECTION_MODE</code></td><td>Detection mode: explicit, auto, hybrid</td><td>hybrid</td></tr>
                        <tr><td><code>BROWSER_ALWAYS_LAUNCH</code></td><td>Always launch browser</td><td>false</td></tr>
                        <tr><td><code>MODULES</code></td><td>Explicit module list</td><td>-</td></tr>
                    </tbody>
                </table>
            </section>

            <!-- ADO INTEGRATION CLASSES -->
            <section id="ado-integration-classes">
                <h2>ADO Integration Classes</h2>
                <p>Classes for Azure DevOps integration including API client, configuration, and tag extraction.</p>

                <h3>CSADOClient</h3>
                <p>Primary client for communicating with Azure DevOps APIs. Handles test cases, runs, results, bug creation, and attachments.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSADOClient</td></tr>
                        <tr><td><code>getTestCase(testCaseId)</code></td><td>Fetch a test case from ADO</td><td>Promise&lt;TestCase&gt;</td></tr>
                        <tr><td><code>createTestRun(name, testPoints, planId)</code></td><td>Create a test run</td><td>Promise&lt;number&gt;</td></tr>
                        <tr><td><code>addTestResult(result, runId)</code></td><td>Add test result to a run</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>updateTestResult(result, runId)</code></td><td>Update existing test result</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>completeTestRun(runId)</code></td><td>Mark test run as completed</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>uploadTestRunAttachment(runId, filePath)</code></td><td>Upload attachment to run</td><td>Promise&lt;void&gt;</td></tr>
                        <tr><td><code>createBug(bug)</code></td><td>Create bug work item</td><td>Promise&lt;number&gt;</td></tr>
                        <tr><td><code>fetchTestPoints(planId, suiteId)</code></td><td>Fetch test points from ADO</td><td>Promise&lt;any[]&gt;</td></tr>
                    </tbody>
                </table>

                <pre><code>import { CSADOClient } from '@mdakhan.mak/cs-playwright-test-framework/ado';

const adoClient = CSADOClient.getInstance();

// Create a test run
const runId = await adoClient.createTestRun('Automation Run', [123, 124, 125], 417);

// Add test result
await adoClient.addTestResult({
    testCaseId: 419,
    outcome: 'Passed',
    duration: 5000,
    errorMessage: undefined
}, runId);

// Upload attachment
await adoClient.uploadTestRunAttachment(runId, './reports/test-report.html');

// Complete the run
await adoClient.completeTestRun(runId);

// Create bug on failure
const bugId = await adoClient.createBug({
    title: 'Test Failed: Login Test',
    description: 'Login failed with invalid credentials',
    severity: '2 - High',
    priority: 1
});</code></pre>

                <h3>CSADOConfiguration</h3>
                <p>Configuration manager for Azure DevOps integration. Centralizes all ADO settings loading and validation.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSADOConfiguration</td></tr>
                        <tr><td><code>initialize()</code></td><td>Initialize configuration</td><td>void</td></tr>
                        <tr><td><code>isEnabled()</code></td><td>Check if ADO is enabled</td><td>boolean</td></tr>
                        <tr><td><code>getAuthHeaders()</code></td><td>Get HTTP auth headers</td><td>Record&lt;string, string&gt;</td></tr>
                        <tr><td><code>buildUrl(endpoint, params)</code></td><td>Build complete API URL</td><td>string</td></tr>
                        <tr><td><code>getTestPlanId()</code></td><td>Get configured test plan ID</td><td>number | undefined</td></tr>
                        <tr><td><code>getTestSuiteId()</code></td><td>Get configured test suite ID</td><td>number | undefined</td></tr>
                        <tr><td><code>shouldCreateBugsOnFailure()</code></td><td>Check bug creation setting</td><td>boolean</td></tr>
                        <tr><td><code>shouldUploadAttachments()</code></td><td>Check attachment upload setting</td><td>boolean</td></tr>
                    </tbody>
                </table>

                <h4>Configuration Environment Variables</h4>
                <table>
                    <thead><tr><th>Variable</th><th>Description</th><th>Default</th></tr></thead>
                    <tbody>
                        <tr><td><code>ADO_INTEGRATION_ENABLED</code></td><td>Enable ADO integration</td><td>false</td></tr>
                        <tr><td><code>ADO_ORGANIZATION</code></td><td>Organization name</td><td>-</td></tr>
                        <tr><td><code>ADO_PROJECT</code></td><td>Project name</td><td>-</td></tr>
                        <tr><td><code>ADO_PAT</code></td><td>Personal Access Token</td><td>-</td></tr>
                        <tr><td><code>ADO_TEST_PLAN_ID</code></td><td>Test plan ID</td><td>-</td></tr>
                        <tr><td><code>ADO_TEST_SUITE_ID</code></td><td>Test suite ID</td><td>-</td></tr>
                        <tr><td><code>ADO_UPLOAD_SCREENSHOTS</code></td><td>Upload screenshots</td><td>true</td></tr>
                        <tr><td><code>ADO_UPLOAD_VIDEOS</code></td><td>Upload videos</td><td>true</td></tr>
                        <tr><td><code>ADO_CREATE_BUGS_ON_FAILURE</code></td><td>Create bugs on failure</td><td>false</td></tr>
                    </tbody>
                </table>

                <h3>CSADOTagExtractor</h3>
                <p>Extracts Azure DevOps metadata from scenario and feature tags with hierarchical inheritance.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Returns</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td><td>CSADOTagExtractor</td></tr>
                        <tr><td><code>extractMetadata(scenario, feature)</code></td><td>Extract ADO metadata from tags</td><td>ADOMetadata</td></tr>
                        <tr><td><code>hasADOMapping(scenario, feature)</code></td><td>Check if scenario has ADO mapping</td><td>boolean</td></tr>
                        <tr><td><code>formatADOTags(metadata)</code></td><td>Format metadata back to tags</td><td>string[]</td></tr>
                        <tr><td><code>parseTestCaseIds(value)</code></td><td>Parse test case IDs from string</td><td>number[]</td></tr>
                    </tbody>
                </table>

                <h4>Supported Tag Patterns</h4>
                <pre><code># Single test case
@TestCaseId:419

# Multiple test cases
@TestCaseId:{419,420,421}

# Test plan and suite
@TestPlanId:417
@TestSuiteId:418

# Build and release
@BuildId:123
@ReleaseId:456</code></pre>
            </section>

            <!-- DATABASE ADAPTERS -->
            <section id="database-adapters">
                <h2>Database Adapters</h2>
                <p>Database-specific adapters for connecting to and querying various database systems.</p>

                <h3>CSSQLServerAdapter (SQL Server)</h3>
                <p>Adapter for Microsoft SQL Server with Windows and SQL Authentication support.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>connect(config)</code></td><td>Connect to SQL Server</td></tr>
                        <tr><td><code>disconnect(connection)</code></td><td>Disconnect from server</td></tr>
                        <tr><td><code>query(connection, sql, params)</code></td><td>Execute SQL query</td></tr>
                        <tr><td><code>executeStoredProcedure(connection, name, params)</code></td><td>Execute stored procedure</td></tr>
                        <tr><td><code>beginTransaction(connection, options)</code></td><td>Start transaction</td></tr>
                        <tr><td><code>commitTransaction(connection)</code></td><td>Commit transaction</td></tr>
                        <tr><td><code>rollbackTransaction(connection)</code></td><td>Rollback transaction</td></tr>
                        <tr><td><code>bulkInsert(connection, table, data)</code></td><td>Bulk insert rows</td></tr>
                    </tbody>
                </table>

                <h4>Connection Options</h4>
                <table>
                    <thead><tr><th>Option</th><th>Description</th><th>Default</th></tr></thead>
                    <tbody>
                        <tr><td><code>trustedConnection</code></td><td>Use Windows Authentication</td><td>false</td></tr>
                        <tr><td><code>odbcDriver</code></td><td>ODBC driver name</td><td>ODBC Driver 17 for SQL Server</td></tr>
                        <tr><td><code>trustServerCertificate</code></td><td>Trust server certificate</td><td>false</td></tr>
                        <tr><td><code>poolSize</code></td><td>Max pool connections</td><td>10</td></tr>
                    </tbody>
                </table>

                <h3>CSPostgreSQLAdapter</h3>
                <p>Adapter for PostgreSQL with streaming and savepoint support.</p>

                <pre><code>import { CSDatabaseManager } from '@mdakhan.mak/cs-playwright-test-framework/database';

const dbManager = CSDatabaseManager.getInstance();

// PostgreSQL connection
const connection = await dbManager.connect({
    type: 'postgresql',
    host: 'localhost',
    port: 5432,
    database: 'testdb',
    username: 'postgres',
    password: 'password'
});

// Execute query with parameters
const result = await dbManager.query(connection,
    'SELECT * FROM users WHERE status = $1',
    ['active']
);

// Streaming large result sets
const stream = await dbManager.stream(connection,
    'SELECT * FROM large_table'
);
for await (const row of stream) {
    console.log(row);
}

// Savepoints
await dbManager.createSavepoint(connection, 'before_update');
await dbManager.query(connection, 'UPDATE users SET status = $1', ['inactive']);
await dbManager.rollbackToSavepoint(connection, 'before_update');</code></pre>

                <h3>CSMySQLAdapter</h3>
                <p>Adapter for MySQL/MariaDB with connection pooling.</p>

                <h3>CSOracleAdapter</h3>
                <p>Adapter for Oracle Database with wallet authentication support.</p>

                <h3>CSMongoDBAdapter</h3>
                <p>Adapter for MongoDB with transaction and aggregation support.</p>

                <pre><code>// MongoDB connection
const connection = await dbManager.connect({
    type: 'mongodb',
    connectionString: 'mongodb://localhost:27017',
    database: 'testdb'
});

// MongoDB query (find)
const result = await dbManager.query(connection,
    'db.users.find({ status: "active" })'
);

// Aggregation pipeline
const aggregateResult = await dbManager.query(connection,
    'db.orders.aggregate([{ $group: { _id: "$status", count: { $sum: 1 } } }])'
);

// Transactions
await dbManager.beginTransaction(connection);
await dbManager.query(connection, 'db.users.insertOne({ name: "John" })');
await dbManager.commitTransaction(connection);</code></pre>

                <h3>CSRedisAdapter</h3>
                <p>Adapter for Redis with Pub/Sub, streams, and Lua script support.</p>

                <pre><code>// Redis connection
const connection = await dbManager.connect({
    type: 'redis',
    host: 'localhost',
    port: 6379,
    db: 0
});

// String operations
await dbManager.query(connection, 'SET user:1 "John"');
const user = await dbManager.query(connection, 'GET user:1');

// Hash operations
await dbManager.query(connection, 'HSET user:1:profile name "John" age 30');
const profile = await dbManager.query(connection, 'HGETALL user:1:profile');

// Pub/Sub
await dbManager.subscribe('notifications', (message) => {
    console.log('Received:', message);
});
await dbManager.publish('notifications', 'Hello World');

// Lua scripts
const result = await dbManager.executeStoredProcedure(connection,
    'return redis.call("incr", KEYS[1])',
    { KEYS: ['counter'] }
);</code></pre>

                <h3>Database Adapter Comparison</h3>
                <table>
                    <thead><tr><th>Adapter</th><th>Transactions</th><th>Prepared Statements</th><th>Stored Procedures</th><th>Streaming</th><th>Savepoints</th></tr></thead>
                    <tbody>
                        <tr><td>SQL Server</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr>
                        <tr><td>PostgreSQL</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>MySQL</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>Oracle</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
                        <tr><td>MongoDB</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr>
                        <tr><td>Redis</td><td>Yes</td><td>No</td><td>Lua Scripts</td><td>Yes</td><td>No</td></tr>
                    </tbody>
                </table>
            </section>

            <!-- UTILITY CLASSES -->
            <section id="utility-classes">
                <h2>Utility Classes</h2>
                <p>Comprehensive utility classes for data manipulation, file operations, and comparisons.</p>

                <h3>CSArrayUtility</h3>
                <p>Comprehensive array manipulation with null-safe operations and functional programming patterns.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th><th>Example</th></tr></thead>
                    <tbody>
                        <tr><td><code>unique(array, key?)</code></td><td>Remove duplicates</td><td><code>CSArrayUtility.unique([1, 2, 2, 3])</code></td></tr>
                        <tr><td><code>chunk(array, size)</code></td><td>Split into chunks</td><td><code>CSArrayUtility.chunk([1, 2, 3, 4], 2)</code></td></tr>
                        <tr><td><code>flatten(array, depth)</code></td><td>Flatten nested arrays</td><td><code>CSArrayUtility.flatten([[1, 2], [3, 4]])</code></td></tr>
                        <tr><td><code>groupBy(array, keyFn)</code></td><td>Group by key function</td><td><code>CSArrayUtility.groupBy(users, u => u.role)</code></td></tr>
                        <tr><td><code>partition(array, predicate)</code></td><td>Split into matching/non-matching</td><td><code>CSArrayUtility.partition(nums, n => n > 0)</code></td></tr>
                        <tr><td><code>intersection(...arrays)</code></td><td>Find common elements</td><td><code>CSArrayUtility.intersection([1, 2], [2, 3])</code></td></tr>
                        <tr><td><code>difference(array1, array2)</code></td><td>Elements in first but not second</td><td><code>CSArrayUtility.difference([1, 2, 3], [2])</code></td></tr>
                        <tr><td><code>shuffle(array)</code></td><td>Fisher-Yates shuffle</td><td><code>CSArrayUtility.shuffle([1, 2, 3, 4, 5])</code></td></tr>
                        <tr><td><code>sample(array, count)</code></td><td>Random sample</td><td><code>CSArrayUtility.sample(items, 3)</code></td></tr>
                        <tr><td><code>sortBy(array, ...compareFns)</code></td><td>Multi-key sort</td><td><code>CSArrayUtility.sortBy(users, byName, byAge)</code></td></tr>
                        <tr><td><code>sum(array)</code></td><td>Sum values</td><td><code>CSArrayUtility.sum([1, 2, 3])</code></td></tr>
                        <tr><td><code>average(array)</code></td><td>Calculate average</td><td><code>CSArrayUtility.average([1, 2, 3])</code></td></tr>
                        <tr><td><code>median(array)</code></td><td>Median value</td><td><code>CSArrayUtility.median([1, 2, 3, 4, 5])</code></td></tr>
                    </tbody>
                </table>

                <h3>CSJsonUtility</h3>
                <p>Comprehensive JSON operations including parsing, validation, transformation, and comparison.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>readFile(filePath)</code></td><td>Read and parse JSON file</td></tr>
                        <tr><td><code>writeFile(data, filePath, options)</code></td><td>Write to JSON file</td></tr>
                        <tr><td><code>safeParse(jsonString, defaultValue)</code></td><td>Safe parse with default</td></tr>
                        <tr><td><code>getValueAtPath(data, path)</code></td><td>Get value at dot-notation path</td></tr>
                        <tr><td><code>setValueAtPath(data, path, value)</code></td><td>Set value at path</td></tr>
                        <tr><td><code>merge(target, source)</code></td><td>Deep merge objects</td></tr>
                        <tr><td><code>flatten(data, separator)</code></td><td>Flatten nested structure</td></tr>
                        <tr><td><code>deepEquals(obj1, obj2)</code></td><td>Deep comparison</td></tr>
                        <tr><td><code>getDifferences(obj1, obj2)</code></td><td>Get differences between objects</td></tr>
                    </tbody>
                </table>

                <pre><code>import { CSJsonUtility } from '@mdakhan.mak/cs-playwright-test-framework/utilities';

// Read and parse JSON
const config = CSJsonUtility.readFile('./config.json');

// Get value at path
const apiUrl = CSJsonUtility.getValueAtPath(config, 'api.baseUrl');

// Deep merge
const merged = CSJsonUtility.merge(defaultConfig, userConfig);

// Flatten nested structure
const flat = CSJsonUtility.flatten({ user: { name: 'John', age: 30 } });
// Result: { 'user.name': 'John', 'user.age': 30 }

// Compare files
const diff = CSJsonUtility.compareFiles('expected.json', 'actual.json');
if (!diff.areEqual) {
    console.log('Differences:', diff.differences);
}</code></pre>

                <h3>CSCsvUtility</h3>
                <p>Comprehensive CSV file operations with reading, writing, transformation, and comparison.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>readAsJSON(filePath, options)</code></td><td>Read as JSON objects</td></tr>
                        <tr><td><code>readAsArray(filePath, options)</code></td><td>Read as 2D array</td></tr>
                        <tr><td><code>writeFromJSON(data, filePath, options)</code></td><td>Write from objects</td></tr>
                        <tr><td><code>getHeaders(filePath)</code></td><td>Get header row</td></tr>
                        <tr><td><code>getRowCount(filePath)</code></td><td>Count rows</td></tr>
                        <tr><td><code>findRows(filePath, predicate)</code></td><td>Find matching rows</td></tr>
                        <tr><td><code>mergeCSVFiles(filePaths, outputPath)</code></td><td>Merge multiple CSV files</td></tr>
                        <tr><td><code>compareCSVFiles(file1, file2)</code></td><td>Compare two CSV files</td></tr>
                    </tbody>
                </table>

                <h3>CSTextUtility</h3>
                <p>Comprehensive text file operations including reading, writing, searching, and transformation.</p>

                <pre><code>import { CSTextUtility } from '@mdakhan.mak/cs-playwright-test-framework/utilities';

// Read file
const content = CSTextUtility.readFile('./log.txt');

// Read specific lines
const firstLines = CSTextUtility.readFirstLines('./log.txt', 10);
const lastLines = CSTextUtility.readLastLines('./log.txt', 10);

// Search text
const searchResult = CSTextUtility.searchText('./log.txt', 'ERROR');
console.log(`Found ${searchResult.count} occurrences`);

// Find lines containing pattern
const errorLines = CSTextUtility.findLinesContaining('./log.txt', 'ERROR');
errorLines.forEach(line => console.log(`Line ${line.lineNumber}: ${line.content}`));

// Replace text
CSTextUtility.replaceAll('./config.txt', 'localhost', 'production.server.com');

// Get file metadata
const metadata = CSTextUtility.getFileMetadata('./document.txt');
console.log(`Lines: ${metadata.lineCount}, Words: ${metadata.wordCount}`);</code></pre>

                <h3>CSComparisonUtility</h3>
                <p>Generic comparison utility for various file formats with smart type detection.</p>

                <pre><code>import { CSComparisonUtility } from '@mdakhan.mak/cs-playwright-test-framework/utilities';

// Smart comparison (auto-detects file type)
const result = await CSComparisonUtility.smartCompare('expected.xlsx', 'actual.xlsx');
console.log(`Files are equal: ${result.areEqual}`);

// Compare JSON files
const jsonDiff = CSComparisonUtility.compareJSONFiles('expected.json', 'actual.json');
if (!jsonDiff.areEqual) {
    jsonDiff.differences.forEach(diff => {
        console.log(`${diff.path}: ${diff.value1} vs ${diff.value2}`);
    });
}

// Compare CSV files
const csvDiff = CSComparisonUtility.compareCSVFiles('expected.csv', 'actual.csv');

// Cross-format comparison
const crossCompare = CSComparisonUtility.compareExcelToCSV('data.xlsx', 'data.csv');

// Batch comparison
const batchResults = await CSComparisonUtility.batchCompare([
    { file1: 'expected1.json', file2: 'actual1.json' },
    { file1: 'expected2.csv', file2: 'actual2.csv' }
]);

// Assert equality (throws if not equal)
CSComparisonUtility.assertJSONFilesEqual('expected.json', 'actual.json');</code></pre>

                <h3>CSPdfUtility</h3>
                <p>Comprehensive PDF operations including generation, extraction, and comparison.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>generateFromHTML(html, outputPath, options)</code></td><td>Generate PDF from HTML</td></tr>
                        <tr><td><code>generateFromURL(url, outputPath, options)</code></td><td>Generate PDF from URL</td></tr>
                        <tr><td><code>generateFromMarkdown(markdown, outputPath)</code></td><td>Generate PDF from Markdown</td></tr>
                        <tr><td><code>extractText(pdfPath)</code></td><td>Extract text content</td></tr>
                        <tr><td><code>comparePDFsText(file1, file2)</code></td><td>Compare PDF text content</td></tr>
                        <tr><td><code>comparePDFsVisually(file1, file2)</code></td><td>Visual PDF comparison</td></tr>
                    </tbody>
                </table>
            </section>

            <!-- REPORT GENERATORS -->
            <section id="report-generators">
                <h2>Report Generators</h2>
                <p>Classes for generating various report formats including HTML, Excel, PDF, and consolidated reports.</p>

                <h3>CSHtmlReportGenerator</h3>
                <p>Generates enterprise-grade HTML reports with multiple interactive views, real-time filtering, and charts.</p>

                <pre><code>import { CSHtmlReportGenerator } from '@mdakhan.mak/cs-playwright-test-framework/reporting';

const generator = new CSHtmlReportGenerator();

// Generate report from test suite
await generator.generateReport(testSuite, './reports');

// Output includes:
// - index.html (main interactive report)
// - report-data.json (JSON data export)
// - execution-history.json (trend data)</code></pre>

                <h4>Report Views</h4>
                <table>
                    <thead><tr><th>View</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td>Dashboard</td><td>KPIs, statistics, environment info</td></tr>
                        <tr><td>Test Scenarios</td><td>Detailed test results with steps</td></tr>
                        <tr><td>Timeline</td><td>Execution timeline with worker lanes</td></tr>
                        <tr><td>Failure Analysis</td><td>Error categorization and patterns</td></tr>
                        <tr><td>Categories</td><td>Tag-based grouping</td></tr>
                        <tr><td>Artifacts</td><td>Screenshots, videos, traces</td></tr>
                    </tbody>
                </table>

                <h3>CSExcelReportGenerator</h3>
                <p>Generates professional Excel reports with multiple worksheets and charts.</p>

                <pre><code>import { CSExcelReportGenerator } from '@mdakhan.mak/cs-playwright-test-framework/reporting';

const excelGenerator = new CSExcelReportGenerator();
await excelGenerator.generateReport(testSuite, './reports');

// Output: test-report.xlsx with worksheets:
// - Dashboard (KPI cards, charts)
// - Test Scenarios (detailed results)
// - Test Steps (step-level details)
// - Failure Analysis (error breakdown)
// - Performance (metrics and trends)
// - History (execution history)</code></pre>

                <h3>CSPdfReportGenerator</h3>
                <p>Generates PDF reports from HTML reports using Playwright's PDF rendering.</p>

                <pre><code>import { CSPdfReportGenerator } from '@mdakhan.mak/cs-playwright-test-framework/reporting';

const pdfGenerator = new CSPdfReportGenerator();

// Standard PDF
await pdfGenerator.generateReport('./reports/index.html', './reports');

// Custom PDF with options
await pdfGenerator.generateCustomPdfReport('./reports/index.html', './reports', {
    includeCharts: true,
    includeScreenshots: true,
    orientation: 'landscape',
    pageSize: 'A3'
});

// Multi-view PDF (separate PDFs for each view)
await pdfGenerator.generateMultiViewPdfReport('./reports/index.html', './reports');</code></pre>

                <h3>CSConsolidatedReportGenerator</h3>
                <p>Generates multi-project suite-level consolidated reports.</p>

                <pre><code>import { CSConsolidatedReportGenerator } from '@mdakhan.mak/cs-playwright-test-framework/suite';

const consolidatedGenerator = new CSConsolidatedReportGenerator();

// Generate report for multiple projects
const reportPath = await consolidatedGenerator.generateReport(suiteResult, './reports');

// Output includes:
// - Dashboard with project overview
// - Project-level success rates
// - Scenario rollup statistics
// - Cross-project timeline</code></pre>

                <h3>CSTestResultsManager</h3>
                <p>Manages test results directory structure and artifact capture configuration.</p>

                <table>
                    <thead><tr><th>Method</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>getInstance()</code></td><td>Get singleton instance</td></tr>
                        <tr><td><code>initializeTestRun(project)</code></td><td>Initialize directory structure</td></tr>
                        <tr><td><code>getDirectories()</code></td><td>Get all artifact directory paths</td></tr>
                        <tr><td><code>getArtifactPath(type, scenarioName, status)</code></td><td>Get artifact path</td></tr>
                        <tr><td><code>shouldCaptureArtifact(type, testPassed)</code></td><td>Check if artifact should be captured</td></tr>
                        <tr><td><code>createTestResultsZip()</code></td><td>Create ZIP archive</td></tr>
                        <tr><td><code>finalizeTestRun()</code></td><td>Finalize run and optionally ZIP</td></tr>
                    </tbody>
                </table>

                <h4>Artifact Capture Modes</h4>
                <table>
                    <thead><tr><th>Mode</th><th>Description</th></tr></thead>
                    <tbody>
                        <tr><td><code>always</code></td><td>Capture for all tests</td></tr>
                        <tr><td><code>on-failure</code></td><td>Capture only on failure</td></tr>
                        <tr><td><code>on-success</code></td><td>Capture only on success</td></tr>
                        <tr><td><code>never</code></td><td>Never capture</td></tr>
                    </tbody>
                </table>

                <pre><code>import { CSTestResultsManager } from '@mdakhan.mak/cs-playwright-test-framework/reporting';

const resultsManager = CSTestResultsManager.getInstance();

// Initialize test run
const testRunDir = resultsManager.initializeTestRun('myproject');

// Get directories
const dirs = resultsManager.getDirectories();
console.log('Screenshots:', dirs.screenshots);
console.log('Videos:', dirs.videos);

// Check if should capture
if (resultsManager.shouldCaptureArtifact('screenshot', false)) {
    // Capture screenshot for failed test
    const path = resultsManager.getArtifactPath('screenshot', 'Login Test', 'fail');
}

// Finalize and ZIP
const finalPath = await resultsManager.finalizeTestRun();</code></pre>

                <h3>CSReportAggregator</h3>
                <p>Aggregates test results from parallel execution workers into a single comprehensive report.</p>

                <pre><code>import { CSReportAggregator } from '@mdakhan.mak/cs-playwright-test-framework/reporting';

const aggregator = CSReportAggregator.getInstance();

// Aggregate results from parallel workers
await aggregator.aggregateParallelResults(scenarios, artifacts);

// Get aggregated results
const results = aggregator.getResults();

// Clear for new run
aggregator.clearResults();</code></pre>
            </section>

            <!-- Footer -->
            <footer style="margin-top: 60px; padding: 30px 0; border-top: 1px solid var(--border); text-align: center; color: var(--text-light);">
                <p>CS Playwright Test Framework Documentation</p>
                <p style="font-size: 0.85rem;">Generated with comprehensive module analysis</p>
            </footer>
        </main>
    </div>

    <script>
        // Highlight active navigation - supports sections AND subsections (h3[id], h4[id])
        document.addEventListener('scroll', () => {
            const navLinks = document.querySelectorAll('.nav-section a');

            // Collect all navigable elements (sections, h3[id], h4[id])
            const allTargets = [];
            document.querySelectorAll('section[id]').forEach(el => {
                allTargets.push({ id: el.id, top: el.offsetTop, type: 'section' });
            });
            document.querySelectorAll('h3[id], h4[id]').forEach(el => {
                allTargets.push({ id: el.id, top: el.offsetTop, type: 'subsection' });
            });

            // Sort by position (top)
            allTargets.sort((a, b) => a.top - b.top);

            // Find current active target
            let current = '';
            let currentParentSection = '';
            const scrollPos = scrollY + 120;

            for (let i = allTargets.length - 1; i >= 0; i--) {
                if (scrollPos >= allTargets[i].top) {
                    current = allTargets[i].id;
                    break;
                }
            }

            // Update active states
            navLinks.forEach(link => {
                link.classList.remove('active');
                const href = link.getAttribute('href');
                if (href === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });

        // Smooth scroll for navigation with active state update
        document.querySelectorAll('.nav-section a').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const href = this.getAttribute('href');
                const target = document.querySelector(href);
                if (target) {
                    // Remove active from all, add to clicked
                    document.querySelectorAll('.nav-section a').forEach(a => a.classList.remove('active'));
                    this.classList.add('active');

                    target.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // ========== SEARCH FUNCTIONALITY ==========
        (function() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            const searchClear = document.getElementById('searchClear');
            let searchIndex = [];
            let debounceTimer;

            // Build search index from page content
            function buildSearchIndex() {
                searchIndex = [];
                const sections = document.querySelectorAll('section[id]');
                let indexCounter = 0;

                sections.forEach(section => {
                    const sectionId = section.id;
                    const sectionTitle = section.querySelector('h2')?.textContent || sectionId;

                    // Index section title
                    searchIndex.push({
                        idx: indexCounter++,
                        type: 'section',
                        id: sectionId,
                        title: sectionTitle,
                        content: sectionTitle,
                        element: section.querySelector('h2')
                    });

                    // Index h3 subsections
                    section.querySelectorAll('h3').forEach(h3 => {
                        searchIndex.push({
                            idx: indexCounter++,
                            type: 'subsection',
                            id: sectionId,
                            title: h3.textContent,
                            section: sectionTitle,
                            content: h3.textContent,
                            element: h3
                        });
                    });

                    // Index h4 items
                    section.querySelectorAll('h4').forEach(h4 => {
                        searchIndex.push({
                            idx: indexCounter++,
                            type: 'item',
                            id: sectionId,
                            title: h4.textContent,
                            section: sectionTitle,
                            content: h4.textContent,
                            element: h4
                        });
                    });

                    // Index code blocks (for method/class names)
                    section.querySelectorAll('pre code').forEach(code => {
                        const text = code.textContent;
                        // Extract class names, method names, imports
                        const patterns = [
                            /class\s+(\w+)/g,
                            /function\s+(\w+)/g,
                            /const\s+(\w+)\s*=/g,
                            /import\s*\{([^}]+)\}/g,
                            /@(\w+)\(/g,
                            /(\w+)\.getInstance\(\)/g
                        ];

                        patterns.forEach(pattern => {
                            let match;
                            while ((match = pattern.exec(text)) !== null) {
                                const term = match[1].trim();
                                if (term.length > 2 && !searchIndex.find(i => i.title === term && i.id === sectionId)) {
                                    searchIndex.push({
                                        idx: indexCounter++,
                                        type: 'code',
                                        id: sectionId,
                                        title: term,
                                        section: sectionTitle,
                                        content: text.substring(Math.max(0, match.index - 30), Math.min(text.length, match.index + term.length + 30)),
                                        element: code.closest('pre')
                                    });
                                }
                            }
                        });
                    });

                    // Index table content
                    section.querySelectorAll('table td:first-child code').forEach(td => {
                        const term = td.textContent.trim();
                        if (term && term.length > 1) {
                            searchIndex.push({
                                idx: indexCounter++,
                                type: 'table',
                                id: sectionId,
                                title: term,
                                section: sectionTitle,
                                content: td.closest('tr')?.textContent?.substring(0, 100) || term,
                                element: td.closest('tr')
                            });
                        }
                    });
                });

                console.log('Search index built: ' + searchIndex.length + ' items');
            }

            // Perform search
            function performSearch(query) {
                if (!query || query.length < 2) {
                    searchResults.classList.remove('active');
                    searchClear.style.display = 'none';
                    return;
                }

                searchClear.style.display = 'block';
                const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 1);

                const results = searchIndex
                    .map(item => {
                        const titleLower = item.title.toLowerCase();
                        const contentLower = item.content.toLowerCase();
                        let score = 0;

                        terms.forEach(term => {
                            // Exact title match
                            if (titleLower === term) score += 100;
                            // Title starts with term
                            else if (titleLower.startsWith(term)) score += 50;
                            // Title contains term
                            else if (titleLower.includes(term)) score += 25;
                            // Content contains term
                            else if (contentLower.includes(term)) score += 10;
                        });

                        // Boost sections and subsections
                        if (item.type === 'section') score *= 1.5;
                        else if (item.type === 'subsection') score *= 1.3;

                        return { ...item, score };
                    })
                    .filter(item => item.score > 0)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 15);

                renderResults(results, query);
            }

            // Render search results
            function renderResults(results, query) {
                if (results.length === 0) {
                    searchResults.innerHTML = '<div class="search-no-results">No results found for "<strong>' + escapeHtml(query) + '</strong>"</div>';
                    searchResults.classList.add('active');
                    return;
                }

                let html = '<div class="search-stats">' + results.length + ' result' + (results.length > 1 ? 's' : '') + ' found</div>';

                results.forEach(function(result) {
                    html += '<div class="search-result-item" data-section="' + result.id + '" data-idx="' + result.idx + '">';
                    html += '<div class="search-result-section">' + escapeHtml(result.section || result.id) + '</div>';
                    html += '<div class="search-result-title">' + highlightTerms(result.title, query) + '</div>';
                    if (result.type === 'code' || result.type === 'table') {
                        html += '<div class="search-result-preview">' + highlightTerms(truncate(result.content, 80), query) + '</div>';
                    }
                    html += '</div>';
                });

                searchResults.innerHTML = html;
                searchResults.classList.add('active');

                // Add click handlers
                searchResults.querySelectorAll('.search-result-item').forEach(function(item) {
                    item.addEventListener('click', function() {
                        const idx = parseInt(this.dataset.idx);
                        const result = searchIndex.find(function(i) { return i.idx === idx; });
                        if (result && result.element) {
                            // Clear search
                            clearSearch();

                            // Scroll to element
                            result.element.scrollIntoView({ behavior: 'smooth', block: 'center' });

                            // Highlight element
                            result.element.classList.add('highlight-search');
                            setTimeout(function() {
                                result.element.classList.remove('highlight-search');
                            }, 3000);
                        } else {
                            // Fallback: navigate to section
                            const sectionId = this.dataset.section;
                            const section = document.getElementById(sectionId);
                            if (section) {
                                clearSearch();
                                section.scrollIntoView({ behavior: 'smooth' });
                            }
                        }
                    });
                });
            }

            // Helper functions
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            function highlightTerms(text, query) {
                const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 1);
                let result = escapeHtml(text);
                terms.forEach(term => {
                    const regex = new RegExp('(' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'gi');
                    result = result.replace(regex, '<mark>$1</mark>');
                });
                return result;
            }

            function truncate(text, length) {
                text = text.replace(/\s+/g, ' ').trim();
                if (text.length <= length) return text;
                return text.substring(0, length) + '...';
            }

            function clearSearch() {
                searchInput.value = '';
                searchResults.classList.remove('active');
                searchResults.innerHTML = '';
                searchClear.style.display = 'none';
            }

            // Event listeners
            searchInput.addEventListener('input', function(e) {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(function() {
                    performSearch(e.target.value.trim());
                }, 200);
            });

            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    clearSearch();
                    searchInput.blur();
                }
            });

            searchClear.addEventListener('click', clearSearch);

            // Keyboard shortcut: Ctrl+K or Cmd+K to focus search
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                    e.preventDefault();
                    searchInput.focus();
                    searchInput.select();
                }
                // Also support / for search (common in docs)
                if (e.key === '/' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    searchInput.focus();
                }
            });

            // Close search results when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.search-container')) {
                    searchResults.classList.remove('active');
                }
            });

            // Build index when page loads
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', buildSearchIndex);
            } else {
                buildSearchIndex();
            }
        })();
    </script>
</body>
</html>
